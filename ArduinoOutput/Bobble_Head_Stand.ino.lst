
C:\Users\LSabe\OneDrive\Desktop\Project stuff\Bobble Head Stand\ArduinoOutput/Bobble_Head_Stand.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
char readBlocking() {
  while (!Serial.available());
  return Serial.read();
}

uint16_t readnumber() {
       0:	00 18 00 20 c1 00 00 00 fd 09 00 00 c1 09 00 00     ... ............
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
      10:	c1 09 00 00 c1 09 00 00 c1 09 00 00 c1 09 00 00     ................
  while (! isdigit(c = readBlocking())) {
    //Serial.print(c);
  }
  Serial.print(c);
  x = c - '0';
  while (isdigit(c = readBlocking())) {
      20:	c1 09 00 00 c1 09 00 00 c1 09 00 00 fd 09 00 00     ................
    Serial.print(c);
    x *= 10;
      30:	fd 09 00 00 c1 09 00 00 91 23 00 00 99 23 00 00     .........#...#..
    x += c - '0';
      40:	fd 09 00 00 fd 09 00 00 fd 09 00 00 fd 09 00 00     ................
	begin_cycle = ARM_DWT_CYCCNT;
	*txreg = 0;
	wait_for_target(begin_cycle, target);
	// 8 data bits
	for (mask = 1; mask; mask <<= 1) {
		*txreg = (b & mask) ? 1 : 0;
      50:	fd 09 00 00 fd 09 00 00 fd 09 00 00 fd 09 00 00     ................
		target += cycles_per_bit;
      60:	fd 09 00 00 fd 09 00 00 fd 09 00 00 fd 09 00 00     ................
	for (mask = 1; mask; mask <<= 1) {
      70:	0d 0e 00 00 d9 13 00 00 31 15 00 00 fd 09 00 00     ........1.......
		wait_for_target(begin_cycle, target);
	}
	// stop bit
	*txreg = 1;
	interrupts();
	target += cycles_per_bit;
      80:	fd 09 00 00 fd 09 00 00 fd 09 00 00 fd 09 00 00     ................
	while (ARM_DWT_CYCCNT - begin_cycle < target) ; // wait
      90:	fd 09 00 00 fd 09 00 00 fd 09 00 00 fd 09 00 00     ................
      filesizes[files] *= 10;

      filesizes[files] += c - '0';
    }

    files++;
      a0:	05 18 00 00 fd 09 00 00 fd 09 00 00 fd 09 00 00     ................
    stream->read();
      b0:	fd 09 00 00 fd 09 00 00 fd 09 00 00 fd 09 00 00     ................

000000c0 <ResetHandler>:
	size_t printNumberAny(unsigned long n, uint8_t base);
	inline size_t printNumber(unsigned long n, uint8_t base, uint8_t sign) __attribute__((always_inline)) {
		// when "base" is a constant (pretty much always), the
		// compiler optimizes this to a single function call.
		if (base == 0) return write((uint8_t)n);
		if (base == 10 || base < 2) return printNumberDec(n, sign);
      c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		rounding *= 0.1;
	}
	number += rounding;

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
      c2:	f000 fc9f 	bl	a04 <startup_early_hook>
      c6:	4b48      	ldr	r3, [pc, #288]	; (1e8 <ResetHandler+0x128>)
      c8:	4a48      	ldr	r2, [pc, #288]	; (1ec <ResetHandler+0x12c>)
	double remainder = number - (double)int_part;
	count += printNumber(int_part, 10, sign);

	// Print the decimal point, but only if there are digits beyond
	if (digits > 0) {
      ca:	601a      	str	r2, [r3, #0]
      cc:	4b48      	ldr	r3, [pc, #288]	; (1f0 <ResetHandler+0x130>)
      ce:	4a49      	ldr	r2, [pc, #292]	; (1f4 <ResetHandler+0x134>)
      d0:	601a      	str	r2, [r3, #0]
	double remainder = number - (double)int_part;
      d2:	4b49      	ldr	r3, [pc, #292]	; (1f8 <ResetHandler+0x138>)
      d4:	4a49      	ldr	r2, [pc, #292]	; (1fc <ResetHandler+0x13c>)
      d6:	601a      	str	r2, [r3, #0]
      d8:	2308      	movs	r3, #8
      da:	4a49      	ldr	r2, [pc, #292]	; (200 <ResetHandler+0x140>)
      dc:	7811      	ldrb	r1, [r2, #0]
      de:	4219      	tst	r1, r3
      e0:	d002      	beq.n	e8 <ResetHandler+0x28>
      e2:	7811      	ldrb	r1, [r2, #0]
		uint8_t n, buf[16], count=1;
		buf[0] = '.';
      e4:	430b      	orrs	r3, r1
      e6:	7013      	strb	r3, [r2, #0]
      e8:	222a      	movs	r2, #42	; 0x2a

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;
      ea:	4b46      	ldr	r3, [pc, #280]	; (204 <ResetHandler+0x144>)
      ec:	4846      	ldr	r0, [pc, #280]	; (208 <ResetHandler+0x148>)
      ee:	701a      	strb	r2, [r3, #0]
      f0:	4b46      	ldr	r3, [pc, #280]	; (20c <ResetHandler+0x14c>)
      f2:	1ec1      	subs	r1, r0, #3
      f4:	2200      	movs	r2, #0
      f6:	428b      	cmp	r3, r1
      f8:	d303      	bcc.n	102 <ResetHandler+0x42>
      fa:	3303      	adds	r3, #3
		buf[0] = '.';
      fc:	1a1a      	subs	r2, r3, r0

		while (digits-- > 0) {
      fe:	0892      	lsrs	r2, r2, #2
     100:	0092      	lsls	r2, r2, #2
     102:	4943      	ldr	r1, [pc, #268]	; (210 <ResetHandler+0x150>)
     104:	f002 fb88 	bl	2818 <memcpy>
     108:	4842      	ldr	r0, [pc, #264]	; (214 <ResetHandler+0x154>)
     10a:	4b43      	ldr	r3, [pc, #268]	; (218 <ResetHandler+0x158>)
			remainder *= 10.0;
			n = (uint8_t)(remainder);
			buf[count++] = '0' + n;
			remainder -= n; 
		}
		count += write(buf, count);
     10c:	1ec1      	subs	r1, r0, #3
     10e:	2200      	movs	r2, #0
     110:	4299      	cmp	r1, r3
     112:	d803      	bhi.n	11c <ResetHandler+0x5c>
     114:	3303      	adds	r3, #3
     116:	1a1a      	subs	r2, r3, r0
     118:	0892      	lsrs	r2, r2, #2
     11a:	0092      	lsls	r2, r2, #2
     11c:	2100      	movs	r1, #0
	uint8_t sign=0;
     11e:	f002 fb33 	bl	2788 <memset>
		rounding *= 0.1;
     122:	4c3e      	ldr	r4, [pc, #248]	; (21c <ResetHandler+0x15c>)
     124:	22c0      	movs	r2, #192	; 0xc0
     126:	0020      	movs	r0, r4
     128:	493d      	ldr	r1, [pc, #244]	; (220 <ResetHandler+0x160>)
     12a:	f002 fb75 	bl	2818 <memcpy>
	for (uint8_t i=0; i<digits; ++i) {
     12e:	2603      	movs	r6, #3
     130:	2200      	movs	r2, #0
     132:	2080      	movs	r0, #128	; 0x80
     134:	0017      	movs	r7, r2
			remainder *= 10.0;
     136:	493b      	ldr	r1, [pc, #236]	; (224 <ResetHandler+0x164>)
     138:	0893      	lsrs	r3, r2, #2
     13a:	009b      	lsls	r3, r3, #2
     13c:	185b      	adds	r3, r3, r1
     13e:	21ff      	movs	r1, #255	; 0xff
     140:	4037      	ands	r7, r6
			n = (uint8_t)(remainder);
     142:	00ff      	lsls	r7, r7, #3
     144:	40b9      	lsls	r1, r7
     146:	468c      	mov	ip, r1
			buf[count++] = '0' + n;
     148:	4665      	mov	r5, ip
     14a:	6819      	ldr	r1, [r3, #0]
     14c:	3201      	adds	r2, #1
			remainder -= n; 
     14e:	43a9      	bics	r1, r5
     150:	0005      	movs	r5, r0
     152:	40bd      	lsls	r5, r7
     154:	4329      	orrs	r1, r5
     156:	6019      	str	r1, [r3, #0]
     158:	2a20      	cmp	r2, #32
     15a:	d1eb      	bne.n	134 <ResetHandler+0x74>
     15c:	4b32      	ldr	r3, [pc, #200]	; (228 <ResetHandler+0x168>)
     15e:	326a      	adds	r2, #106	; 0x6a
     160:	601c      	str	r4, [r3, #0]
     162:	4b32      	ldr	r3, [pc, #200]	; (22c <ResetHandler+0x16c>)
     164:	701a      	strb	r2, [r3, #0]
     166:	4b32      	ldr	r3, [pc, #200]	; (230 <ResetHandler+0x170>)
     168:	3a66      	subs	r2, #102	; 0x66
     16a:	705a      	strb	r2, [r3, #1]
     16c:	327c      	adds	r2, #124	; 0x7c
     16e:	701a      	strb	r2, [r3, #0]
     170:	3a9e      	subs	r2, #158	; 0x9e
     172:	7999      	ldrb	r1, [r3, #6]
     174:	4211      	tst	r1, r2
     176:	d0fc      	beq.n	172 <ResetHandler+0xb2>
     178:	2210      	movs	r2, #16
     17a:	7999      	ldrb	r1, [r3, #6]
     17c:	4211      	tst	r1, r2
     17e:	d1fc      	bne.n	17a <ResetHandler+0xba>
     180:	210c      	movs	r1, #12
     182:	799a      	ldrb	r2, [r3, #6]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     184:	400a      	ands	r2, r1
     186:	2a08      	cmp	r2, #8
     188:	d1fb      	bne.n	182 <ResetHandler+0xc2>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
     18a:	3a05      	subs	r2, #5
     18c:	711a      	strb	r2, [r3, #4]
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
    #elif F_CPU == 72000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(3); // config PLL for 72 MHz output
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0); // config PLL for 96 MHz output
     18e:	323d      	adds	r2, #61	; 0x3d
     190:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     192:	3a20      	subs	r2, #32
     194:	7999      	ldrb	r1, [r3, #6]
     196:	4211      	tst	r1, r2
     198:	d0fc      	beq.n	194 <ResetHandler+0xd4>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     19a:	2240      	movs	r2, #64	; 0x40
     19c:	7999      	ldrb	r1, [r3, #6]
     19e:	4211      	tst	r1, r2
     1a0:	d0fc      	beq.n	19c <ResetHandler+0xdc>
	// config divisors: 48 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
  #if defined(KINETISK)
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV3(1) |  SIM_CLKDIV1_OUTDIV4(3);
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
  #elif defined(KINETISL)
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV4(1);
     1a2:	4a24      	ldr	r2, [pc, #144]	; (234 <ResetHandler+0x174>)
     1a4:	4924      	ldr	r1, [pc, #144]	; (238 <ResetHandler+0x178>)
     1a6:	6011      	str	r1, [r2, #0]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     1a8:	2220      	movs	r2, #32
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     1aa:	210c      	movs	r1, #12
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     1ac:	701a      	strb	r2, [r3, #0]
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     1ae:	799a      	ldrb	r2, [r3, #6]
     1b0:	400a      	ands	r2, r1
     1b2:	2a0c      	cmp	r2, #12
     1b4:	d1fb      	bne.n	1ae <ResetHandler+0xee>
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#endif
	#elif defined(KINETISL)
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_CLKOUTSEL(6)
     1b6:	4b21      	ldr	r3, [pc, #132]	; (23c <ResetHandler+0x17c>)
     1b8:	4a21      	ldr	r2, [pc, #132]	; (240 <ResetHandler+0x180>)
     1ba:	601a      	str	r2, [r3, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     1bc:	4b21      	ldr	r3, [pc, #132]	; (244 <ResetHandler+0x184>)
     1be:	4a22      	ldr	r2, [pc, #136]	; (248 <ResetHandler+0x188>)
     1c0:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     1c2:	2200      	movs	r2, #0
     1c4:	4b21      	ldr	r3, [pc, #132]	; (24c <ResetHandler+0x18c>)
     1c6:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     1c8:	4b21      	ldr	r3, [pc, #132]	; (250 <ResetHandler+0x190>)
     1ca:	3207      	adds	r2, #7
     1cc:	601a      	str	r2, [r3, #0]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     1ce:	4b21      	ldr	r3, [pc, #132]	; (254 <ResetHandler+0x194>)
     1d0:	4a21      	ldr	r2, [pc, #132]	; (258 <ResetHandler+0x198>)
     1d2:	601a      	str	r2, [r3, #0]

	//init_pins();
	__enable_irq();
     1d4:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     1d6:	f000 fcd7 	bl	b88 <_init_Teensyduino_internal_>
		#endif
		*(uint32_t *)0x4003E01C = 0;
	}
#endif

	startup_late_hook();
     1da:	f000 fc19 	bl	a10 <startup_late_hook>
	__libc_init_array();
     1de:	f002 faf7 	bl	27d0 <__libc_init_array>

	main();
     1e2:	f000 fbe5 	bl	9b0 <main>
	
	while (1) ;
     1e6:	e7fe      	b.n	1e6 <ResetHandler+0x126>
     1e8:	40048034 	.word	0x40048034
     1ec:	f0040030 	.word	0xf0040030
     1f0:	40048038 	.word	0x40048038
     1f4:	00003f82 	.word	0x00003f82
     1f8:	4004803c 	.word	0x4004803c
     1fc:	0f000001 	.word	0x0f000001
     200:	4007d002 	.word	0x4007d002
     204:	4007e000 	.word	0x4007e000
     208:	1ffffd20 	.word	0x1ffffd20
     20c:	1ffffec8 	.word	0x1ffffec8
     210:	00002c34 	.word	0x00002c34
     214:	1ffffec8 	.word	0x1ffffec8
     218:	200004e8 	.word	0x200004e8
     21c:	1ffff900 	.word	0x1ffff900
     220:	00000000 	.word	0x00000000
     224:	e000e400 	.word	0xe000e400
     228:	e000ed08 	.word	0xe000ed08
     22c:	40065000 	.word	0x40065000
     230:	40064000 	.word	0x40064000
     234:	40048044 	.word	0x40048044
     238:	10010000 	.word	0x10010000
     23c:	40048004 	.word	0x40048004
     240:	050500c0 	.word	0x050500c0
     244:	e000e014 	.word	0xe000e014
     248:	0000bb7f 	.word	0x0000bb7f
     24c:	e000e018 	.word	0xe000e018
     250:	e000e010 	.word	0xe000e010
     254:	e000ed20 	.word	0xe000ed20
     258:	20200000 	.word	0x20200000
		*p++ = '0';
		*p++ = '.';
		// print leading zeros
		while ( decpt < 0 ) {
			decpt++;
			*p++ = '0';
     25c:	ffffffff 	.word	0xffffffff
     260:	ffffffff 	.word	0xffffffff
     264:	ffffffff 	.word	0xffffffff
     268:	ffffffff 	.word	0xffffffff
     26c:	ffffffff 	.word	0xffffffff
     270:	ffffffff 	.word	0xffffffff
     274:	ffffffff 	.word	0xffffffff
     278:	ffffffff 	.word	0xffffffff
     27c:	ffffffff 	.word	0xffffffff
     280:	ffffffff 	.word	0xffffffff
     284:	ffffffff 	.word	0xffffffff
     288:	ffffffff 	.word	0xffffffff
     28c:	ffffffff 	.word	0xffffffff
     290:	ffffffff 	.word	0xffffffff
     294:	ffffffff 	.word	0xffffffff
     298:	ffffffff 	.word	0xffffffff
     29c:	ffffffff 	.word	0xffffffff
     2a0:	ffffffff 	.word	0xffffffff
     2a4:	ffffffff 	.word	0xffffffff
     2a8:	ffffffff 	.word	0xffffffff
     2ac:	ffffffff 	.word	0xffffffff
     2b0:	ffffffff 	.word	0xffffffff
     2b4:	ffffffff 	.word	0xffffffff
     2b8:	ffffffff 	.word	0xffffffff
     2bc:	ffffffff 	.word	0xffffffff
     2c0:	ffffffff 	.word	0xffffffff
     2c4:	ffffffff 	.word	0xffffffff
     2c8:	ffffffff 	.word	0xffffffff
     2cc:	ffffffff 	.word	0xffffffff
     2d0:	ffffffff 	.word	0xffffffff
     2d4:	ffffffff 	.word	0xffffffff
     2d8:	ffffffff 	.word	0xffffffff
     2dc:	ffffffff 	.word	0xffffffff
     2e0:	ffffffff 	.word	0xffffffff
     2e4:	ffffffff 	.word	0xffffffff
     2e8:	ffffffff 	.word	0xffffffff
     2ec:	ffffffff 	.word	0xffffffff
     2f0:	ffffffff 	.word	0xffffffff
     2f4:	ffffffff 	.word	0xffffffff
     2f8:	ffffffff 	.word	0xffffffff
     2fc:	ffffffff 	.word	0xffffffff
     300:	ffffffff 	.word	0xffffffff
     304:	ffffffff 	.word	0xffffffff
     308:	ffffffff 	.word	0xffffffff
     30c:	ffffffff 	.word	0xffffffff
     310:	ffffffff 	.word	0xffffffff
     314:	ffffffff 	.word	0xffffffff
     318:	ffffffff 	.word	0xffffffff
     31c:	ffffffff 	.word	0xffffffff
     320:	ffffffff 	.word	0xffffffff
     324:	ffffffff 	.word	0xffffffff
     328:	ffffffff 	.word	0xffffffff
     32c:	ffffffff 	.word	0xffffffff
     330:	ffffffff 	.word	0xffffffff
     334:	ffffffff 	.word	0xffffffff
     338:	ffffffff 	.word	0xffffffff
     33c:	ffffffff 	.word	0xffffffff
     340:	ffffffff 	.word	0xffffffff
     344:	ffffffff 	.word	0xffffffff
     348:	ffffffff 	.word	0xffffffff
     34c:	ffffffff 	.word	0xffffffff
     350:	ffffffff 	.word	0xffffffff
     354:	ffffffff 	.word	0xffffffff
     358:	ffffffff 	.word	0xffffffff
     35c:	ffffffff 	.word	0xffffffff
     360:	ffffffff 	.word	0xffffffff
     364:	ffffffff 	.word	0xffffffff
     368:	ffffffff 	.word	0xffffffff
     36c:	ffffffff 	.word	0xffffffff
     370:	ffffffff 	.word	0xffffffff
     374:	ffffffff 	.word	0xffffffff
     378:	ffffffff 	.word	0xffffffff
     37c:	ffffffff 	.word	0xffffffff
     380:	ffffffff 	.word	0xffffffff
     384:	ffffffff 	.word	0xffffffff
     388:	ffffffff 	.word	0xffffffff
     38c:	ffffffff 	.word	0xffffffff
     390:	ffffffff 	.word	0xffffffff
     394:	ffffffff 	.word	0xffffffff
     398:	ffffffff 	.word	0xffffffff
     39c:	ffffffff 	.word	0xffffffff
     3a0:	ffffffff 	.word	0xffffffff
     3a4:	ffffffff 	.word	0xffffffff
     3a8:	ffffffff 	.word	0xffffffff
     3ac:	ffffffff 	.word	0xffffffff
     3b0:	ffffffff 	.word	0xffffffff
     3b4:	ffffffff 	.word	0xffffffff
     3b8:	ffffffff 	.word	0xffffffff
     3bc:	ffffffff 	.word	0xffffffff
     3c0:	ffffffff 	.word	0xffffffff
     3c4:	ffffffff 	.word	0xffffffff
     3c8:	ffffffff 	.word	0xffffffff
     3cc:	ffffffff 	.word	0xffffffff
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <register_tm_clones>:
     410:	4806      	ldr	r0, [pc, #24]	; (42c <register_tm_clones+0x1c>)
     412:	4907      	ldr	r1, [pc, #28]	; (430 <register_tm_clones+0x20>)
     414:	1a09      	subs	r1, r1, r0
     416:	108b      	asrs	r3, r1, #2
     418:	0fc9      	lsrs	r1, r1, #31
     41a:	18c9      	adds	r1, r1, r3
     41c:	b510      	push	{r4, lr}
     41e:	1049      	asrs	r1, r1, #1
     420:	d003      	beq.n	42a <register_tm_clones+0x1a>
     422:	4b04      	ldr	r3, [pc, #16]	; (434 <register_tm_clones+0x24>)
     424:	2b00      	cmp	r3, #0
     426:	d000      	beq.n	42a <register_tm_clones+0x1a>
     428:	4798      	blx	r3
     42a:	bd10      	pop	{r4, pc}
     42c:	1ffffec8 	.word	0x1ffffec8
     430:	1ffffec8 	.word	0x1ffffec8
     434:	00000000 	.word	0x00000000

00000438 <frame_dummy>:
     438:	4b05      	ldr	r3, [pc, #20]	; (450 <frame_dummy+0x18>)
     43a:	b510      	push	{r4, lr}
     43c:	2b00      	cmp	r3, #0
     43e:	d003      	beq.n	448 <frame_dummy+0x10>
     440:	4904      	ldr	r1, [pc, #16]	; (454 <frame_dummy+0x1c>)
     442:	4805      	ldr	r0, [pc, #20]	; (458 <frame_dummy+0x20>)
     444:	e000      	b.n	448 <frame_dummy+0x10>
     446:	bf00      	nop
     448:	f7ff ffe2 	bl	410 <register_tm_clones>
     44c:	bd10      	pop	{r4, pc}
     44e:	46c0      	nop			; (mov r8, r8)
     450:	00000000 	.word	0x00000000
     454:	1ffffec8 	.word	0x1ffffec8
     458:	00002c34 	.word	0x00002c34

0000045c <Print::write(char const*) [clone .isra.0]>:
	size_t write(const char *str)			{ if (str == nullptr) return 0;
     45c:	b570      	push	{r4, r5, r6, lr}
     45e:	0005      	movs	r5, r0
     460:	1e0c      	subs	r4, r1, #0
     462:	d008      	beq.n	476 <Print::write(char const*) [clone .isra.0]+0x1a>
							  return write((const uint8_t *)str, strlen(str)); }
     464:	0008      	movs	r0, r1
     466:	f002 f9e0 	bl	282a <strlen>
     46a:	682b      	ldr	r3, [r5, #0]
     46c:	0002      	movs	r2, r0
     46e:	0021      	movs	r1, r4
     470:	0028      	movs	r0, r5
     472:	685b      	ldr	r3, [r3, #4]
     474:	4798      	blx	r3
     476:	bd70      	pop	{r4, r5, r6, pc}

00000478 <Print::println(char const*) [clone .isra.0]>:
	size_t println(const char s[])			{ return print(s) + println(); }
     478:	b510      	push	{r4, lr}
     47a:	0004      	movs	r4, r0
	size_t print(const char s[])			{ return write(s); }
     47c:	f7ff ffee 	bl	45c <Print::write(char const*) [clone .isra.0]>
	size_t println(const char s[])			{ return print(s) + println(); }
     480:	0020      	movs	r0, r4
     482:	f000 fa17 	bl	8b4 <Print::println()>
     486:	bd10      	pop	{r4, pc}

00000488 <playFirstFile()>:
  buff[buffidx] = 0;  // null term
  return buffidx;
}
/************************ MENU HELPERS ***************************/

void playFirstFile() {
     488:	b510      	push	{r4, lr}
	size_t print(const char s[])			{ return write(s); }
     48a:	4c0e      	ldr	r4, [pc, #56]	; (4c4 <playFirstFile()+0x3c>)
     48c:	490e      	ldr	r1, [pc, #56]	; (4c8 <playFirstFile()+0x40>)
     48e:	0020      	movs	r0, r4
     490:	f7ff ffe4 	bl	45c <Print::write(char const*) [clone .isra.0]>
     494:	0020      	movs	r0, r4
     496:	490d      	ldr	r1, [pc, #52]	; (4cc <playFirstFile()+0x44>)
     498:	f7ff ffe0 	bl	45c <Print::write(char const*) [clone .isra.0]>
		if (base == 10 || base < 2) return printNumberDec(n, sign);
     49c:	2200      	movs	r2, #0
     49e:	0020      	movs	r0, r4
     4a0:	0011      	movs	r1, r2
     4a2:	f000 fa13 	bl	8cc <Print::printNumberDec(unsigned long, unsigned char)>
	size_t println(uint8_t b)			{ return print(b) + println(); }
     4a6:	0020      	movs	r0, r4
     4a8:	f000 fa04 	bl	8b4 <Print::println()>
  Serial.print("Playing First File");
  uint8_t n = 0;

  Serial.print("\nPlaying track #"); Serial.println(n);
  if (! sfx.playTrack((uint8_t)n) ) {
     4ac:	2100      	movs	r1, #0
     4ae:	4808      	ldr	r0, [pc, #32]	; (4d0 <playFirstFile()+0x48>)
     4b0:	f000 f910 	bl	6d4 <Adafruit_Soundboard::playTrack(unsigned char)>
     4b4:	2800      	cmp	r0, #0
     4b6:	d103      	bne.n	4c0 <playFirstFile()+0x38>
    Serial.println("Failed to play track?");
     4b8:	0020      	movs	r0, r4
     4ba:	4906      	ldr	r1, [pc, #24]	; (4d4 <playFirstFile()+0x4c>)
     4bc:	f7ff ffdc 	bl	478 <Print::println(char const*) [clone .isra.0]>
  }
     4c0:	bd10      	pop	{r4, pc}
     4c2:	46c0      	nop			; (mov r8, r8)
     4c4:	1ffffdc4 	.word	0x1ffffdc4
     4c8:	00002838 	.word	0x00002838
     4cc:	0000284b 	.word	0x0000284b
     4d0:	1ffffee0 	.word	0x1ffffee0
     4d4:	0000285c 	.word	0x0000285c

000004d8 <loop>:
}
     4d8:	4770      	bx	lr
     4da:	Address 0x000004da is out of bounds.


000004dc <_GLOBAL__sub_I_sfx>:
     4dc:	b510      	push	{r4, lr}
Adafruit_Soundboard sfx = Adafruit_Soundboard(&Serial2, NULL, SFX_RST);
     4de:	2303      	movs	r3, #3
     4e0:	2200      	movs	r2, #0
     4e2:	4902      	ldr	r1, [pc, #8]	; (4ec <_GLOBAL__sub_I_sfx+0x10>)
     4e4:	4802      	ldr	r0, [pc, #8]	; (4f0 <_GLOBAL__sub_I_sfx+0x14>)
     4e6:	f000 f893 	bl	610 <Adafruit_Soundboard::Adafruit_Soundboard(Stream*, Stream*, signed char)>
     4ea:	bd10      	pop	{r4, pc}
     4ec:	1ffffd20 	.word	0x1ffffd20
     4f0:	1ffffee0 	.word	0x1ffffee0

000004f4 <setup>:
void setup() {
     4f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		uint32_t millis_begin = systick_millis_count;
		while (!(*this)) {
			uint32_t elapsed = systick_millis_count - millis_begin;
			if (usb_configuration) {
				// Wait up to 2 seconds for Arduino Serial Monitor
				if (elapsed > 2000) break;
     4f6:	27fa      	movs	r7, #250	; 0xfa
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() {
		yield();
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     4f8:	2601      	movs	r6, #1
  pinMode(BUTTON_PIN, INPUT);
     4fa:	2100      	movs	r1, #0
     4fc:	2004      	movs	r0, #4
     4fe:	f000 fbd7 	bl	cb0 <pinMode>
  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), playFirstFile, RISING);
     502:	2203      	movs	r2, #3
     504:	2004      	movs	r0, #4
     506:	491e      	ldr	r1, [pc, #120]	; (580 <setup+0x8c>)
     508:	f000 fc06 	bl	d18 <attachInterrupt>
		uint32_t millis_begin = systick_millis_count;
     50c:	4c1d      	ldr	r4, [pc, #116]	; (584 <setup+0x90>)
				if (elapsed > 2000) break;
     50e:	00ff      	lsls	r7, r7, #3
		uint32_t millis_begin = systick_millis_count;
     510:	6825      	ldr	r5, [r4, #0]
		yield();
     512:	f001 fedb 	bl	22cc <yield>
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     516:	4a1c      	ldr	r2, [pc, #112]	; (588 <setup+0x94>)
     518:	7813      	ldrb	r3, [r2, #0]
     51a:	2b00      	cmp	r3, #0
     51c:	d009      	beq.n	532 <setup+0x3e>
     51e:	4b1b      	ldr	r3, [pc, #108]	; (58c <setup+0x98>)
     520:	781b      	ldrb	r3, [r3, #0]
     522:	4233      	tst	r3, r6
     524:	d005      	beq.n	532 <setup+0x3e>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     526:	491a      	ldr	r1, [pc, #104]	; (590 <setup+0x9c>)
     528:	6823      	ldr	r3, [r4, #0]
     52a:	6809      	ldr	r1, [r1, #0]
     52c:	1a5b      	subs	r3, r3, r1
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     52e:	2b0e      	cmp	r3, #14
     530:	d80c      	bhi.n	54c <setup+0x58>
			uint32_t elapsed = systick_millis_count - millis_begin;
     532:	6823      	ldr	r3, [r4, #0]
			if (usb_configuration) {
     534:	7812      	ldrb	r2, [r2, #0]
			uint32_t elapsed = systick_millis_count - millis_begin;
     536:	1b5b      	subs	r3, r3, r5
			if (usb_configuration) {
     538:	2a00      	cmp	r2, #0
     53a:	d105      	bne.n	548 <setup+0x54>
				if (elapsed > 750) break;
     53c:	4a15      	ldr	r2, [pc, #84]	; (594 <setup+0xa0>)
     53e:	4293      	cmp	r3, r2
     540:	d804      	bhi.n	54c <setup+0x58>
			yield();
     542:	f001 fec3 	bl	22cc <yield>
     546:	e7e4      	b.n	512 <setup+0x1e>
				if (elapsed > 2000) break;
     548:	42bb      	cmp	r3, r7
     54a:	d9fa      	bls.n	542 <setup+0x4e>
  Serial.println("Adafruit Sound Board!");
     54c:	4c12      	ldr	r4, [pc, #72]	; (598 <setup+0xa4>)
     54e:	4913      	ldr	r1, [pc, #76]	; (59c <setup+0xa8>)
     550:	0020      	movs	r0, r4
     552:	f7ff ff91 	bl	478 <Print::println(char const*) [clone .isra.0]>
  Serial2.begin(9600);
     556:	2196      	movs	r1, #150	; 0x96
     558:	4811      	ldr	r0, [pc, #68]	; (5a0 <setup+0xac>)
     55a:	0189      	lsls	r1, r1, #6
     55c:	f000 f908 	bl	770 <HardwareSerial2::begin(unsigned long)>
  if (!sfx.reset()) {
     560:	4810      	ldr	r0, [pc, #64]	; (5a4 <setup+0xb0>)
     562:	f000 f887 	bl	674 <Adafruit_Soundboard::reset()>
     566:	2800      	cmp	r0, #0
     568:	d104      	bne.n	574 <setup+0x80>
      Serial.println("Not found");
     56a:	0020      	movs	r0, r4
     56c:	490e      	ldr	r1, [pc, #56]	; (5a8 <setup+0xb4>)
     56e:	f7ff ff83 	bl	478 <Print::println(char const*) [clone .isra.0]>
    while (1){
     572:	e7fa      	b.n	56a <setup+0x76>
  Serial.println("SFX board found");
     574:	0020      	movs	r0, r4
     576:	490d      	ldr	r1, [pc, #52]	; (5ac <setup+0xb8>)
     578:	f7ff ff7e 	bl	478 <Print::println(char const*) [clone .isra.0]>
}
     57c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     57e:	46c0      	nop			; (mov r8, r8)
     580:	00000489 	.word	0x00000489
     584:	200000d4 	.word	0x200000d4
     588:	20000360 	.word	0x20000360
     58c:	20000380 	.word	0x20000380
     590:	20000384 	.word	0x20000384
     594:	000002ee 	.word	0x000002ee
     598:	1ffffdc4 	.word	0x1ffffdc4
     59c:	00002872 	.word	0x00002872
     5a0:	1ffffd20 	.word	0x1ffffd20
     5a4:	1ffffee0 	.word	0x1ffffee0
     5a8:	00002888 	.word	0x00002888
     5ac:	00002892 	.word	0x00002892

000005b0 <Print::availableForWrite()>:
	virtual int availableForWrite(void)		{ return 0; }
     5b0:	2000      	movs	r0, #0
     5b2:	4770      	bx	lr

000005b4 <Print::flush()>:
	virtual void flush()				{ }
     5b4:	4770      	bx	lr

000005b6 <Print::write(char const*)>:
	size_t write(const char *str)			{ if (str == nullptr) return 0;
     5b6:	b570      	push	{r4, r5, r6, lr}
     5b8:	0005      	movs	r5, r0
     5ba:	000c      	movs	r4, r1
     5bc:	1e08      	subs	r0, r1, #0
     5be:	d007      	beq.n	5d0 <Print::write(char const*)+0x1a>
							  return write((const uint8_t *)str, strlen(str)); }
     5c0:	f002 f933 	bl	282a <strlen>
     5c4:	682b      	ldr	r3, [r5, #0]
     5c6:	0002      	movs	r2, r0
     5c8:	0021      	movs	r1, r4
     5ca:	0028      	movs	r0, r5
     5cc:	685b      	ldr	r3, [r3, #4]
     5ce:	4798      	blx	r3
     5d0:	bd70      	pop	{r4, r5, r6, pc}
     5d2:	Address 0x000005d2 is out of bounds.


000005d4 <Adafruit_Soundboard::write(unsigned char)>:
size_t Adafruit_Soundboard::write(uint8_t c) {
     5d4:	b570      	push	{r4, r5, r6, lr}
     5d6:	0004      	movs	r4, r0
  if (debug) {
     5d8:	68c0      	ldr	r0, [r0, #12]
size_t Adafruit_Soundboard::write(uint8_t c) {
     5da:	000d      	movs	r5, r1
  if (debug) {
     5dc:	2800      	cmp	r0, #0
     5de:	d00e      	beq.n	5fe <Adafruit_Soundboard::write(unsigned char)+0x2a>
    if (!writing) {
     5e0:	0026      	movs	r6, r4
     5e2:	3661      	adds	r6, #97	; 0x61
     5e4:	7833      	ldrb	r3, [r6, #0]
     5e6:	2b00      	cmp	r3, #0
     5e8:	d104      	bne.n	5f4 <Adafruit_Soundboard::write(unsigned char)+0x20>
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
     5ea:	4908      	ldr	r1, [pc, #32]	; (60c <Adafruit_Soundboard::write(unsigned char)+0x38>)
     5ec:	f7ff ffe3 	bl	5b6 <Print::write(char const*)>
      writing = true;
     5f0:	2301      	movs	r3, #1
     5f2:	7033      	strb	r3, [r6, #0]
    debug->write(c);
     5f4:	68e0      	ldr	r0, [r4, #12]
     5f6:	0029      	movs	r1, r5
     5f8:	6803      	ldr	r3, [r0, #0]
     5fa:	681b      	ldr	r3, [r3, #0]
     5fc:	4798      	blx	r3
  return stream->write(c);
     5fe:	68a0      	ldr	r0, [r4, #8]
     600:	0029      	movs	r1, r5
     602:	6803      	ldr	r3, [r0, #0]
     604:	681b      	ldr	r3, [r3, #0]
     606:	4798      	blx	r3
}
     608:	bd70      	pop	{r4, r5, r6, pc}
     60a:	46c0      	nop			; (mov r8, r8)
     60c:	000028a2 	.word	0x000028a2

00000610 <Adafruit_Soundboard::Adafruit_Soundboard(Stream*, Stream*, signed char)>:
Adafruit_Soundboard::Adafruit_Soundboard(Stream *s, Stream *d, int8_t r)
     610:	b570      	push	{r4, r5, r6, lr}
     612:	0004      	movs	r4, r0
     614:	0008      	movs	r0, r1
    : stream(s), debug(d), reset_pin(r) {
     616:	4909      	ldr	r1, [pc, #36]	; (63c <Adafruit_Soundboard::Adafruit_Soundboard(Stream*, Stream*, signed char)+0x2c>)
	constexpr Print() : write_error(0) {}
     618:	2500      	movs	r5, #0
     61a:	3108      	adds	r1, #8
     61c:	6021      	str	r1, [r4, #0]
  stream->setTimeout(500);
     61e:	21fa      	movs	r1, #250	; 0xfa
     620:	6065      	str	r5, [r4, #4]
    : stream(s), debug(d), reset_pin(r) {
     622:	60a0      	str	r0, [r4, #8]
     624:	7423      	strb	r3, [r4, #16]
     626:	60e2      	str	r2, [r4, #12]
  stream->setTimeout(500);
     628:	0049      	lsls	r1, r1, #1
     62a:	f000 f99b 	bl	964 <Stream::setTimeout(unsigned long)>
  writing = false;
     62e:	0023      	movs	r3, r4
     630:	3361      	adds	r3, #97	; 0x61
}
     632:	0020      	movs	r0, r4
  writing = false;
     634:	701d      	strb	r5, [r3, #0]
  files = 0;
     636:	705d      	strb	r5, [r3, #1]
}
     638:	bd70      	pop	{r4, r5, r6, pc}
     63a:	46c0      	nop			; (mov r8, r8)
     63c:	000028c8 	.word	0x000028c8

00000640 <Adafruit_Soundboard::readLine()>:
  int x = stream->readBytesUntil('\n', line_buffer, LINE_BUFFER_SIZE);
     640:	0002      	movs	r2, r0
int Adafruit_Soundboard::readLine(void) {
     642:	b570      	push	{r4, r5, r6, lr}
  int x = stream->readBytesUntil('\n', line_buffer, LINE_BUFFER_SIZE);
     644:	2350      	movs	r3, #80	; 0x50
int Adafruit_Soundboard::readLine(void) {
     646:	0004      	movs	r4, r0
  int x = stream->readBytesUntil('\n', line_buffer, LINE_BUFFER_SIZE);
     648:	3211      	adds	r2, #17
     64a:	210a      	movs	r1, #10
     64c:	6880      	ldr	r0, [r0, #8]
     64e:	f000 f98b 	bl	968 <Stream::readBytesUntil(char, char*, unsigned int)>
  line_buffer[x] = 0;
     652:	2200      	movs	r2, #0
     654:	1823      	adds	r3, r4, r0
     656:	745a      	strb	r2, [r3, #17]
  int x = stream->readBytesUntil('\n', line_buffer, LINE_BUFFER_SIZE);
     658:	0005      	movs	r5, r0
  if (stream->peek() == '\r')
     65a:	68a0      	ldr	r0, [r4, #8]
     65c:	6803      	ldr	r3, [r0, #0]
     65e:	699b      	ldr	r3, [r3, #24]
     660:	4798      	blx	r3
     662:	280d      	cmp	r0, #13
     664:	d103      	bne.n	66e <Adafruit_Soundboard::readLine()+0x2e>
     666:	68a0      	ldr	r0, [r4, #8]
    stream->read();
     668:	6803      	ldr	r3, [r0, #0]
     66a:	695b      	ldr	r3, [r3, #20]
     66c:	4798      	blx	r3
}
     66e:	0028      	movs	r0, r5
     670:	bd70      	pop	{r4, r5, r6, pc}
     672:	Address 0x00000672 is out of bounds.


00000674 <Adafruit_Soundboard::reset()>:
boolean Adafruit_Soundboard::reset(void) {
     674:	b510      	push	{r4, lr}
     676:	0004      	movs	r4, r0
  digitalWrite(reset_pin, LOW);
     678:	2100      	movs	r1, #0
     67a:	7c00      	ldrb	r0, [r0, #16]
     67c:	f000 faf6 	bl	c6c <digitalWrite>
  pinMode(reset_pin, OUTPUT);
     680:	2101      	movs	r1, #1
     682:	7c20      	ldrb	r0, [r4, #16]
     684:	f000 fb14 	bl	cb0 <pinMode>
  delay(10);
     688:	200a      	movs	r0, #10
     68a:	f000 fba5 	bl	dd8 <delay>
  pinMode(reset_pin, INPUT);
     68e:	2100      	movs	r1, #0
     690:	7c20      	ldrb	r0, [r4, #16]
     692:	f000 fb0d 	bl	cb0 <pinMode>
  delay(1000); // give a bit of time to 'boot up'
     696:	20fa      	movs	r0, #250	; 0xfa
     698:	0080      	lsls	r0, r0, #2
     69a:	f000 fb9d 	bl	dd8 <delay>
  readLine();
     69e:	0020      	movs	r0, r4
     6a0:	f7ff ffce 	bl	640 <Adafruit_Soundboard::readLine()>
  readLine();
     6a4:	0020      	movs	r0, r4
     6a6:	f7ff ffcb 	bl	640 <Adafruit_Soundboard::readLine()>
  if (!strstr(line_buffer, "Adafruit FX Sound Board"))
     6aa:	0020      	movs	r0, r4
     6ac:	4908      	ldr	r1, [pc, #32]	; (6d0 <Adafruit_Soundboard::reset()+0x5c>)
     6ae:	3011      	adds	r0, #17
     6b0:	f002 f872 	bl	2798 <strstr>
     6b4:	2800      	cmp	r0, #0
     6b6:	d009      	beq.n	6cc <Adafruit_Soundboard::reset()+0x58>
  delay(250);
     6b8:	20fa      	movs	r0, #250	; 0xfa
     6ba:	f000 fb8d 	bl	dd8 <delay>
  readLine();
     6be:	0020      	movs	r0, r4
     6c0:	f7ff ffbe 	bl	640 <Adafruit_Soundboard::readLine()>
  readLine();
     6c4:	0020      	movs	r0, r4
     6c6:	f7ff ffbb 	bl	640 <Adafruit_Soundboard::readLine()>
  return true;
     6ca:	2001      	movs	r0, #1
}
     6cc:	bd10      	pop	{r4, pc}
     6ce:	46c0      	nop			; (mov r8, r8)
     6d0:	000028a8 	.word	0x000028a8

000006d4 <Adafruit_Soundboard::playTrack(unsigned char)>:
    return 0;

  return filesizes[n];
}

boolean Adafruit_Soundboard::playTrack(uint8_t n) {
     6d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     6d6:	0004      	movs	r4, r0
     6d8:	000d      	movs	r5, r1
  while (stream->available())
     6da:	68a0      	ldr	r0, [r4, #8]
     6dc:	6803      	ldr	r3, [r0, #0]
     6de:	691b      	ldr	r3, [r3, #16]
     6e0:	4798      	blx	r3
     6e2:	1e06      	subs	r6, r0, #0
     6e4:	d122      	bne.n	72c <Adafruit_Soundboard::playTrack(unsigned char)+0x58>
	size_t print(const char s[])			{ return write(s); }
     6e6:	4914      	ldr	r1, [pc, #80]	; (738 <Adafruit_Soundboard::playTrack(unsigned char)+0x64>)
     6e8:	68a0      	ldr	r0, [r4, #8]
     6ea:	f7ff ff64 	bl	5b6 <Print::write(char const*)>
    stream->read();

  stream->print("#");
  stream->println(n);
     6ee:	68a7      	ldr	r7, [r4, #8]
		if (base == 10 || base < 2) return printNumberDec(n, sign);
     6f0:	0029      	movs	r1, r5
     6f2:	0032      	movs	r2, r6
     6f4:	0038      	movs	r0, r7
     6f6:	f000 f8e9 	bl	8cc <Print::printNumberDec(unsigned long, unsigned char)>
	size_t println(uint8_t b)			{ return print(b) + println(); }
     6fa:	0038      	movs	r0, r7
     6fc:	f000 f8da 	bl	8b4 <Print::println()>

  readLine(); // eat return
     700:	0020      	movs	r0, r4
     702:	f7ff ff9d 	bl	640 <Adafruit_Soundboard::readLine()>

  readLine();
     706:	0020      	movs	r0, r4
     708:	f7ff ff9a 	bl	640 <Adafruit_Soundboard::readLine()>
  Serial.print("<---");
  Serial.println(line_buffer);
#endif

  // check we got "play" back
  if (strstr(line_buffer, "play") == 0) {
     70c:	0020      	movs	r0, r4
     70e:	490b      	ldr	r1, [pc, #44]	; (73c <Adafruit_Soundboard::playTrack(unsigned char)+0x68>)
     710:	3011      	adds	r0, #17
     712:	f002 f841 	bl	2798 <strstr>
     716:	2800      	cmp	r0, #0
     718:	d007      	beq.n	72a <Adafruit_Soundboard::playTrack(unsigned char)+0x56>
    return false;
  }
  // check the # is correct
  int playing = atoi(line_buffer + 5);
     71a:	0020      	movs	r0, r4
     71c:	3016      	adds	r0, #22
     71e:	f001 ff9b 	bl	2658 <atoi>
#ifdef DEBUG
  Serial.print("# = ");
  Serial.println(playing);
#endif
  if (n != playing)
     722:	1a2d      	subs	r5, r5, r0
     724:	426b      	negs	r3, r5
     726:	415d      	adcs	r5, r3
     728:	b2e8      	uxtb	r0, r5
    return false;

  return true;
}
     72a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    stream->read();
     72c:	68a0      	ldr	r0, [r4, #8]
     72e:	6803      	ldr	r3, [r0, #0]
     730:	695b      	ldr	r3, [r3, #20]
     732:	4798      	blx	r3
     734:	e7d1      	b.n	6da <Adafruit_Soundboard::playTrack(unsigned char)+0x6>
     736:	46c0      	nop			; (mov r8, r8)
     738:	0000285a 	.word	0x0000285a
     73c:	000028c0 	.word	0x000028c0

00000740 <HardwareSerial2::write(unsigned long)>:
	virtual int availableForWrite(void) { return serial2_write_buffer_free(); }
 	virtual void addMemoryForRead(void *buffer, size_t length) {serial2_add_memory_for_read(buffer, length);}
	virtual void addMemoryForWrite(void *buffer, size_t length){serial2_add_memory_for_write(buffer, length);}
	using Print::write;
	virtual size_t write(uint8_t c) { serial2_putchar(c); return 1; }
	virtual size_t write(unsigned long n)   { return write((uint8_t)n); }
     740:	b510      	push	{r4, lr}
     742:	6803      	ldr	r3, [r0, #0]
     744:	b2c9      	uxtb	r1, r1
     746:	681b      	ldr	r3, [r3, #0]
     748:	4798      	blx	r3
     74a:	bd10      	pop	{r4, pc}

0000074c <HardwareSerial2::write(long)>:
	virtual size_t write(long n)            { return write((uint8_t)n); }
     74c:	b510      	push	{r4, lr}
     74e:	6803      	ldr	r3, [r0, #0]
     750:	b2c9      	uxtb	r1, r1
     752:	681b      	ldr	r3, [r3, #0]
     754:	4798      	blx	r3
     756:	bd10      	pop	{r4, pc}

00000758 <HardwareSerial2::write(unsigned int)>:
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
     758:	b510      	push	{r4, lr}
     75a:	6803      	ldr	r3, [r0, #0]
     75c:	b2c9      	uxtb	r1, r1
     75e:	681b      	ldr	r3, [r3, #0]
     760:	4798      	blx	r3
     762:	bd10      	pop	{r4, pc}

00000764 <HardwareSerial2::write(int)>:
	virtual size_t write(int n)             { return write((uint8_t)n); }
     764:	b510      	push	{r4, lr}
     766:	6803      	ldr	r3, [r0, #0]
     768:	b2c9      	uxtb	r1, r1
     76a:	681b      	ldr	r3, [r3, #0]
     76c:	4798      	blx	r3
     76e:	bd10      	pop	{r4, pc}

00000770 <HardwareSerial2::begin(unsigned long)>:
HardwareSerial2 Serial2(&serialEvent2);

uint8_t _serialEvent2_default __attribute__((weak)) PROGMEM = 0 ;

void HardwareSerial2::begin(uint32_t baud) {
	serial2_begin(BAUD2DIV2(baud));
     770:	4b08      	ldr	r3, [pc, #32]	; (794 <HardwareSerial2::begin(unsigned long)+0x24>)
void HardwareSerial2::begin(uint32_t baud) {
     772:	b510      	push	{r4, lr}
     774:	0004      	movs	r4, r0
	serial2_begin(BAUD2DIV2(baud));
     776:	0848      	lsrs	r0, r1, #1
     778:	18c0      	adds	r0, r0, r3
     77a:	f001 fec3 	bl	2504 <__udivsi3>
     77e:	f000 fbcf 	bl	f20 <serial2_begin>
	if (!_serialEvent2_default) addToSerialEventsList();
     782:	4b05      	ldr	r3, [pc, #20]	; (798 <HardwareSerial2::begin(unsigned long)+0x28>)
     784:	781b      	ldrb	r3, [r3, #0]
     786:	2b00      	cmp	r3, #0
     788:	d102      	bne.n	790 <HardwareSerial2::begin(unsigned long)+0x20>
     78a:	0020      	movs	r0, r4
     78c:	f001 fe0c 	bl	23a8 <HardwareSerial::addToSerialEventsList()>
}
     790:	bd10      	pop	{r4, pc}
     792:	46c0      	nop			; (mov r8, r8)
     794:	0016e360 	.word	0x0016e360
     798:	1ffffdc0 	.word	0x1ffffdc0

0000079c <HardwareSerial2::write9bit(unsigned long)>:
	virtual size_t write(const uint8_t *buffer, size_t size)
					{ serial2_write(buffer, size); return size; }
        virtual size_t write(const char *str)	{ size_t len = strlen(str);
					  serial2_write((const uint8_t *)str, len);
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial2_putchar(c); return 1; }
     79c:	b510      	push	{r4, lr}
     79e:	0008      	movs	r0, r1
     7a0:	f000 fcd8 	bl	1154 <serial2_putchar>
     7a4:	2001      	movs	r0, #1
     7a6:	bd10      	pop	{r4, pc}

000007a8 <HardwareSerial2::write(unsigned char)>:
	virtual size_t write(uint8_t c) { serial2_putchar(c); return 1; }
     7a8:	b510      	push	{r4, lr}
     7aa:	0008      	movs	r0, r1
     7ac:	f000 fcd2 	bl	1154 <serial2_putchar>
     7b0:	2001      	movs	r0, #1
     7b2:	bd10      	pop	{r4, pc}

000007b4 <HardwareSerial2::write(char const*)>:
        virtual size_t write(const char *str)	{ size_t len = strlen(str);
     7b4:	b570      	push	{r4, r5, r6, lr}
     7b6:	0008      	movs	r0, r1
     7b8:	000d      	movs	r5, r1
     7ba:	f002 f836 	bl	282a <strlen>
     7be:	0004      	movs	r4, r0
					  serial2_write((const uint8_t *)str, len);
     7c0:	0001      	movs	r1, r0
     7c2:	0028      	movs	r0, r5
     7c4:	f000 fd44 	bl	1250 <serial2_write>
					  return len; }
     7c8:	0020      	movs	r0, r4
     7ca:	bd70      	pop	{r4, r5, r6, pc}

000007cc <HardwareSerial2::write(unsigned char const*, unsigned int)>:
	virtual size_t write(const uint8_t *buffer, size_t size)
     7cc:	b510      	push	{r4, lr}
     7ce:	0014      	movs	r4, r2
     7d0:	0008      	movs	r0, r1
					{ serial2_write(buffer, size); return size; }
     7d2:	0011      	movs	r1, r2
     7d4:	f000 fd3c 	bl	1250 <serial2_write>
     7d8:	0020      	movs	r0, r4
     7da:	bd10      	pop	{r4, pc}

000007dc <HardwareSerial2::addMemoryForWrite(void*, unsigned int)>:
	virtual void addMemoryForWrite(void *buffer, size_t length){serial2_add_memory_for_write(buffer, length);}
     7dc:	b510      	push	{r4, lr}
     7de:	0008      	movs	r0, r1
     7e0:	0011      	movs	r1, r2
     7e2:	f000 fe97 	bl	1514 <serial2_add_memory_for_write>
     7e6:	bd10      	pop	{r4, pc}

000007e8 <HardwareSerial2::addMemoryForRead(void*, unsigned int)>:
 	virtual void addMemoryForRead(void *buffer, size_t length) {serial2_add_memory_for_read(buffer, length);}
     7e8:	b510      	push	{r4, lr}
     7ea:	0008      	movs	r0, r1
     7ec:	0011      	movs	r1, r2
     7ee:	f000 fe7d 	bl	14ec <serial2_add_memory_for_read>
     7f2:	bd10      	pop	{r4, pc}

000007f4 <HardwareSerial2::clear()>:
	virtual void clear(void)	{ serial2_clear(); }
     7f4:	b510      	push	{r4, lr}
     7f6:	f000 fdd9 	bl	13ac <serial2_clear>
     7fa:	bd10      	pop	{r4, pc}

000007fc <HardwareSerial2::attachCts(unsigned char)>:
	virtual bool attachCts(uint8_t pin) { return serial2_set_cts(pin); }
     7fc:	b510      	push	{r4, lr}
     7fe:	0008      	movs	r0, r1
     800:	f000 fca6 	bl	1150 <serial2_set_cts>
     804:	1e43      	subs	r3, r0, #1
     806:	4198      	sbcs	r0, r3
     808:	b2c0      	uxtb	r0, r0
     80a:	bd10      	pop	{r4, pc}

0000080c <HardwareSerial2::attachRts(unsigned char)>:
	virtual bool attachRts(uint8_t pin) { return serial2_set_rts(pin); }
     80c:	b510      	push	{r4, lr}
     80e:	0008      	movs	r0, r1
     810:	f000 fc74 	bl	10fc <serial2_set_rts>
     814:	1e43      	subs	r3, r0, #1
     816:	4198      	sbcs	r0, r3
     818:	b2c0      	uxtb	r0, r0
     81a:	bd10      	pop	{r4, pc}

0000081c <HardwareSerial2::setTX(unsigned char, bool)>:
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial2_set_tx(pin, opendrain); }
     81c:	b510      	push	{r4, lr}
     81e:	0008      	movs	r0, r1
     820:	0011      	movs	r1, r2
     822:	f000 fc69 	bl	10f8 <serial2_set_tx>
     826:	bd10      	pop	{r4, pc}

00000828 <HardwareSerial2::setRX(unsigned char)>:
	virtual void setRX(uint8_t pin) { serial2_set_rx(pin); }
     828:	b510      	push	{r4, lr}
     82a:	0008      	movs	r0, r1
     82c:	f000 fc65 	bl	10fa <serial2_set_rx>
     830:	bd10      	pop	{r4, pc}

00000832 <HardwareSerial2::transmitterEnable(unsigned char)>:
	virtual void transmitterEnable(uint8_t pin) { serial2_set_transmit_pin(pin); }
     832:	b510      	push	{r4, lr}
     834:	0008      	movs	r0, r1
     836:	f000 fc3d 	bl	10b4 <serial2_set_transmit_pin>
     83a:	bd10      	pop	{r4, pc}

0000083c <HardwareSerial2::end()>:
	virtual void end(void)		{ serial2_end(); }
     83c:	b510      	push	{r4, lr}
     83e:	f000 fbfd 	bl	103c <serial2_end>
     842:	bd10      	pop	{r4, pc}

00000844 <HardwareSerial2::begin(unsigned long, unsigned long)>:
	virtual void begin(uint32_t baud, uint32_t format) {
     844:	b510      	push	{r4, lr}
     846:	0014      	movs	r4, r2
					  serial2_begin(BAUD2DIV2(baud));
     848:	4b05      	ldr	r3, [pc, #20]	; (860 <HardwareSerial2::begin(unsigned long, unsigned long)+0x1c>)
     84a:	0848      	lsrs	r0, r1, #1
     84c:	18c0      	adds	r0, r0, r3
     84e:	f001 fe59 	bl	2504 <__udivsi3>
     852:	f000 fb65 	bl	f20 <serial2_begin>
					  serial2_format(format); }
     856:	0020      	movs	r0, r4
     858:	f000 fbae 	bl	fb8 <serial2_format>
     85c:	bd10      	pop	{r4, pc}
     85e:	46c0      	nop			; (mov r8, r8)
     860:	0016e360 	.word	0x0016e360

00000864 <HardwareSerial2::peek()>:
	virtual int peek(void)          { return serial2_peek(); }
     864:	b510      	push	{r4, lr}
     866:	f000 fd79 	bl	135c <serial2_peek>
     86a:	bd10      	pop	{r4, pc}

0000086c <HardwareSerial2::read()>:
	virtual int read(void)          { return serial2_getchar(); }
     86c:	b510      	push	{r4, lr}
     86e:	f000 fd33 	bl	12d8 <serial2_getchar>
     872:	bd10      	pop	{r4, pc}

00000874 <HardwareSerial2::available()>:
	virtual int available(void)     { return serial2_available(); }
     874:	b510      	push	{r4, lr}
     876:	f000 fd1b 	bl	12b0 <serial2_available>
     87a:	bd10      	pop	{r4, pc}

0000087c <HardwareSerial2::flush()>:
	virtual void flush(void)        { serial2_flush(); }
     87c:	b510      	push	{r4, lr}
     87e:	f000 fcf3 	bl	1268 <serial2_flush>
     882:	bd10      	pop	{r4, pc}

00000884 <HardwareSerial2::availableForWrite()>:
	virtual int availableForWrite(void) { return serial2_write_buffer_free(); }
     884:	b510      	push	{r4, lr}
     886:	f000 fcfb 	bl	1280 <serial2_write_buffer_free>
     88a:	bd10      	pop	{r4, pc}

0000088c <Print::write(unsigned char const*, unsigned int)>:
{
     88c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     88e:	0007      	movs	r7, r0
     890:	000c      	movs	r4, r1
	if (buffer == nullptr) return 0;
     892:	1e0e      	subs	r6, r1, #0
     894:	d003      	beq.n	89e <Print::write(unsigned char const*, unsigned int)+0x12>
	size_t count = 0;
     896:	2600      	movs	r6, #0
     898:	188d      	adds	r5, r1, r2
	while (size--) count += write(*buffer++);
     89a:	42a5      	cmp	r5, r4
     89c:	d101      	bne.n	8a2 <Print::write(unsigned char const*, unsigned int)+0x16>
}
     89e:	0030      	movs	r0, r6
     8a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	while (size--) count += write(*buffer++);
     8a2:	683b      	ldr	r3, [r7, #0]
     8a4:	7821      	ldrb	r1, [r4, #0]
     8a6:	0038      	movs	r0, r7
     8a8:	681b      	ldr	r3, [r3, #0]
     8aa:	4798      	blx	r3
     8ac:	3401      	adds	r4, #1
     8ae:	1836      	adds	r6, r6, r0
     8b0:	e7f3      	b.n	89a <Print::write(unsigned char const*, unsigned int)+0xe>
     8b2:	Address 0x000008b2 is out of bounds.


000008b4 <Print::println()>:
{
     8b4:	b507      	push	{r0, r1, r2, lr}
	uint8_t buf[2]={'\r', '\n'};
     8b6:	4b04      	ldr	r3, [pc, #16]	; (8c8 <Print::println()+0x14>)
     8b8:	a901      	add	r1, sp, #4
     8ba:	800b      	strh	r3, [r1, #0]
	return write(buf, 2);
     8bc:	6803      	ldr	r3, [r0, #0]
     8be:	2202      	movs	r2, #2
     8c0:	685b      	ldr	r3, [r3, #4]
     8c2:	4798      	blx	r3
}
     8c4:	bd0e      	pop	{r1, r2, r3, pc}
     8c6:	46c0      	nop			; (mov r8, r8)
     8c8:	00000a0d 	.word	0x00000a0d

000008cc <Print::printNumberDec(unsigned long, unsigned char)>:
{
     8cc:	000b      	movs	r3, r1
        p = buf + (sizeof(buf));
     8ce:	210f      	movs	r1, #15
{
     8d0:	b5f0      	push	{r4, r5, r6, r7, lr}
     8d2:	b087      	sub	sp, #28
     8d4:	9201      	str	r2, [sp, #4]
  q = 13107*q;
     8d6:	4e15      	ldr	r6, [pc, #84]	; (92c <Print::printNumberDec(unsigned long, unsigned char)+0x60>)
        p = buf + (sizeof(buf));
     8d8:	aa02      	add	r2, sp, #8
     8da:	1889      	adds	r1, r1, r2
  p = (n>>16);
     8dc:	0c1d      	lsrs	r5, r3, #16
  p = 13107*p;
     8de:	4375      	muls	r5, r6
  q = q + (q>>16) + (p&0xFFFF);
     8e0:	b2af      	uxth	r7, r5
     8e2:	46bc      	mov	ip, r7
  q = (n&0xFFFF) + 1;
     8e4:	b29c      	uxth	r4, r3
     8e6:	3401      	adds	r4, #1
  q = 13107*q;
     8e8:	4374      	muls	r4, r6
  q = q + (q>>16) + (p&0xFFFF);
     8ea:	0c22      	lsrs	r2, r4, #16
     8ec:	44a4      	add	ip, r4
     8ee:	4462      	add	r2, ip
  p = p + (p>>16) + (q>>16);
     8f0:	0c2c      	lsrs	r4, r5, #16
     8f2:	1965      	adds	r5, r4, r5
     8f4:	0c14      	lsrs	r4, r2, #16
     8f6:	1964      	adds	r4, r4, r5
  *mod = n-10*p;
     8f8:	250a      	movs	r5, #10
     8fa:	001a      	movs	r2, r3
  p = p>>1;
     8fc:	0863      	lsrs	r3, r4, #1
  *mod = n-10*p;
     8fe:	435d      	muls	r5, r3
     900:	1b52      	subs	r2, r2, r5
     902:	000c      	movs	r4, r1
                *--p = digit + '0';
     904:	3230      	adds	r2, #48	; 0x30
     906:	3901      	subs	r1, #1
     908:	700a      	strb	r2, [r1, #0]
        } while (n);
     90a:	2b00      	cmp	r3, #0
     90c:	d1e6      	bne.n	8dc <Print::printNumberDec(unsigned long, unsigned char)+0x10>
        if (sign) *--p = '-';
     90e:	9b01      	ldr	r3, [sp, #4]
     910:	2b00      	cmp	r3, #0
     912:	d003      	beq.n	91c <Print::printNumberDec(unsigned long, unsigned char)+0x50>
     914:	232d      	movs	r3, #45	; 0x2d
     916:	3901      	subs	r1, #1
     918:	700b      	strb	r3, [r1, #0]
     91a:	1ea1      	subs	r1, r4, #2
        return write(p, sizeof(buf) - (p - buf));
     91c:	43ca      	mvns	r2, r1
     91e:	ab06      	add	r3, sp, #24
     920:	18d2      	adds	r2, r2, r3
     922:	6803      	ldr	r3, [r0, #0]
     924:	685b      	ldr	r3, [r3, #4]
     926:	4798      	blx	r3
}
     928:	b007      	add	sp, #28
     92a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     92c:	00003333 	.word	0x00003333

00000930 <Stream::timedRead()>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
     930:	b573      	push	{r0, r1, r4, r5, r6, lr}
     932:	0004      	movs	r4, r0
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     934:	4d0a      	ldr	r5, [pc, #40]	; (960 <Stream::timedRead()+0x30>)
     936:	682b      	ldr	r3, [r5, #0]
     938:	9300      	str	r3, [sp, #0]
	return ret;
     93a:	9e00      	ldr	r6, [sp, #0]
  int c;
  unsigned long startMillis = millis();
  do {
    c = read();
     93c:	6823      	ldr	r3, [r4, #0]
     93e:	0020      	movs	r0, r4
     940:	695b      	ldr	r3, [r3, #20]
     942:	4798      	blx	r3
    if (c >= 0) return c;
     944:	2800      	cmp	r0, #0
     946:	da0a      	bge.n	95e <Stream::timedRead()+0x2e>
    yield();
     948:	f001 fcc0 	bl	22cc <yield>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     94c:	682b      	ldr	r3, [r5, #0]
  } while(millis() - startMillis < _timeout);
     94e:	68a2      	ldr	r2, [r4, #8]
     950:	9301      	str	r3, [sp, #4]
	return ret;
     952:	9b01      	ldr	r3, [sp, #4]
     954:	1b9b      	subs	r3, r3, r6
     956:	4293      	cmp	r3, r2
     958:	d3f0      	bcc.n	93c <Stream::timedRead()+0xc>
  return -1;     // -1 indicates timeout
     95a:	2001      	movs	r0, #1
     95c:	4240      	negs	r0, r0
}
     95e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
     960:	200000d4 	.word	0x200000d4

00000964 <Stream::setTimeout(unsigned long)>:
// Public Methods
//////////////////////////////////////////////////////////////

void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
{
  _timeout = timeout;
     964:	6081      	str	r1, [r0, #8]
}
     966:	4770      	bx	lr

00000968 <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
     968:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
     96a:	0006      	movs	r6, r0
     96c:	000f      	movs	r7, r1
     96e:	0015      	movs	r5, r2
     970:	001c      	movs	r4, r3
	if (buffer == nullptr) return 0;
     972:	2a00      	cmp	r2, #0
     974:	d01a      	beq.n	9ac <Stream::readBytesUntil(char, char*, unsigned int)+0x44>
	if (length < 1) return 0;
     976:	2b00      	cmp	r3, #0
     978:	d013      	beq.n	9a2 <Stream::readBytesUntil(char, char*, unsigned int)+0x3a>
	length--;
	size_t index = 0;
     97a:	2400      	movs	r4, #0
	length--;
     97c:	3b01      	subs	r3, #1
     97e:	9300      	str	r3, [sp, #0]
	while (index < length) {
     980:	192b      	adds	r3, r5, r4
     982:	9301      	str	r3, [sp, #4]
     984:	9b00      	ldr	r3, [sp, #0]
     986:	429c      	cmp	r4, r3
     988:	d208      	bcs.n	99c <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		int c = timedRead();
     98a:	0030      	movs	r0, r6
     98c:	f7ff ffd0 	bl	930 <Stream::timedRead()>
		if (c == terminator) break;
     990:	4287      	cmp	r7, r0
     992:	d003      	beq.n	99c <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		if (c < 0) {
     994:	2800      	cmp	r0, #0
     996:	da06      	bge.n	9a6 <Stream::readBytesUntil(char, char*, unsigned int)+0x3e>
	String readString(size_t max = 0 /* 0 means unlimited length */);
	String readStringUntil(char terminator, size_t max = 0 /* 0 means unlimited length */);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
     998:	2301      	movs	r3, #1
     99a:	7333      	strb	r3, [r6, #12]
			break;
		}
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
     99c:	2300      	movs	r3, #0
     99e:	9a01      	ldr	r2, [sp, #4]
     9a0:	7013      	strb	r3, [r2, #0]
	return index; // return number of characters, not including null terminator
}
     9a2:	0020      	movs	r0, r4
     9a4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		*buffer++ = (char)c;
     9a6:	5528      	strb	r0, [r5, r4]
		index++;
     9a8:	3401      	adds	r4, #1
     9aa:	e7e9      	b.n	980 <Stream::readBytesUntil(char, char*, unsigned int)+0x18>
	if (buffer == nullptr) return 0;
     9ac:	0014      	movs	r4, r2
     9ae:	e7f8      	b.n	9a2 <Stream::readBytesUntil(char, char*, unsigned int)+0x3a>

000009b0 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
     9b0:	b510      	push	{r4, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
     9b2:	f7ff fd9f 	bl	4f4 <setup>
	while (1) {
		loop();
     9b6:	f7ff fd8f 	bl	4d8 <loop>
		yield();
     9ba:	f001 fc87 	bl	22cc <yield>
	while (1) {
     9be:	e7fa      	b.n	9b6 <main+0x6>

000009c0 <fault_isr>:
{
     9c0:	b570      	push	{r4, r5, r6, lr}
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
     9c2:	2580      	movs	r5, #128	; 0x80
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
     9c4:	2680      	movs	r6, #128	; 0x80
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
     9c6:	02ed      	lsls	r5, r5, #11
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
     9c8:	00f6      	lsls	r6, r6, #3
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
     9ca:	4c0b      	ldr	r4, [pc, #44]	; (9f8 <fault_isr+0x38>)
     9cc:	6823      	ldr	r3, [r4, #0]
     9ce:	422b      	tst	r3, r5
     9d0:	d001      	beq.n	9d6 <fault_isr+0x16>
     9d2:	f000 ff17 	bl	1804 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
     9d6:	6823      	ldr	r3, [r4, #0]
     9d8:	4233      	tst	r3, r6
     9da:	d001      	beq.n	9e0 <fault_isr+0x20>
     9dc:	f000 fa16 	bl	e0c <uart0_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
     9e0:	6823      	ldr	r3, [r4, #0]
     9e2:	051b      	lsls	r3, r3, #20
     9e4:	d501      	bpl.n	9ea <fault_isr+0x2a>
     9e6:	f000 fcf7 	bl	13d8 <uart1_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
     9ea:	6823      	ldr	r3, [r4, #0]
     9ec:	04db      	lsls	r3, r3, #19
     9ee:	d5ec      	bpl.n	9ca <fault_isr+0xa>
     9f0:	f000 fd9e 	bl	1530 <uart2_status_isr>
     9f4:	e7e9      	b.n	9ca <fault_isr+0xa>
     9f6:	46c0      	nop			; (mov r8, r8)
     9f8:	40048034 	.word	0x40048034

000009fc <unused_isr>:
{
     9fc:	b510      	push	{r4, lr}
	fault_isr();
     9fe:	f7ff ffdf 	bl	9c0 <fault_isr>
     a02:	Address 0x00000a02 is out of bounds.


00000a04 <startup_early_hook>:
	SIM_COPC = 0;  // disable the watchdog
     a04:	2200      	movs	r2, #0
     a06:	4b01      	ldr	r3, [pc, #4]	; (a0c <startup_early_hook+0x8>)
     a08:	601a      	str	r2, [r3, #0]
}
     a0a:	4770      	bx	lr
     a0c:	40048100 	.word	0x40048100

00000a10 <startup_late_hook>:
static void startup_default_late_hook(void) {}
     a10:	4770      	bx	lr
     a12:	Address 0x00000a12 is out of bounds.


00000a14 <nvic_execution_priority>:
	uint32_t priority=256;
	uint32_t primask, faultmask, basepri, ipsr;

	// full algorithm in ARM DDI0403D, page B1-639
	// this isn't quite complete, but hopefully good enough
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
     a14:	f3ef 8013 	mrs	r0, FAULTMASK
	if (faultmask) return -1;
     a18:	2800      	cmp	r0, #0
     a1a:	d121      	bne.n	a60 <nvic_execution_priority+0x4c>
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
     a1c:	f3ef 8310 	mrs	r3, PRIMASK
	if (primask) return 0;
     a20:	2b00      	cmp	r3, #0
     a22:	d119      	bne.n	a58 <nvic_execution_priority+0x44>
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
     a24:	f3ef 8205 	mrs	r2, IPSR
	if (ipsr) {
     a28:	2a00      	cmp	r2, #0
     a2a:	d016      	beq.n	a5a <nvic_execution_priority+0x46>
		if (ipsr < 16) priority = 0; // could be non-zero
     a2c:	2a0f      	cmp	r2, #15
     a2e:	d90b      	bls.n	a48 <nvic_execution_priority+0x34>
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
     a30:	0013      	movs	r3, r2
     a32:	3b10      	subs	r3, #16
     a34:	490c      	ldr	r1, [pc, #48]	; (a68 <nvic_execution_priority+0x54>)
     a36:	089b      	lsrs	r3, r3, #2
     a38:	009b      	lsls	r3, r3, #2
     a3a:	185b      	adds	r3, r3, r1
     a3c:	2103      	movs	r1, #3
     a3e:	400a      	ands	r2, r1
     a40:	408a      	lsls	r2, r1
     a42:	681b      	ldr	r3, [r3, #0]
     a44:	40d3      	lsrs	r3, r2
     a46:	b2db      	uxtb	r3, r3
	}
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
     a48:	f3ef 8211 	mrs	r2, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
     a4c:	2a00      	cmp	r2, #0
     a4e:	d002      	beq.n	a56 <nvic_execution_priority+0x42>
     a50:	4293      	cmp	r3, r2
     a52:	d900      	bls.n	a56 <nvic_execution_priority+0x42>
     a54:	0013      	movs	r3, r2
	return priority;
     a56:	0018      	movs	r0, r3
}
     a58:	4770      	bx	lr
	uint32_t priority=256;
     a5a:	2380      	movs	r3, #128	; 0x80
     a5c:	005b      	lsls	r3, r3, #1
     a5e:	e7f3      	b.n	a48 <nvic_execution_priority+0x34>
	if (faultmask) return -1;
     a60:	2001      	movs	r0, #1
     a62:	4240      	negs	r0, r0
     a64:	e7f8      	b.n	a58 <nvic_execution_priority+0x44>
     a66:	46c0      	nop			; (mov r8, r8)
     a68:	e000e400 	.word	0xe000e400

00000a6c <ultoa>:
{
     a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     a6e:	0006      	movs	r6, r0
     a70:	000d      	movs	r5, r1
     a72:	0017      	movs	r7, r2
	int i=0, j;
     a74:	2400      	movs	r4, #0
		digit = val % radix;
     a76:	0039      	movs	r1, r7
     a78:	0030      	movs	r0, r6
     a7a:	f001 fdc9 	bl	2610 <__aeabi_uidivmod>
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
     a7e:	b2ca      	uxtb	r2, r1
     a80:	0013      	movs	r3, r2
     a82:	3337      	adds	r3, #55	; 0x37
     a84:	b2db      	uxtb	r3, r3
     a86:	2909      	cmp	r1, #9
     a88:	d801      	bhi.n	a8e <ultoa+0x22>
     a8a:	3230      	adds	r2, #48	; 0x30
     a8c:	b2d3      	uxtb	r3, r2
     a8e:	0022      	movs	r2, r4
     a90:	552b      	strb	r3, [r5, r4]
		if (val == 0) break;
     a92:	42b7      	cmp	r7, r6
     a94:	d802      	bhi.n	a9c <ultoa+0x30>
		val /= radix;
     a96:	0006      	movs	r6, r0
		i++;
     a98:	3401      	adds	r4, #1
		digit = val % radix;
     a9a:	e7ec      	b.n	a76 <ultoa+0xa>
	buf[i + 1] = 0;
     a9c:	2100      	movs	r1, #0
     a9e:	192b      	adds	r3, r5, r4
     aa0:	7059      	strb	r1, [r3, #1]
	for (j=0; j < i; j++, i--) {
     aa2:	002b      	movs	r3, r5
     aa4:	1b11      	subs	r1, r2, r4
     aa6:	42a1      	cmp	r1, r4
     aa8:	db01      	blt.n	aae <ultoa+0x42>
}
     aaa:	0028      	movs	r0, r5
     aac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		t = buf[j];
     aae:	7819      	ldrb	r1, [r3, #0]
		buf[j] = buf[i];
     ab0:	5d28      	ldrb	r0, [r5, r4]
     ab2:	7018      	strb	r0, [r3, #0]
		buf[i] = t;
     ab4:	5529      	strb	r1, [r5, r4]
	for (j=0; j < i; j++, i--) {
     ab6:	3301      	adds	r3, #1
     ab8:	3c01      	subs	r4, #1
     aba:	e7f3      	b.n	aa4 <ultoa+0x38>

00000abc <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
     abc:	4770      	bx	lr
     abe:	Address 0x00000abe is out of bounds.


00000ac0 <porta_interrupt>:
#define DISPATCH_PIN_ISR(pin_nr) { voidFuncPtr pin_isr = intFunc[pin_nr]; \
                                   if(isfr & CORE_PIN ## pin_nr ## _BITMASK) pin_isr(); }

static void porta_interrupt(void)
{
	uint32_t isfr = PORTA_ISFR;
     ac0:	4b06      	ldr	r3, [pc, #24]	; (adc <porta_interrupt+0x1c>)
{
     ac2:	b570      	push	{r4, r5, r6, lr}
	uint32_t isfr = PORTA_ISFR;
     ac4:	681c      	ldr	r4, [r3, #0]
	PORTA_ISFR = isfr;
	DISPATCH_PIN_ISR(3);
     ac6:	4d06      	ldr	r5, [pc, #24]	; (ae0 <porta_interrupt+0x20>)
	PORTA_ISFR = isfr;
     ac8:	601c      	str	r4, [r3, #0]
	DISPATCH_PIN_ISR(3);
     aca:	68eb      	ldr	r3, [r5, #12]
     acc:	07a2      	lsls	r2, r4, #30
     ace:	d500      	bpl.n	ad2 <porta_interrupt+0x12>
     ad0:	4798      	blx	r3
	DISPATCH_PIN_ISR(4);
     ad2:	692b      	ldr	r3, [r5, #16]
     ad4:	0764      	lsls	r4, r4, #29
     ad6:	d500      	bpl.n	ada <porta_interrupt+0x1a>
     ad8:	4798      	blx	r3
}
     ada:	bd70      	pop	{r4, r5, r6, pc}
     adc:	400490a0 	.word	0x400490a0
     ae0:	1ffffd34 	.word	0x1ffffd34

00000ae4 <portcd_interrupt>:

static void portcd_interrupt(void)
{
	uint32_t isfr = PORTC_ISFR;
     ae4:	4b24      	ldr	r3, [pc, #144]	; (b78 <portcd_interrupt+0x94>)
{
     ae6:	b570      	push	{r4, r5, r6, lr}
	uint32_t isfr = PORTC_ISFR;
     ae8:	681d      	ldr	r5, [r3, #0]
	PORTC_ISFR = isfr;
	DISPATCH_PIN_ISR(9);
     aea:	4c24      	ldr	r4, [pc, #144]	; (b7c <portcd_interrupt+0x98>)
	PORTC_ISFR = isfr;
     aec:	601d      	str	r5, [r3, #0]
	DISPATCH_PIN_ISR(9);
     aee:	6a63      	ldr	r3, [r4, #36]	; 0x24
     af0:	072a      	lsls	r2, r5, #28
     af2:	d500      	bpl.n	af6 <portcd_interrupt+0x12>
     af4:	4798      	blx	r3
	DISPATCH_PIN_ISR(10);
     af6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
     af8:	06ea      	lsls	r2, r5, #27
     afa:	d500      	bpl.n	afe <portcd_interrupt+0x1a>
     afc:	4798      	blx	r3
	DISPATCH_PIN_ISR(11);
     afe:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
     b00:	066a      	lsls	r2, r5, #25
     b02:	d500      	bpl.n	b06 <portcd_interrupt+0x22>
     b04:	4798      	blx	r3
	DISPATCH_PIN_ISR(12);
     b06:	6b23      	ldr	r3, [r4, #48]	; 0x30
     b08:	062a      	lsls	r2, r5, #24
     b0a:	d500      	bpl.n	b0e <portcd_interrupt+0x2a>
     b0c:	4798      	blx	r3
	DISPATCH_PIN_ISR(13);
     b0e:	6b63      	ldr	r3, [r4, #52]	; 0x34
     b10:	06aa      	lsls	r2, r5, #26
     b12:	d500      	bpl.n	b16 <portcd_interrupt+0x32>
     b14:	4798      	blx	r3
	DISPATCH_PIN_ISR(15);
     b16:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     b18:	07ea      	lsls	r2, r5, #31
     b1a:	d500      	bpl.n	b1e <portcd_interrupt+0x3a>
     b1c:	4798      	blx	r3
	DISPATCH_PIN_ISR(22);
     b1e:	6da3      	ldr	r3, [r4, #88]	; 0x58
     b20:	07aa      	lsls	r2, r5, #30
     b22:	d500      	bpl.n	b26 <portcd_interrupt+0x42>
     b24:	4798      	blx	r3
	DISPATCH_PIN_ISR(23);
     b26:	6de3      	ldr	r3, [r4, #92]	; 0x5c
     b28:	076d      	lsls	r5, r5, #29
     b2a:	d500      	bpl.n	b2e <portcd_interrupt+0x4a>
     b2c:	4798      	blx	r3
	isfr = PORTD_ISFR;
     b2e:	4b14      	ldr	r3, [pc, #80]	; (b80 <portcd_interrupt+0x9c>)
     b30:	681d      	ldr	r5, [r3, #0]
	PORTD_ISFR = isfr;
     b32:	601d      	str	r5, [r3, #0]
	DISPATCH_PIN_ISR(2);
     b34:	68a3      	ldr	r3, [r4, #8]
     b36:	07ea      	lsls	r2, r5, #31
     b38:	d500      	bpl.n	b3c <portcd_interrupt+0x58>
     b3a:	4798      	blx	r3
	DISPATCH_PIN_ISR(5);
     b3c:	6963      	ldr	r3, [r4, #20]
     b3e:	062a      	lsls	r2, r5, #24
     b40:	d500      	bpl.n	b44 <portcd_interrupt+0x60>
     b42:	4798      	blx	r3
	DISPATCH_PIN_ISR(6);
     b44:	69a3      	ldr	r3, [r4, #24]
     b46:	06ea      	lsls	r2, r5, #27
     b48:	d500      	bpl.n	b4c <portcd_interrupt+0x68>
     b4a:	4798      	blx	r3
	DISPATCH_PIN_ISR(7);
     b4c:	69e3      	ldr	r3, [r4, #28]
     b4e:	076a      	lsls	r2, r5, #29
     b50:	d500      	bpl.n	b54 <portcd_interrupt+0x70>
     b52:	4798      	blx	r3
	DISPATCH_PIN_ISR(8);
     b54:	6a23      	ldr	r3, [r4, #32]
     b56:	072a      	lsls	r2, r5, #28
     b58:	d500      	bpl.n	b5c <portcd_interrupt+0x78>
     b5a:	4798      	blx	r3
	DISPATCH_PIN_ISR(14);
     b5c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     b5e:	07aa      	lsls	r2, r5, #30
     b60:	d500      	bpl.n	b64 <portcd_interrupt+0x80>
     b62:	4798      	blx	r3
	DISPATCH_PIN_ISR(20);
     b64:	6d23      	ldr	r3, [r4, #80]	; 0x50
     b66:	06aa      	lsls	r2, r5, #26
     b68:	d500      	bpl.n	b6c <portcd_interrupt+0x88>
     b6a:	4798      	blx	r3
	DISPATCH_PIN_ISR(21);
     b6c:	6d63      	ldr	r3, [r4, #84]	; 0x54
     b6e:	066d      	lsls	r5, r5, #25
     b70:	d500      	bpl.n	b74 <portcd_interrupt+0x90>
     b72:	4798      	blx	r3
}
     b74:	bd70      	pop	{r4, r5, r6, pc}
     b76:	46c0      	nop			; (mov r8, r8)
     b78:	4004b0a0 	.word	0x4004b0a0
     b7c:	1ffffd34 	.word	0x1ffffd34
     b80:	4004c0a0 	.word	0x4004c0a0

00000b84 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
     b84:	4770      	bx	lr
     b86:	Address 0x00000b86 is out of bounds.


00000b88 <_init_Teensyduino_internal_>:
	NVIC_ENABLE_IRQ(IRQ_PORTB);
	NVIC_ENABLE_IRQ(IRQ_PORTC);
	NVIC_ENABLE_IRQ(IRQ_PORTD);
	NVIC_ENABLE_IRQ(IRQ_PORTE);
#elif defined(__MKL26Z64__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
     b88:	2280      	movs	r2, #128	; 0x80
     b8a:	4b22      	ldr	r3, [pc, #136]	; (c14 <_init_Teensyduino_internal_+0x8c>)
     b8c:	05d2      	lsls	r2, r2, #23
{
     b8e:	b513      	push	{r0, r1, r4, lr}
	NVIC_ENABLE_IRQ(IRQ_PORTA);
     b90:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
     b92:	2280      	movs	r2, #128	; 0x80
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
     b94:	2000      	movs	r0, #0
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
     b96:	0612      	lsls	r2, r2, #24
     b98:	601a      	str	r2, [r3, #0]
	FTM0_CNT = 0;
     b9a:	4b1f      	ldr	r3, [pc, #124]	; (c18 <_init_Teensyduino_internal_+0x90>)
	FTM0_MOD = DEFAULT_FTM_MOD;
     b9c:	491f      	ldr	r1, [pc, #124]	; (c1c <_init_Teensyduino_internal_+0x94>)
	FTM0_CNT = 0;
     b9e:	6018      	str	r0, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
     ba0:	4b1f      	ldr	r3, [pc, #124]	; (c20 <_init_Teensyduino_internal_+0x98>)
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
     ba2:	4a20      	ldr	r2, [pc, #128]	; (c24 <_init_Teensyduino_internal_+0x9c>)
	FTM0_MOD = DEFAULT_FTM_MOD;
     ba4:	6019      	str	r1, [r3, #0]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
     ba6:	2328      	movs	r3, #40	; 0x28
     ba8:	6013      	str	r3, [r2, #0]
	FTM0_C1SC = 0x28;
     baa:	4a1f      	ldr	r2, [pc, #124]	; (c28 <_init_Teensyduino_internal_+0xa0>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
     bac:	4c1f      	ldr	r4, [pc, #124]	; (c2c <_init_Teensyduino_internal_+0xa4>)
	FTM0_C1SC = 0x28;
     bae:	6013      	str	r3, [r2, #0]
	FTM0_C2SC = 0x28;
     bb0:	4a1f      	ldr	r2, [pc, #124]	; (c30 <_init_Teensyduino_internal_+0xa8>)
     bb2:	6013      	str	r3, [r2, #0]
	FTM0_C3SC = 0x28;
     bb4:	4a1f      	ldr	r2, [pc, #124]	; (c34 <_init_Teensyduino_internal_+0xac>)
     bb6:	6013      	str	r3, [r2, #0]
	FTM0_C4SC = 0x28;
     bb8:	4a1f      	ldr	r2, [pc, #124]	; (c38 <_init_Teensyduino_internal_+0xb0>)
     bba:	6013      	str	r3, [r2, #0]
	FTM0_C5SC = 0x28;
     bbc:	4a1f      	ldr	r2, [pc, #124]	; (c3c <_init_Teensyduino_internal_+0xb4>)
     bbe:	6013      	str	r3, [r2, #0]
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
     bc0:	2209      	movs	r2, #9
     bc2:	6022      	str	r2, [r4, #0]
	FTM1_CNT = 0;
     bc4:	4c1e      	ldr	r4, [pc, #120]	; (c40 <_init_Teensyduino_internal_+0xb8>)
     bc6:	6020      	str	r0, [r4, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
     bc8:	4c1e      	ldr	r4, [pc, #120]	; (c44 <_init_Teensyduino_internal_+0xbc>)
     bca:	6021      	str	r1, [r4, #0]
	FTM1_C0SC = 0x28;
     bcc:	4c1e      	ldr	r4, [pc, #120]	; (c48 <_init_Teensyduino_internal_+0xc0>)
     bce:	6023      	str	r3, [r4, #0]
	FTM1_C1SC = 0x28;
     bd0:	4c1e      	ldr	r4, [pc, #120]	; (c4c <_init_Teensyduino_internal_+0xc4>)
     bd2:	6023      	str	r3, [r4, #0]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
     bd4:	4c1e      	ldr	r4, [pc, #120]	; (c50 <_init_Teensyduino_internal_+0xc8>)
     bd6:	6022      	str	r2, [r4, #0]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
     bd8:	4c1e      	ldr	r4, [pc, #120]	; (c54 <_init_Teensyduino_internal_+0xcc>)
     bda:	6020      	str	r0, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
     bdc:	481e      	ldr	r0, [pc, #120]	; (c58 <_init_Teensyduino_internal_+0xd0>)
     bde:	6001      	str	r1, [r0, #0]
	FTM2_C0SC = 0x28;
     be0:	491e      	ldr	r1, [pc, #120]	; (c5c <_init_Teensyduino_internal_+0xd4>)
     be2:	600b      	str	r3, [r1, #0]
	FTM2_C1SC = 0x28;
     be4:	491e      	ldr	r1, [pc, #120]	; (c60 <_init_Teensyduino_internal_+0xd8>)
     be6:	600b      	str	r3, [r1, #0]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
     be8:	4b1e      	ldr	r3, [pc, #120]	; (c64 <_init_Teensyduino_internal_+0xdc>)
     bea:	601a      	str	r2, [r3, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
     bec:	f001 fbfc 	bl	23e8 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
     bf0:	f7ff ffc8 	bl	b84 <startup_middle_hook>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     bf4:	4c1c      	ldr	r4, [pc, #112]	; (c68 <_init_Teensyduino_internal_+0xe0>)
     bf6:	6823      	ldr	r3, [r4, #0]
     bf8:	9300      	str	r3, [sp, #0]
	return ret;
     bfa:	9b00      	ldr	r3, [sp, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
     bfc:	2b13      	cmp	r3, #19
     bfe:	d9fa      	bls.n	bf6 <_init_Teensyduino_internal_+0x6e>
	usb_init();
     c00:	f001 f910 	bl	1e24 <usb_init>
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
     c04:	2396      	movs	r3, #150	; 0x96
     c06:	005b      	lsls	r3, r3, #1
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     c08:	6822      	ldr	r2, [r4, #0]
     c0a:	9201      	str	r2, [sp, #4]
	return ret;
     c0c:	9a01      	ldr	r2, [sp, #4]
     c0e:	429a      	cmp	r2, r3
     c10:	d3fa      	bcc.n	c08 <_init_Teensyduino_internal_+0x80>
}
     c12:	bd13      	pop	{r0, r1, r4, pc}
     c14:	e000e100 	.word	0xe000e100
     c18:	40038004 	.word	0x40038004
     c1c:	0000bfff 	.word	0x0000bfff
     c20:	40038008 	.word	0x40038008
     c24:	4003800c 	.word	0x4003800c
     c28:	40038014 	.word	0x40038014
     c2c:	40038000 	.word	0x40038000
     c30:	4003801c 	.word	0x4003801c
     c34:	40038024 	.word	0x40038024
     c38:	4003802c 	.word	0x4003802c
     c3c:	40038034 	.word	0x40038034
     c40:	40039004 	.word	0x40039004
     c44:	40039008 	.word	0x40039008
     c48:	4003900c 	.word	0x4003900c
     c4c:	40039014 	.word	0x40039014
     c50:	40039000 	.word	0x40039000
     c54:	4003a004 	.word	0x4003a004
     c58:	4003a008 	.word	0x4003a008
     c5c:	4003a00c 	.word	0x4003a00c
     c60:	4003a014 	.word	0x4003a014
     c64:	4003a000 	.word	0x4003a000
     c68:	200000d4 	.word	0x200000d4

00000c6c <digitalWrite>:


// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
     c6c:	0002      	movs	r2, r0
     c6e:	b510      	push	{r4, lr}
	if (pin >= CORE_NUM_DIGITAL) return;
     c70:	281a      	cmp	r0, #26
     c72:	d80b      	bhi.n	c8c <digitalWrite+0x20>
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
		}
#else
	if (*portModeRegister(pin) & digitalPinToBitMask(pin)) {
     c74:	230c      	movs	r3, #12
     c76:	4353      	muls	r3, r2
     c78:	480c      	ldr	r0, [pc, #48]	; (cac <digitalWrite+0x40>)
     c7a:	581a      	ldr	r2, [r3, r0]
     c7c:	18c0      	adds	r0, r0, r3
     c7e:	7d14      	ldrb	r4, [r2, #20]
     c80:	7a03      	ldrb	r3, [r0, #8]
     c82:	4223      	tst	r3, r4
     c84:	d005      	beq.n	c92 <digitalWrite+0x26>
		if (val) {
     c86:	2900      	cmp	r1, #0
     c88:	d001      	beq.n	c8e <digitalWrite+0x22>
			*portSetRegister(pin) = digitalPinToBitMask(pin);
     c8a:	7113      	strb	r3, [r2, #4]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
     c8c:	bd10      	pop	{r4, pc}
			*portClearRegister(pin) = digitalPinToBitMask(pin);
     c8e:	7213      	strb	r3, [r2, #8]
     c90:	e7fc      	b.n	c8c <digitalWrite+0x20>
		volatile uint32_t *config = portConfigRegister(pin);
     c92:	6843      	ldr	r3, [r0, #4]
		if (val) {
     c94:	2900      	cmp	r1, #0
     c96:	d004      	beq.n	ca2 <digitalWrite+0x36>
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
     c98:	2203      	movs	r2, #3
     c9a:	6819      	ldr	r1, [r3, #0]
     c9c:	430a      	orrs	r2, r1
			*config &= ~(PORT_PCR_PE);
     c9e:	601a      	str	r2, [r3, #0]
     ca0:	e7f4      	b.n	c8c <digitalWrite+0x20>
     ca2:	2102      	movs	r1, #2
     ca4:	681a      	ldr	r2, [r3, #0]
     ca6:	438a      	bics	r2, r1
     ca8:	e7f9      	b.n	c9e <digitalWrite+0x32>
     caa:	46c0      	nop			; (mov r8, r8)
     cac:	00002950 	.word	0x00002950

00000cb0 <pinMode>:
}



void pinMode(uint8_t pin, uint8_t mode)
{
     cb0:	0003      	movs	r3, r0
     cb2:	b510      	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
     cb4:	281a      	cmp	r0, #26
     cb6:	d81b      	bhi.n	cf0 <pinMode+0x40>
	config = portConfigRegister(pin);
     cb8:	200c      	movs	r0, #12
     cba:	4358      	muls	r0, r3
     cbc:	4a15      	ldr	r2, [pc, #84]	; (d14 <pinMode+0x64>)
     cbe:	1814      	adds	r4, r2, r0
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
     cc0:	5882      	ldr	r2, [r0, r2]
	config = portConfigRegister(pin);
     cc2:	6863      	ldr	r3, [r4, #4]
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
     cc4:	7d10      	ldrb	r0, [r2, #20]
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
     cc6:	7a24      	ldrb	r4, [r4, #8]
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
     cc8:	2901      	cmp	r1, #1
     cca:	d001      	beq.n	cd0 <pinMode+0x20>
     ccc:	2904      	cmp	r1, #4
     cce:	d110      	bne.n	cf2 <pinMode+0x42>
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
     cd0:	4320      	orrs	r0, r4
     cd2:	7510      	strb	r0, [r2, #20]
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
     cd4:	22a2      	movs	r2, #162	; 0xa2
     cd6:	0052      	lsls	r2, r2, #1
     cd8:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
     cda:	3a25      	subs	r2, #37	; 0x25
     cdc:	3aff      	subs	r2, #255	; 0xff
     cde:	2904      	cmp	r1, #4
     ce0:	d103      	bne.n	cea <pinMode+0x3a>
		    *config |= PORT_PCR_ODE;
     ce2:	6819      	ldr	r1, [r3, #0]
     ce4:	430a      	orrs	r2, r1
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
		} else { // INPUT_DISABLE
			*config = 0;
     ce6:	601a      	str	r2, [r3, #0]
     ce8:	e002      	b.n	cf0 <pinMode+0x40>
		    *config &= ~PORT_PCR_ODE;
     cea:	6819      	ldr	r1, [r3, #0]
     cec:	4391      	bics	r1, r2
     cee:	6019      	str	r1, [r3, #0]
		}
	}
}
     cf0:	bd10      	pop	{r4, pc}
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
     cf2:	43a0      	bics	r0, r4
     cf4:	7510      	strb	r0, [r2, #20]
			*config = PORT_PCR_MUX(1);
     cf6:	2280      	movs	r2, #128	; 0x80
		if (mode == INPUT) {
     cf8:	2900      	cmp	r1, #0
     cfa:	d008      	beq.n	d0e <pinMode+0x5e>
		} else if (mode == INPUT_PULLUP) {
     cfc:	2902      	cmp	r1, #2
     cfe:	d102      	bne.n	d06 <pinMode+0x56>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
     d00:	2204      	movs	r2, #4
     d02:	32ff      	adds	r2, #255	; 0xff
     d04:	e7ef      	b.n	ce6 <pinMode+0x36>
			*config = 0;
     d06:	2200      	movs	r2, #0
		} else if (mode == INPUT_PULLDOWN) {
     d08:	2903      	cmp	r1, #3
     d0a:	d1ec      	bne.n	ce6 <pinMode+0x36>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
     d0c:	2281      	movs	r2, #129	; 0x81
     d0e:	0052      	lsls	r2, r2, #1
     d10:	e7e9      	b.n	ce6 <pinMode+0x36>
     d12:	46c0      	nop			; (mov r8, r8)
     d14:	00002950 	.word	0x00002950

00000d18 <attachInterrupt>:
{
     d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     d1a:	0004      	movs	r4, r0
     d1c:	000e      	movs	r6, r1
	if (pin >= CORE_NUM_DIGITAL) return;
     d1e:	281a      	cmp	r0, #26
     d20:	d828      	bhi.n	d74 <attachInterrupt+0x5c>
	switch (mode) {
     d22:	2a04      	cmp	r2, #4
     d24:	d826      	bhi.n	d74 <attachInterrupt+0x5c>
	mask = (mask << 16) | 0x01000000;
     d26:	4b14      	ldr	r3, [pc, #80]	; (d78 <attachInterrupt+0x60>)
     d28:	5c9f      	ldrb	r7, [r3, r2]
	config = portConfigRegister(pin);
     d2a:	220c      	movs	r2, #12
     d2c:	4342      	muls	r2, r0
     d2e:	4b13      	ldr	r3, [pc, #76]	; (d7c <attachInterrupt+0x64>)
	mask = (mask << 16) | 0x01000000;
     d30:	043f      	lsls	r7, r7, #16
	config = portConfigRegister(pin);
     d32:	189b      	adds	r3, r3, r2
     d34:	685d      	ldr	r5, [r3, #4]
	if ((*config & 0x00000700) == 0) {
     d36:	23e0      	movs	r3, #224	; 0xe0
     d38:	682a      	ldr	r2, [r5, #0]
     d3a:	00db      	lsls	r3, r3, #3
     d3c:	0011      	movs	r1, r2
     d3e:	4019      	ands	r1, r3
     d40:	421a      	tst	r2, r3
     d42:	d101      	bne.n	d48 <attachInterrupt+0x30>
		pinMode(pin, INPUT);
     d44:	f7ff ffb4 	bl	cb0 <pinMode>
	_VectorsRam[irq + 16] = function;
     d48:	4b0d      	ldr	r3, [pc, #52]	; (d80 <attachInterrupt+0x68>)
     d4a:	490e      	ldr	r1, [pc, #56]	; (d84 <attachInterrupt+0x6c>)
     d4c:	001a      	movs	r2, r3
     d4e:	32b8      	adds	r2, #184	; 0xb8
     d50:	6011      	str	r1, [r2, #0]
     d52:	4a0d      	ldr	r2, [pc, #52]	; (d88 <attachInterrupt+0x70>)
     d54:	33bc      	adds	r3, #188	; 0xbc
     d56:	601a      	str	r2, [r3, #0]
	__disable_irq();
     d58:	b672      	cpsid	i
	cfg &= ~0x000F0000;		// disable any previous interrupt
     d5a:	4a0c      	ldr	r2, [pc, #48]	; (d8c <attachInterrupt+0x74>)
	cfg = *config;
     d5c:	682b      	ldr	r3, [r5, #0]
	intFunc[pin] = function;	// set the function pointer
     d5e:	00a4      	lsls	r4, r4, #2
	cfg &= ~0x000F0000;		// disable any previous interrupt
     d60:	4013      	ands	r3, r2
	*config = cfg;
     d62:	602b      	str	r3, [r5, #0]
     d64:	431f      	orrs	r7, r3
	intFunc[pin] = function;	// set the function pointer
     d66:	4b0a      	ldr	r3, [pc, #40]	; (d90 <attachInterrupt+0x78>)
     d68:	50e6      	str	r6, [r4, r3]
	cfg |= mask;
     d6a:	2380      	movs	r3, #128	; 0x80
     d6c:	045b      	lsls	r3, r3, #17
     d6e:	431f      	orrs	r7, r3
	*config = cfg;			// enable the new interrupt
     d70:	602f      	str	r7, [r5, #0]
	__enable_irq();
     d72:	b662      	cpsie	i
}
     d74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     d76:	46c0      	nop			; (mov r8, r8)
     d78:	00002948 	.word	0x00002948
     d7c:	00002950 	.word	0x00002950
     d80:	1ffff900 	.word	0x1ffff900
     d84:	00000ac1 	.word	0x00000ac1
     d88:	00000ae5 	.word	0x00000ae5
     d8c:	fff0ffff 	.word	0xfff0ffff
     d90:	1ffffd34 	.word	0x1ffffd34

00000d94 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
     d94:	b672      	cpsid	i
	current = SYST_CVR;
     d96:	4b0b      	ldr	r3, [pc, #44]	; (dc4 <micros+0x30>)
     d98:	6819      	ldr	r1, [r3, #0]
	count = systick_millis_count;
     d9a:	4b0b      	ldr	r3, [pc, #44]	; (dc8 <micros+0x34>)
     d9c:	681a      	ldr	r2, [r3, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     d9e:	4b0b      	ldr	r3, [pc, #44]	; (dcc <micros+0x38>)
     da0:	681b      	ldr	r3, [r3, #0]
	__enable_irq();
     da2:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     da4:	015b      	lsls	r3, r3, #5
     da6:	d502      	bpl.n	dae <micros+0x1a>
     da8:	2932      	cmp	r1, #50	; 0x32
     daa:	d900      	bls.n	dae <micros+0x1a>
     dac:	3201      	adds	r2, #1
	current = ((F_CPU / 1000) - 1) - current;
     dae:	4b08      	ldr	r3, [pc, #32]	; (dd0 <micros+0x3c>)
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
     db0:	4808      	ldr	r0, [pc, #32]	; (dd4 <micros+0x40>)
	current = ((F_CPU / 1000) - 1) - current;
     db2:	1a5b      	subs	r3, r3, r1
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
     db4:	4358      	muls	r0, r3
     db6:	23fa      	movs	r3, #250	; 0xfa
     db8:	009b      	lsls	r3, r3, #2
     dba:	4353      	muls	r3, r2
     dbc:	0d80      	lsrs	r0, r0, #22
     dbe:	18c0      	adds	r0, r0, r3
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
}
     dc0:	4770      	bx	lr
     dc2:	46c0      	nop			; (mov r8, r8)
     dc4:	e000e018 	.word	0xe000e018
     dc8:	200000d4 	.word	0x200000d4
     dcc:	e000ed04 	.word	0xe000ed04
     dd0:	0000bb7f 	.word	0x0000bb7f
     dd4:	00015555 	.word	0x00015555

00000dd8 <delay>:

void delay(uint32_t ms)
{
     dd8:	b570      	push	{r4, r5, r6, lr}
     dda:	0004      	movs	r4, r0
	uint32_t start = micros();
     ddc:	f7ff ffda 	bl	d94 <micros>
     de0:	0005      	movs	r5, r0

	if (ms > 0) {
     de2:	2c00      	cmp	r4, #0
     de4:	d010      	beq.n	e08 <delay+0x30>
		while (1) {
			while ((micros() - start) >= 1000) {
     de6:	26fa      	movs	r6, #250	; 0xfa
     de8:	00b6      	lsls	r6, r6, #2
     dea:	f7ff ffd3 	bl	d94 <micros>
     dee:	1b40      	subs	r0, r0, r5
     df0:	42b0      	cmp	r0, r6
     df2:	d202      	bcs.n	dfa <delay+0x22>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
     df4:	f001 fa6a 	bl	22cc <yield>
			while ((micros() - start) >= 1000) {
     df8:	e7f7      	b.n	dea <delay+0x12>
				ms--;
     dfa:	3c01      	subs	r4, #1
				if (ms == 0) return;
     dfc:	2c00      	cmp	r4, #0
     dfe:	d003      	beq.n	e08 <delay+0x30>
				start += 1000;
     e00:	23fa      	movs	r3, #250	; 0xfa
     e02:	009b      	lsls	r3, r3, #2
     e04:	18ed      	adds	r5, r5, r3
     e06:	e7f0      	b.n	dea <delay+0x12>
		}
	}
}
     e08:	bd70      	pop	{r4, r5, r6, pc}
     e0a:	Address 0x00000e0a is out of bounds.


00000e0c <uart0_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart0_status_isr(void)
{
     e0c:	b537      	push	{r0, r1, r2, r4, r5, lr}
		} while (UART0_TCFIFO < 8);
		tx_buffer_tail = tail;
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
	}
#else
	if (UART0_S1 & UART_S1_RDRF) {
     e0e:	4a35      	ldr	r2, [pc, #212]	; (ee4 <uart0_status_isr+0xd8>)
     e10:	7913      	ldrb	r3, [r2, #4]
     e12:	069b      	lsls	r3, r3, #26
     e14:	d513      	bpl.n	e3e <uart0_status_isr+0x32>
		if (use9Bits && (UART0_C3 & 0x80)) {
			n = UART0_D | 0x100;
		} else {
			n = UART0_D;
		}
		head = rx_buffer_head + 1;
     e16:	4d34      	ldr	r5, [pc, #208]	; (ee8 <uart0_status_isr+0xdc>)
		if (head >= rx_buffer_total_size_) head = 0;
     e18:	4834      	ldr	r0, [pc, #208]	; (eec <uart0_status_isr+0xe0>)
			n = UART0_D;
     e1a:	79d1      	ldrb	r1, [r2, #7]
		head = rx_buffer_head + 1;
     e1c:	782b      	ldrb	r3, [r5, #0]
		if (head >= rx_buffer_total_size_) head = 0;
     e1e:	6800      	ldr	r0, [r0, #0]
		head = rx_buffer_head + 1;
     e20:	3301      	adds	r3, #1
		if (head >= rx_buffer_total_size_) head = 0;
     e22:	4283      	cmp	r3, r0
     e24:	4180      	sbcs	r0, r0
     e26:	4003      	ands	r3, r0
		if (head != rx_buffer_tail) {
     e28:	4831      	ldr	r0, [pc, #196]	; (ef0 <uart0_status_isr+0xe4>)
			n = UART0_D;
     e2a:	b2c9      	uxtb	r1, r1
		if (head != rx_buffer_tail) {
     e2c:	7800      	ldrb	r0, [r0, #0]
     e2e:	4298      	cmp	r0, r3
     e30:	d005      	beq.n	e3e <uart0_status_isr+0x32>
			if (head < SERIAL1_RX_BUFFER_SIZE) {
     e32:	2b3f      	cmp	r3, #63	; 0x3f
     e34:	d838      	bhi.n	ea8 <uart0_status_isr+0x9c>
				rx_buffer[head] = n;
     e36:	482f      	ldr	r0, [pc, #188]	; (ef4 <uart0_status_isr+0xe8>)
     e38:	54c1      	strb	r1, [r0, r3]
			} else {
				rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
			}

			rx_buffer_head = head;
     e3a:	b2db      	uxtb	r3, r3
     e3c:	702b      	strb	r3, [r5, #0]
		}
	}
	c = UART0_C2;
     e3e:	78d3      	ldrb	r3, [r2, #3]
     e40:	b2dc      	uxtb	r4, r3
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
     e42:	b25b      	sxtb	r3, r3
     e44:	2b00      	cmp	r3, #0
     e46:	da0c      	bge.n	e62 <uart0_status_isr+0x56>
     e48:	7913      	ldrb	r3, [r2, #4]
     e4a:	b25b      	sxtb	r3, r3
     e4c:	2b00      	cmp	r3, #0
     e4e:	da08      	bge.n	e62 <uart0_status_isr+0x56>
		head = tx_buffer_head;
     e50:	4b29      	ldr	r3, [pc, #164]	; (ef8 <uart0_status_isr+0xec>)
		tail = tx_buffer_tail;
     e52:	482a      	ldr	r0, [pc, #168]	; (efc <uart0_status_isr+0xf0>)
		head = tx_buffer_head;
     e54:	781d      	ldrb	r5, [r3, #0]
		tail = tx_buffer_tail;
     e56:	7801      	ldrb	r1, [r0, #0]
     e58:	b2cb      	uxtb	r3, r1
		if (head == tail) {
     e5a:	428d      	cmp	r5, r1
     e5c:	d12b      	bne.n	eb6 <uart0_status_isr+0xaa>
			UART0_C2 = C2_TX_COMPLETING;
     e5e:	236c      	movs	r3, #108	; 0x6c
     e60:	70d3      	strb	r3, [r2, #3]
			UART0_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
     e62:	2340      	movs	r3, #64	; 0x40
     e64:	421c      	tst	r4, r3
     e66:	d01e      	beq.n	ea6 <uart0_status_isr+0x9a>
     e68:	7911      	ldrb	r1, [r2, #4]
     e6a:	4219      	tst	r1, r3
     e6c:	d01b      	beq.n	ea6 <uart0_status_isr+0x9a>
		transmitting = 0;
     e6e:	2100      	movs	r1, #0
     e70:	4b23      	ldr	r3, [pc, #140]	; (f00 <uart0_status_isr+0xf4>)
     e72:	7019      	strb	r1, [r3, #0]
		if (transmit_pin) transmit_deassert();
     e74:	4b23      	ldr	r3, [pc, #140]	; (f04 <uart0_status_isr+0xf8>)
     e76:	681b      	ldr	r3, [r3, #0]
     e78:	428b      	cmp	r3, r1
     e7a:	d002      	beq.n	e82 <uart0_status_isr+0x76>
     e7c:	4922      	ldr	r1, [pc, #136]	; (f08 <uart0_status_isr+0xfc>)
     e7e:	7809      	ldrb	r1, [r1, #0]
     e80:	7219      	strb	r1, [r3, #8]
		#if defined(KINETISL)
		if (half_duplex_mode) {
     e82:	4b22      	ldr	r3, [pc, #136]	; (f0c <uart0_status_isr+0x100>)
     e84:	781b      	ldrb	r3, [r3, #0]
     e86:	2b00      	cmp	r3, #0
     e88:	d00b      	beq.n	ea2 <uart0_status_isr+0x96>
			__disable_irq();
     e8a:	b672      	cpsid	i
			volatile uint32_t reg = UART0_C3;
			reg &= ~UART_C3_TXDIR;
     e8c:	2120      	movs	r1, #32
			volatile uint32_t reg = UART0_C3;
     e8e:	7993      	ldrb	r3, [r2, #6]
     e90:	b2db      	uxtb	r3, r3
     e92:	9301      	str	r3, [sp, #4]
			reg &= ~UART_C3_TXDIR;
     e94:	9b01      	ldr	r3, [sp, #4]
     e96:	438b      	bics	r3, r1
     e98:	9301      	str	r3, [sp, #4]
			UART0_C3 = reg;
     e9a:	9b01      	ldr	r3, [sp, #4]
     e9c:	b2db      	uxtb	r3, r3
     e9e:	7193      	strb	r3, [r2, #6]
			__enable_irq();
     ea0:	b662      	cpsie	i
		}
		#endif
		UART0_C2 = C2_TX_INACTIVE;
     ea2:	232c      	movs	r3, #44	; 0x2c
     ea4:	70d3      	strb	r3, [r2, #3]
	}
}
     ea6:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
				rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
     ea8:	001c      	movs	r4, r3
     eaa:	4819      	ldr	r0, [pc, #100]	; (f10 <uart0_status_isr+0x104>)
     eac:	3c40      	subs	r4, #64	; 0x40
     eae:	6800      	ldr	r0, [r0, #0]
     eb0:	1900      	adds	r0, r0, r4
     eb2:	7001      	strb	r1, [r0, #0]
     eb4:	e7c1      	b.n	e3a <uart0_status_isr+0x2e>
			if (++tail >= tx_buffer_total_size_) tail = 0;
     eb6:	4d17      	ldr	r5, [pc, #92]	; (f14 <uart0_status_isr+0x108>)
     eb8:	1c59      	adds	r1, r3, #1
     eba:	682d      	ldr	r5, [r5, #0]
     ebc:	428d      	cmp	r5, r1
     ebe:	d909      	bls.n	ed4 <uart0_status_isr+0xc8>
			if (tail < SERIAL1_TX_BUFFER_SIZE) {
     ec0:	293f      	cmp	r1, #63	; 0x3f
     ec2:	d809      	bhi.n	ed8 <uart0_status_isr+0xcc>
				n = tx_buffer[tail];
     ec4:	4b14      	ldr	r3, [pc, #80]	; (f18 <uart0_status_isr+0x10c>)
     ec6:	5c5b      	ldrb	r3, [r3, r1]
				n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
     ec8:	b2db      	uxtb	r3, r3
			UART0_D = n;
     eca:	b2db      	uxtb	r3, r3
			tx_buffer_tail = tail;
     ecc:	b2c9      	uxtb	r1, r1
			UART0_D = n;
     ece:	71d3      	strb	r3, [r2, #7]
			tx_buffer_tail = tail;
     ed0:	7001      	strb	r1, [r0, #0]
     ed2:	e7c6      	b.n	e62 <uart0_status_isr+0x56>
			if (++tail >= tx_buffer_total_size_) tail = 0;
     ed4:	2100      	movs	r1, #0
     ed6:	e7f5      	b.n	ec4 <uart0_status_isr+0xb8>
				n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
     ed8:	4d10      	ldr	r5, [pc, #64]	; (f1c <uart0_status_isr+0x110>)
     eda:	3b3f      	subs	r3, #63	; 0x3f
     edc:	682d      	ldr	r5, [r5, #0]
     ede:	18eb      	adds	r3, r5, r3
     ee0:	781b      	ldrb	r3, [r3, #0]
     ee2:	e7f1      	b.n	ec8 <uart0_status_isr+0xbc>
     ee4:	4006a000 	.word	0x4006a000
     ee8:	20000119 	.word	0x20000119
     eec:	1ffffda0 	.word	0x1ffffda0
     ef0:	20000120 	.word	0x20000120
     ef4:	200000d9 	.word	0x200000d9
     ef8:	20000169 	.word	0x20000169
     efc:	20000170 	.word	0x20000170
     f00:	20000128 	.word	0x20000128
     f04:	20000124 	.word	0x20000124
     f08:	20000121 	.word	0x20000121
     f0c:	200000d8 	.word	0x200000d8
     f10:	2000011c 	.word	0x2000011c
     f14:	1ffffda4 	.word	0x1ffffda4
     f18:	20000129 	.word	0x20000129
     f1c:	2000016c 	.word	0x2000016c

00000f20 <serial2_begin>:
#define GPIO_BITBAND_PTR(reg, bit) ((uint32_t *)GPIO_BITBAND_ADDR((reg), (bit)))
#define C3_TXDIR_BIT 5

void serial2_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART1;	// turn on clock, TODO: use bitband
     f20:	2380      	movs	r3, #128	; 0x80
     f22:	4a18      	ldr	r2, [pc, #96]	; (f84 <serial2_begin+0x64>)
     f24:	011b      	lsls	r3, r3, #4
     f26:	6811      	ldr	r1, [r2, #0]
     f28:	430b      	orrs	r3, r1
     f2a:	6013      	str	r3, [r2, #0]
	rx_buffer_head = 0;
     f2c:	2300      	movs	r3, #0
     f2e:	4a16      	ldr	r2, [pc, #88]	; (f88 <serial2_begin+0x68>)
     f30:	7013      	strb	r3, [r2, #0]
	rx_buffer_tail = 0;
     f32:	4a16      	ldr	r2, [pc, #88]	; (f8c <serial2_begin+0x6c>)
     f34:	7013      	strb	r3, [r2, #0]
	tx_buffer_head = 0;
     f36:	4a16      	ldr	r2, [pc, #88]	; (f90 <serial2_begin+0x70>)
     f38:	7013      	strb	r3, [r2, #0]
	tx_buffer_tail = 0;
     f3a:	4a16      	ldr	r2, [pc, #88]	; (f94 <serial2_begin+0x74>)
     f3c:	7013      	strb	r3, [r2, #0]
	transmitting = 0;
     f3e:	4a16      	ldr	r2, [pc, #88]	; (f98 <serial2_begin+0x78>)
     f40:	7013      	strb	r3, [r2, #0]
		#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)  // T3.5 or T3.6
		case 58: CORE_PIN58_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#elif defined(KINETISL)
	CORE_PIN9_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3);
     f42:	4b16      	ldr	r3, [pc, #88]	; (f9c <serial2_begin+0x7c>)
     f44:	4a16      	ldr	r2, [pc, #88]	; (fa0 <serial2_begin+0x80>)
     f46:	601a      	str	r2, [r3, #0]
	CORE_PIN10_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
     f48:	4b16      	ldr	r3, [pc, #88]	; (fa4 <serial2_begin+0x84>)
     f4a:	3231      	adds	r2, #49	; 0x31
     f4c:	601a      	str	r2, [r3, #0]
#else
	UART1_C1 = 0;
	UART1_PFIFO = 0;
#endif
#elif defined(HAS_KINETISL_UART1)
	if (divisor < 1) divisor = 1;
     f4e:	2800      	cmp	r0, #0
     f50:	d100      	bne.n	f54 <serial2_begin+0x34>
     f52:	3001      	adds	r0, #1
	UART1_BDH = (divisor >> 8) & 0x1F;
     f54:	4b14      	ldr	r3, [pc, #80]	; (fa8 <serial2_begin+0x88>)
     f56:	04c2      	lsls	r2, r0, #19
     f58:	0ed2      	lsrs	r2, r2, #27
     f5a:	701a      	strb	r2, [r3, #0]
	UART1_BDL = divisor & 0xFF;
	UART1_C1 = 0;
     f5c:	2200      	movs	r2, #0
	UART1_BDL = divisor & 0xFF;
     f5e:	b2c0      	uxtb	r0, r0
     f60:	7058      	strb	r0, [r3, #1]
#endif
	UART1_C2 = C2_TX_INACTIVE;
	NVIC_SET_PRIORITY(IRQ_UART1_STATUS, IRQ_PRIORITY);
     f62:	4912      	ldr	r1, [pc, #72]	; (fac <serial2_begin+0x8c>)
	UART1_C1 = 0;
     f64:	709a      	strb	r2, [r3, #2]
	UART1_C2 = C2_TX_INACTIVE;
     f66:	322c      	adds	r2, #44	; 0x2c
     f68:	70da      	strb	r2, [r3, #3]
	NVIC_SET_PRIORITY(IRQ_UART1_STATUS, IRQ_PRIORITY);
     f6a:	680a      	ldr	r2, [r1, #0]
     f6c:	4b10      	ldr	r3, [pc, #64]	; (fb0 <serial2_begin+0x90>)
     f6e:	401a      	ands	r2, r3
     f70:	2380      	movs	r3, #128	; 0x80
     f72:	01db      	lsls	r3, r3, #7
     f74:	4313      	orrs	r3, r2
	NVIC_ENABLE_IRQ(IRQ_UART1_STATUS);
     f76:	2280      	movs	r2, #128	; 0x80
	NVIC_SET_PRIORITY(IRQ_UART1_STATUS, IRQ_PRIORITY);
     f78:	600b      	str	r3, [r1, #0]
	NVIC_ENABLE_IRQ(IRQ_UART1_STATUS);
     f7a:	4b0e      	ldr	r3, [pc, #56]	; (fb4 <serial2_begin+0x94>)
     f7c:	0192      	lsls	r2, r2, #6
     f7e:	601a      	str	r2, [r3, #0]
}
     f80:	4770      	bx	lr
     f82:	46c0      	nop			; (mov r8, r8)
     f84:	40048034 	.word	0x40048034
     f88:	200001b8 	.word	0x200001b8
     f8c:	200001c0 	.word	0x200001c0
     f90:	200001f1 	.word	0x200001f1
     f94:	200001f8 	.word	0x200001f8
     f98:	200001c8 	.word	0x200001c8
     f9c:	4004b00c 	.word	0x4004b00c
     fa0:	00000313 	.word	0x00000313
     fa4:	4004b010 	.word	0x4004b010
     fa8:	4006b000 	.word	0x4006b000
     fac:	e000e40c 	.word	0xe000e40c
     fb0:	ffff00ff 	.word	0xffff00ff
     fb4:	e000e100 	.word	0xe000e100

00000fb8 <serial2_format>:
void serial2_format(uint32_t format)
{
	uint8_t c;

	c = UART1_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
     fb8:	2113      	movs	r1, #19
{
     fba:	b510      	push	{r4, lr}
	c = UART1_C1;
     fbc:	4b1b      	ldr	r3, [pc, #108]	; (102c <serial2_format+0x74>)
     fbe:	789a      	ldrb	r2, [r3, #2]
	c = (c & ~0x13) | (format & 0x03);	// configure parity
     fc0:	438a      	bics	r2, r1
     fc2:	3910      	subs	r1, #16
     fc4:	4001      	ands	r1, r0
     fc6:	430a      	orrs	r2, r1
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
     fc8:	0741      	lsls	r1, r0, #29
     fca:	d501      	bpl.n	fd0 <serial2_format+0x18>
     fcc:	2110      	movs	r1, #16
     fce:	430a      	orrs	r2, r1
	UART1_C1 = c;
     fd0:	709a      	strb	r2, [r3, #2]
	if ((format & 0x0F) == 0x04) UART1_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
     fd2:	220f      	movs	r2, #15
     fd4:	4002      	ands	r2, r0
     fd6:	2a04      	cmp	r2, #4
     fd8:	d103      	bne.n	fe2 <serial2_format+0x2a>
     fda:	7999      	ldrb	r1, [r3, #6]
     fdc:	323c      	adds	r2, #60	; 0x3c
     fde:	430a      	orrs	r2, r1
     fe0:	719a      	strb	r2, [r3, #6]
	c = UART1_S2 & ~0x10;
     fe2:	2110      	movs	r1, #16
     fe4:	795a      	ldrb	r2, [r3, #5]
     fe6:	438a      	bics	r2, r1
	if (format & 0x10) c |= 0x10;		// rx invert
     fe8:	4208      	tst	r0, r1
     fea:	d000      	beq.n	fee <serial2_format+0x36>
     fec:	430a      	orrs	r2, r1
	UART1_S2 = c;
	c = UART1_C3 & ~0x10;
     fee:	2110      	movs	r1, #16
	UART1_S2 = c;
     ff0:	715a      	strb	r2, [r3, #5]
	c = UART1_C3 & ~0x10;
     ff2:	799a      	ldrb	r2, [r3, #6]
     ff4:	438a      	bics	r2, r1
	if (format & 0x20) c |= 0x10;		// tx invert
     ff6:	0684      	lsls	r4, r0, #26
     ff8:	d500      	bpl.n	ffc <serial2_format+0x44>
     ffa:	430a      	orrs	r2, r1
	UART1_C3 = c;
     ffc:	719a      	strb	r2, [r3, #6]
	UART1_C4 = c;
	use9Bits = format & 0x80;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(KINETISL)
	// For T3.5/T3.6/TLC See about turning on 2 stop bit mode
	if ( format & 0x100) {
     ffe:	05c2      	lsls	r2, r0, #23
    1000:	d506      	bpl.n	1010 <serial2_format+0x58>
		uint8_t bdl = UART1_BDL;
		UART1_BDH |= UART_BDH_SBNS;		// Turn on 2 stop bits - was turned off by set baud
    1002:	2120      	movs	r1, #32
		uint8_t bdl = UART1_BDL;
    1004:	785a      	ldrb	r2, [r3, #1]
		UART1_BDH |= UART_BDH_SBNS;		// Turn on 2 stop bits - was turned off by set baud
    1006:	781c      	ldrb	r4, [r3, #0]
		uint8_t bdl = UART1_BDL;
    1008:	b2d2      	uxtb	r2, r2
		UART1_BDH |= UART_BDH_SBNS;		// Turn on 2 stop bits - was turned off by set baud
    100a:	4321      	orrs	r1, r4
    100c:	7019      	strb	r1, [r3, #0]
		UART1_BDL = bdl;		// Says BDH not acted on until BDL is written
    100e:	705a      	strb	r2, [r3, #1]
	}
#endif
	// process request for half duplex.
	if ((format & SERIAL_HALF_DUPLEX) != 0) {
    1010:	2200      	movs	r2, #0
    1012:	0580      	lsls	r0, r0, #22
    1014:	d507      	bpl.n	1026 <serial2_format+0x6e>
		c = UART1_C1;
		c |= UART_C1_LOOPS | UART_C1_RSRC;
    1016:	21a0      	movs	r1, #160	; 0xa0
		c = UART1_C1;
    1018:	789a      	ldrb	r2, [r3, #2]
		c |= UART_C1_LOOPS | UART_C1_RSRC;
    101a:	430a      	orrs	r2, r1
		UART1_C1 = c;
    101c:	709a      	strb	r2, [r3, #2]

		// Lets try to make use of bitband address to set the direction for ue...
		#if defined(KINETISL)
		//CORE_PIN10_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		CORE_PIN10_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3);
    101e:	4a04      	ldr	r2, [pc, #16]	; (1030 <serial2_format+0x78>)
    1020:	4b04      	ldr	r3, [pc, #16]	; (1034 <serial2_format+0x7c>)
    1022:	601a      	str	r2, [r3, #0]
		half_duplex_mode = 1;
    1024:	2201      	movs	r2, #1
    1026:	4b04      	ldr	r3, [pc, #16]	; (1038 <serial2_format+0x80>)
    1028:	701a      	strb	r2, [r3, #0]
		half_duplex_mode = 0;
		#else
		if (transmit_pin == (uint8_t*)GPIO_BITBAND_PTR(UART1_C3, C3_TXDIR_BIT)) transmit_pin = NULL;
		#endif
	}
}
    102a:	bd10      	pop	{r4, pc}
    102c:	4006b000 	.word	0x4006b000
    1030:	00000313 	.word	0x00000313
    1034:	4004b010 	.word	0x4004b010
    1038:	20000171 	.word	0x20000171

0000103c <serial2_end>:

void serial2_end(void)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART1)) return;
    103c:	4b13      	ldr	r3, [pc, #76]	; (108c <serial2_end+0x50>)
{
    103e:	b510      	push	{r4, lr}
	if (!(SIM_SCGC4 & SIM_SCGC4_UART1)) return;
    1040:	681b      	ldr	r3, [r3, #0]
    1042:	051b      	lsls	r3, r3, #20
    1044:	d402      	bmi.n	104c <serial2_end+0x10>
	UART1_S1;
	UART1_D; // clear leftover error status
	rx_buffer_head = 0;
	rx_buffer_tail = 0;
	if (rts_pin) rts_deassert();
}
    1046:	bd10      	pop	{r4, pc}
	while (transmitting) yield();  // wait for buffered data to send
    1048:	f001 f940 	bl	22cc <yield>
    104c:	4b10      	ldr	r3, [pc, #64]	; (1090 <serial2_end+0x54>)
    104e:	781a      	ldrb	r2, [r3, #0]
    1050:	b2d3      	uxtb	r3, r2
    1052:	2a00      	cmp	r2, #0
    1054:	d1f8      	bne.n	1048 <serial2_end+0xc>
	NVIC_DISABLE_IRQ(IRQ_UART1_STATUS);
    1056:	2180      	movs	r1, #128	; 0x80
    1058:	4a0e      	ldr	r2, [pc, #56]	; (1094 <serial2_end+0x58>)
    105a:	0189      	lsls	r1, r1, #6
    105c:	6011      	str	r1, [r2, #0]
	CORE_PIN9_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1);  // PTC3
    105e:	2104      	movs	r1, #4
	UART1_C2 = 0;
    1060:	4a0d      	ldr	r2, [pc, #52]	; (1098 <serial2_end+0x5c>)
	CORE_PIN9_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1);  // PTC3
    1062:	480e      	ldr	r0, [pc, #56]	; (109c <serial2_end+0x60>)
    1064:	31ff      	adds	r1, #255	; 0xff
	UART1_C2 = 0;
    1066:	70d3      	strb	r3, [r2, #3]
	CORE_PIN9_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1);  // PTC3
    1068:	6001      	str	r1, [r0, #0]
	CORE_PIN10_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); // PTC4
    106a:	480d      	ldr	r0, [pc, #52]	; (10a0 <serial2_end+0x64>)
    106c:	6001      	str	r1, [r0, #0]
	UART1_S1;
    106e:	7911      	ldrb	r1, [r2, #4]
	UART1_D; // clear leftover error status
    1070:	79d2      	ldrb	r2, [r2, #7]
	rx_buffer_head = 0;
    1072:	4a0c      	ldr	r2, [pc, #48]	; (10a4 <serial2_end+0x68>)
    1074:	7013      	strb	r3, [r2, #0]
	rx_buffer_tail = 0;
    1076:	4a0c      	ldr	r2, [pc, #48]	; (10a8 <serial2_end+0x6c>)
    1078:	7013      	strb	r3, [r2, #0]
	if (rts_pin) rts_deassert();
    107a:	4b0c      	ldr	r3, [pc, #48]	; (10ac <serial2_end+0x70>)
    107c:	681b      	ldr	r3, [r3, #0]
    107e:	2b00      	cmp	r3, #0
    1080:	d0e1      	beq.n	1046 <serial2_end+0xa>
    1082:	4a0b      	ldr	r2, [pc, #44]	; (10b0 <serial2_end+0x74>)
    1084:	7812      	ldrb	r2, [r2, #0]
    1086:	711a      	strb	r2, [r3, #4]
    1088:	e7dd      	b.n	1046 <serial2_end+0xa>
    108a:	46c0      	nop			; (mov r8, r8)
    108c:	40048034 	.word	0x40048034
    1090:	200001c8 	.word	0x200001c8
    1094:	e000e180 	.word	0xe000e180
    1098:	4006b000 	.word	0x4006b000
    109c:	4004b00c 	.word	0x4004b00c
    10a0:	4004b010 	.word	0x4004b010
    10a4:	200001b8 	.word	0x200001b8
    10a8:	200001c0 	.word	0x200001c0
    10ac:	20000174 	.word	0x20000174
    10b0:	20000172 	.word	0x20000172

000010b4 <serial2_set_transmit_pin>:

void serial2_set_transmit_pin(uint8_t pin)
{
    10b4:	b570      	push	{r4, r5, r6, lr}
    10b6:	0004      	movs	r4, r0
	while (transmitting) ;
    10b8:	4a0b      	ldr	r2, [pc, #44]	; (10e8 <serial2_set_transmit_pin+0x34>)
    10ba:	7813      	ldrb	r3, [r2, #0]
    10bc:	b2dd      	uxtb	r5, r3
    10be:	2b00      	cmp	r3, #0
    10c0:	d1fb      	bne.n	10ba <serial2_set_transmit_pin+0x6>
	pinMode(pin, OUTPUT);
    10c2:	0020      	movs	r0, r4
    10c4:	2101      	movs	r1, #1
    10c6:	f7ff fdf3 	bl	cb0 <pinMode>
	digitalWrite(pin, LOW);
    10ca:	0029      	movs	r1, r5
    10cc:	0020      	movs	r0, r4
    10ce:	f7ff fdcd 	bl	c6c <digitalWrite>
	transmit_pin = portOutputRegister(pin);
    10d2:	220c      	movs	r2, #12
    10d4:	4362      	muls	r2, r4
    10d6:	4b05      	ldr	r3, [pc, #20]	; (10ec <serial2_set_transmit_pin+0x38>)
    10d8:	4905      	ldr	r1, [pc, #20]	; (10f0 <serial2_set_transmit_pin+0x3c>)
    10da:	58d0      	ldr	r0, [r2, r3]
	#if defined(KINETISL)
	transmit_mask = digitalPinToBitMask(pin);
    10dc:	189b      	adds	r3, r3, r2
	transmit_pin = portOutputRegister(pin);
    10de:	6008      	str	r0, [r1, #0]
	transmit_mask = digitalPinToBitMask(pin);
    10e0:	7a1b      	ldrb	r3, [r3, #8]
    10e2:	4904      	ldr	r1, [pc, #16]	; (10f4 <serial2_set_transmit_pin+0x40>)
    10e4:	700b      	strb	r3, [r1, #0]
	#endif
}
    10e6:	bd70      	pop	{r4, r5, r6, pc}
    10e8:	200001c8 	.word	0x200001c8
    10ec:	00002950 	.word	0x00002950
    10f0:	200001c4 	.word	0x200001c4
    10f4:	200001c1 	.word	0x200001c1

000010f8 <serial2_set_tx>:
			#endif
		}
	}
	tx_pin_num = pin;
	#endif
}
    10f8:	4770      	bx	lr

000010fa <serial2_set_rx>:
			#endif
		}
	}
	rx_pin_num = pin;
	#endif
}
    10fa:	4770      	bx	lr

000010fc <serial2_set_rts>:

int serial2_set_rts(uint8_t pin)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART1)) return 0;
    10fc:	4b10      	ldr	r3, [pc, #64]	; (1140 <serial2_set_rts+0x44>)
    10fe:	2280      	movs	r2, #128	; 0x80
    1100:	6819      	ldr	r1, [r3, #0]
    1102:	0112      	lsls	r2, r2, #4
    1104:	000b      	movs	r3, r1
{
    1106:	b570      	push	{r4, r5, r6, lr}
	if (!(SIM_SCGC4 & SIM_SCGC4_UART1)) return 0;
    1108:	4013      	ands	r3, r2
    110a:	4211      	tst	r1, r2
    110c:	d012      	beq.n	1134 <serial2_set_rts+0x38>
	if (pin < CORE_NUM_DIGITAL) {
    110e:	4c0d      	ldr	r4, [pc, #52]	; (1144 <serial2_set_rts+0x48>)
    1110:	281a      	cmp	r0, #26
    1112:	d811      	bhi.n	1138 <serial2_set_rts+0x3c>
		rts_pin = portOutputRegister(pin);
    1114:	220c      	movs	r2, #12
    1116:	4342      	muls	r2, r0
    1118:	4b0b      	ldr	r3, [pc, #44]	; (1148 <serial2_set_rts+0x4c>)
		#if defined(KINETISL)
		rts_mask = digitalPinToBitMask(pin);
    111a:	4d0c      	ldr	r5, [pc, #48]	; (114c <serial2_set_rts+0x50>)
		rts_pin = portOutputRegister(pin);
    111c:	58d1      	ldr	r1, [r2, r3]
		rts_mask = digitalPinToBitMask(pin);
    111e:	189b      	adds	r3, r3, r2
    1120:	7a1b      	ldrb	r3, [r3, #8]
		rts_pin = portOutputRegister(pin);
    1122:	6021      	str	r1, [r4, #0]
		#endif
		pinMode(pin, OUTPUT);
    1124:	2101      	movs	r1, #1
		rts_mask = digitalPinToBitMask(pin);
    1126:	702b      	strb	r3, [r5, #0]
		pinMode(pin, OUTPUT);
    1128:	f7ff fdc2 	bl	cb0 <pinMode>
		rts_assert();
    112c:	6823      	ldr	r3, [r4, #0]
    112e:	782a      	ldrb	r2, [r5, #0]
    1130:	721a      	strb	r2, [r3, #8]
		UART1_MODEM &= ~UART_MODEM_RXRTSE;
		return 0;
	}
	UART1_MODEM |= UART_MODEM_RXRTSE;
*/
	return 1;
    1132:	2301      	movs	r3, #1
}
    1134:	0018      	movs	r0, r3
    1136:	bd70      	pop	{r4, r5, r6, pc}
		rts_pin = NULL;
    1138:	2300      	movs	r3, #0
    113a:	6023      	str	r3, [r4, #0]
		return 0;
    113c:	e7fa      	b.n	1134 <serial2_set_rts+0x38>
    113e:	46c0      	nop			; (mov r8, r8)
    1140:	40048034 	.word	0x40048034
    1144:	20000174 	.word	0x20000174
    1148:	00002950 	.word	0x00002950
    114c:	20000172 	.word	0x20000172

00001150 <serial2_set_cts>:
	UART1_MODEM |= UART_MODEM_TXCTSE;
	return 1;
#else
	return 0;
#endif
}
    1150:	2000      	movs	r0, #0
    1152:	4770      	bx	lr

00001154 <serial2_putchar>:

void serial2_putchar(uint32_t c)
{
    1154:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART1)) return;
    1156:	4b33      	ldr	r3, [pc, #204]	; (1224 <serial2_putchar+0xd0>)
{
    1158:	b085      	sub	sp, #20
	if (!(SIM_SCGC4 & SIM_SCGC4_UART1)) return;
    115a:	681b      	ldr	r3, [r3, #0]
{
    115c:	9001      	str	r0, [sp, #4]
	if (!(SIM_SCGC4 & SIM_SCGC4_UART1)) return;
    115e:	051b      	lsls	r3, r3, #20
    1160:	d531      	bpl.n	11c6 <serial2_putchar+0x72>
	if (transmit_pin) transmit_assert();
    1162:	4b31      	ldr	r3, [pc, #196]	; (1228 <serial2_putchar+0xd4>)
    1164:	681b      	ldr	r3, [r3, #0]
    1166:	2b00      	cmp	r3, #0
    1168:	d002      	beq.n	1170 <serial2_putchar+0x1c>
    116a:	4a30      	ldr	r2, [pc, #192]	; (122c <serial2_putchar+0xd8>)
    116c:	7812      	ldrb	r2, [r2, #0]
    116e:	711a      	strb	r2, [r3, #4]
	#if defined(KINETISL)
	if (half_duplex_mode) {
    1170:	4b2f      	ldr	r3, [pc, #188]	; (1230 <serial2_putchar+0xdc>)
    1172:	781b      	ldrb	r3, [r3, #0]
    1174:	2b00      	cmp	r3, #0
    1176:	d00c      	beq.n	1192 <serial2_putchar+0x3e>
		__disable_irq();
    1178:	b672      	cpsid	i
		volatile uint32_t reg = UART1_C3;
    117a:	4a2e      	ldr	r2, [pc, #184]	; (1234 <serial2_putchar+0xe0>)
    117c:	7993      	ldrb	r3, [r2, #6]
    117e:	b2db      	uxtb	r3, r3
    1180:	9303      	str	r3, [sp, #12]
		reg |= UART_C3_TXDIR;
    1182:	2320      	movs	r3, #32
    1184:	9903      	ldr	r1, [sp, #12]
    1186:	430b      	orrs	r3, r1
    1188:	9303      	str	r3, [sp, #12]
		UART1_C3 = reg;
    118a:	9b03      	ldr	r3, [sp, #12]
    118c:	b2db      	uxtb	r3, r3
    118e:	7193      	strb	r3, [r2, #6]
		__enable_irq();
    1190:	b662      	cpsie	i
	}
	#endif 
	head = tx_buffer_head;
    1192:	4e29      	ldr	r6, [pc, #164]	; (1238 <serial2_putchar+0xe4>)
	if (++head >= tx_buffer_total_size_) head = 0;
    1194:	4f29      	ldr	r7, [pc, #164]	; (123c <serial2_putchar+0xe8>)
	head = tx_buffer_head;
    1196:	7834      	ldrb	r4, [r6, #0]
	if (++head >= tx_buffer_total_size_) head = 0;
    1198:	683b      	ldr	r3, [r7, #0]
    119a:	3401      	adds	r4, #1
    119c:	429c      	cmp	r4, r3
    119e:	419b      	sbcs	r3, r3
    11a0:	401c      	ands	r4, r3
	while (tx_buffer_tail == head) {
    11a2:	4d27      	ldr	r5, [pc, #156]	; (1240 <serial2_putchar+0xec>)
    11a4:	782b      	ldrb	r3, [r5, #0]
    11a6:	42a3      	cmp	r3, r4
    11a8:	d00f      	beq.n	11ca <serial2_putchar+0x76>
		} else if (priority >= 256) {
			yield(); // wait
		}
	}
	if (head < SERIAL2_TX_BUFFER_SIZE) {
		tx_buffer[head] = c;
    11aa:	466b      	mov	r3, sp
    11ac:	791b      	ldrb	r3, [r3, #4]
	if (head < SERIAL2_TX_BUFFER_SIZE) {
    11ae:	2c27      	cmp	r4, #39	; 0x27
    11b0:	d831      	bhi.n	1216 <serial2_putchar+0xc2>
		tx_buffer[head] = c;
    11b2:	4a24      	ldr	r2, [pc, #144]	; (1244 <serial2_putchar+0xf0>)
    11b4:	5513      	strb	r3, [r2, r4]
	} else {
		tx_buffer_storage_[head - SERIAL2_TX_BUFFER_SIZE] = c;
	}
	transmitting = 1;
    11b6:	2201      	movs	r2, #1
    11b8:	4b23      	ldr	r3, [pc, #140]	; (1248 <serial2_putchar+0xf4>)
	tx_buffer_head = head;
    11ba:	b2e4      	uxtb	r4, r4
	transmitting = 1;
    11bc:	701a      	strb	r2, [r3, #0]
	UART1_C2 = C2_TX_ACTIVE;
    11be:	4b1d      	ldr	r3, [pc, #116]	; (1234 <serial2_putchar+0xe0>)
    11c0:	32ab      	adds	r2, #171	; 0xab
	tx_buffer_head = head;
    11c2:	7034      	strb	r4, [r6, #0]
	UART1_C2 = C2_TX_ACTIVE;
    11c4:	70da      	strb	r2, [r3, #3]
}
    11c6:	b005      	add	sp, #20
    11c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		int priority = nvic_execution_priority();
    11ca:	f7ff fc23 	bl	a14 <nvic_execution_priority>
		if (priority <= IRQ_PRIORITY) {
    11ce:	2840      	cmp	r0, #64	; 0x40
    11d0:	dc1c      	bgt.n	120c <serial2_putchar+0xb8>
			if ((UART1_S1 & UART_S1_TDRE)) {
    11d2:	4918      	ldr	r1, [pc, #96]	; (1234 <serial2_putchar+0xe0>)
    11d4:	790b      	ldrb	r3, [r1, #4]
    11d6:	b25b      	sxtb	r3, r3
    11d8:	2b00      	cmp	r3, #0
    11da:	dae2      	bge.n	11a2 <serial2_putchar+0x4e>
				uint32_t tail = tx_buffer_tail;
    11dc:	782b      	ldrb	r3, [r5, #0]
				if (++tail >= tx_buffer_total_size_) tail = 0;
    11de:	683a      	ldr	r2, [r7, #0]
				uint32_t tail = tx_buffer_tail;
    11e0:	b2d8      	uxtb	r0, r3
				if (++tail >= tx_buffer_total_size_) tail = 0;
    11e2:	3301      	adds	r3, #1
    11e4:	4293      	cmp	r3, r2
    11e6:	d209      	bcs.n	11fc <serial2_putchar+0xa8>
				if (tail < SERIAL2_TX_BUFFER_SIZE) {
    11e8:	2b27      	cmp	r3, #39	; 0x27
    11ea:	d809      	bhi.n	1200 <serial2_putchar+0xac>
					n = tx_buffer[tail];
    11ec:	4a15      	ldr	r2, [pc, #84]	; (1244 <serial2_putchar+0xf0>)
    11ee:	5cd2      	ldrb	r2, [r2, r3]
					n = tx_buffer_storage_[tail-SERIAL2_TX_BUFFER_SIZE];
    11f0:	b2d2      	uxtb	r2, r2
				UART1_D = n;
    11f2:	b2d2      	uxtb	r2, r2
				tx_buffer_tail = tail;
    11f4:	b2db      	uxtb	r3, r3
				UART1_D = n;
    11f6:	71ca      	strb	r2, [r1, #7]
				tx_buffer_tail = tail;
    11f8:	702b      	strb	r3, [r5, #0]
    11fa:	e7d2      	b.n	11a2 <serial2_putchar+0x4e>
				if (++tail >= tx_buffer_total_size_) tail = 0;
    11fc:	2300      	movs	r3, #0
    11fe:	e7f5      	b.n	11ec <serial2_putchar+0x98>
					n = tx_buffer_storage_[tail-SERIAL2_TX_BUFFER_SIZE];
    1200:	4a12      	ldr	r2, [pc, #72]	; (124c <serial2_putchar+0xf8>)
    1202:	3827      	subs	r0, #39	; 0x27
    1204:	6812      	ldr	r2, [r2, #0]
    1206:	1812      	adds	r2, r2, r0
    1208:	7812      	ldrb	r2, [r2, #0]
    120a:	e7f1      	b.n	11f0 <serial2_putchar+0x9c>
		} else if (priority >= 256) {
    120c:	28ff      	cmp	r0, #255	; 0xff
    120e:	ddc8      	ble.n	11a2 <serial2_putchar+0x4e>
			yield(); // wait
    1210:	f001 f85c 	bl	22cc <yield>
    1214:	e7c5      	b.n	11a2 <serial2_putchar+0x4e>
		tx_buffer_storage_[head - SERIAL2_TX_BUFFER_SIZE] = c;
    1216:	0021      	movs	r1, r4
    1218:	4a0c      	ldr	r2, [pc, #48]	; (124c <serial2_putchar+0xf8>)
    121a:	3928      	subs	r1, #40	; 0x28
    121c:	6812      	ldr	r2, [r2, #0]
    121e:	1852      	adds	r2, r2, r1
    1220:	7013      	strb	r3, [r2, #0]
    1222:	e7c8      	b.n	11b6 <serial2_putchar+0x62>
    1224:	40048034 	.word	0x40048034
    1228:	200001c4 	.word	0x200001c4
    122c:	200001c1 	.word	0x200001c1
    1230:	20000171 	.word	0x20000171
    1234:	4006b000 	.word	0x4006b000
    1238:	200001f1 	.word	0x200001f1
    123c:	1ffffdb0 	.word	0x1ffffdb0
    1240:	200001f8 	.word	0x200001f8
    1244:	200001c9 	.word	0x200001c9
    1248:	200001c8 	.word	0x200001c8
    124c:	200001f4 	.word	0x200001f4

00001250 <serial2_write>:
	}
	UART1_C2 = C2_TX_ACTIVE;
}
#else
void serial2_write(const void *buf, unsigned int count)
{
    1250:	b570      	push	{r4, r5, r6, lr}
    1252:	0004      	movs	r4, r0
    1254:	1845      	adds	r5, r0, r1
	const uint8_t *p = (const uint8_t *)buf;
	while (count-- > 0) serial2_putchar(*p++);
    1256:	42ac      	cmp	r4, r5
    1258:	d100      	bne.n	125c <serial2_write+0xc>
}
    125a:	bd70      	pop	{r4, r5, r6, pc}
	while (count-- > 0) serial2_putchar(*p++);
    125c:	7820      	ldrb	r0, [r4, #0]
    125e:	f7ff ff79 	bl	1154 <serial2_putchar>
    1262:	3401      	adds	r4, #1
    1264:	e7f7      	b.n	1256 <serial2_write+0x6>
    1266:	Address 0x00001266 is out of bounds.


00001268 <serial2_flush>:
#endif

void serial2_flush(void)
{
    1268:	b510      	push	{r4, lr}
	while (transmitting) yield(); // wait
    126a:	4b04      	ldr	r3, [pc, #16]	; (127c <serial2_flush+0x14>)
    126c:	781b      	ldrb	r3, [r3, #0]
    126e:	2b00      	cmp	r3, #0
    1270:	d100      	bne.n	1274 <serial2_flush+0xc>
}
    1272:	bd10      	pop	{r4, pc}
	while (transmitting) yield(); // wait
    1274:	f001 f82a 	bl	22cc <yield>
    1278:	e7f7      	b.n	126a <serial2_flush+0x2>
    127a:	46c0      	nop			; (mov r8, r8)
    127c:	200001c8 	.word	0x200001c8

00001280 <serial2_write_buffer_free>:

int serial2_write_buffer_free(void)
{
	uint32_t head, tail;

	head = tx_buffer_head;
    1280:	4b08      	ldr	r3, [pc, #32]	; (12a4 <serial2_write_buffer_free+0x24>)
    1282:	7819      	ldrb	r1, [r3, #0]
	tail = tx_buffer_tail;
    1284:	4b08      	ldr	r3, [pc, #32]	; (12a8 <serial2_write_buffer_free+0x28>)
	head = tx_buffer_head;
    1286:	b2c8      	uxtb	r0, r1
	tail = tx_buffer_tail;
    1288:	781b      	ldrb	r3, [r3, #0]
    128a:	b2da      	uxtb	r2, r3
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    128c:	4299      	cmp	r1, r3
    128e:	d305      	bcc.n	129c <serial2_write_buffer_free+0x1c>
    1290:	4b06      	ldr	r3, [pc, #24]	; (12ac <serial2_write_buffer_free+0x2c>)
    1292:	681b      	ldr	r3, [r3, #0]
    1294:	3b01      	subs	r3, #1
    1296:	189b      	adds	r3, r3, r2
    1298:	1a18      	subs	r0, r3, r0
	return tail - head - 1;
}
    129a:	4770      	bx	lr
	return tail - head - 1;
    129c:	3a01      	subs	r2, #1
    129e:	1a10      	subs	r0, r2, r0
    12a0:	e7fb      	b.n	129a <serial2_write_buffer_free+0x1a>
    12a2:	46c0      	nop			; (mov r8, r8)
    12a4:	200001f1 	.word	0x200001f1
    12a8:	200001f8 	.word	0x200001f8
    12ac:	1ffffdb0 	.word	0x1ffffdb0

000012b0 <serial2_available>:

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    12b0:	4b06      	ldr	r3, [pc, #24]	; (12cc <serial2_available+0x1c>)
	tail = rx_buffer_tail;
    12b2:	4a07      	ldr	r2, [pc, #28]	; (12d0 <serial2_available+0x20>)
	head = rx_buffer_head;
    12b4:	7819      	ldrb	r1, [r3, #0]
	tail = rx_buffer_tail;
    12b6:	7812      	ldrb	r2, [r2, #0]
	head = rx_buffer_head;
    12b8:	b2cb      	uxtb	r3, r1
	tail = rx_buffer_tail;
    12ba:	b2d0      	uxtb	r0, r2
	if (head >= tail) return head - tail;
    12bc:	4291      	cmp	r1, r2
    12be:	d301      	bcc.n	12c4 <serial2_available+0x14>
	return rx_buffer_total_size_ + head - tail;
    12c0:	1a18      	subs	r0, r3, r0
}
    12c2:	4770      	bx	lr
	return rx_buffer_total_size_ + head - tail;
    12c4:	4a03      	ldr	r2, [pc, #12]	; (12d4 <serial2_available+0x24>)
    12c6:	6812      	ldr	r2, [r2, #0]
    12c8:	189b      	adds	r3, r3, r2
    12ca:	e7f9      	b.n	12c0 <serial2_available+0x10>
    12cc:	200001b8 	.word	0x200001b8
    12d0:	200001c0 	.word	0x200001c0
    12d4:	1ffffdac 	.word	0x1ffffdac

000012d8 <serial2_getchar>:

int serial2_getchar(void)
{
    12d8:	b530      	push	{r4, r5, lr}
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
    12da:	4b18      	ldr	r3, [pc, #96]	; (133c <serial2_getchar+0x64>)
	tail = rx_buffer_tail;
    12dc:	4d18      	ldr	r5, [pc, #96]	; (1340 <serial2_getchar+0x68>)
	head = rx_buffer_head;
    12de:	781a      	ldrb	r2, [r3, #0]
	tail = rx_buffer_tail;
    12e0:	782b      	ldrb	r3, [r5, #0]
	head = rx_buffer_head;
    12e2:	b2d4      	uxtb	r4, r2
	tail = rx_buffer_tail;
    12e4:	b2d9      	uxtb	r1, r3
	if (head == tail) return -1;
    12e6:	429a      	cmp	r2, r3
    12e8:	d025      	beq.n	1336 <serial2_getchar+0x5e>
	if (++tail >= rx_buffer_total_size_) tail = 0;
    12ea:	4a16      	ldr	r2, [pc, #88]	; (1344 <serial2_getchar+0x6c>)
    12ec:	1c4b      	adds	r3, r1, #1
    12ee:	6812      	ldr	r2, [r2, #0]
    12f0:	429a      	cmp	r2, r3
    12f2:	d915      	bls.n	1320 <serial2_getchar+0x48>
	if (tail < SERIAL2_RX_BUFFER_SIZE) {
    12f4:	2b3f      	cmp	r3, #63	; 0x3f
    12f6:	d815      	bhi.n	1324 <serial2_getchar+0x4c>
		c = rx_buffer[tail];
    12f8:	4913      	ldr	r1, [pc, #76]	; (1348 <serial2_getchar+0x70>)
    12fa:	5cc8      	ldrb	r0, [r1, r3]
	} else {
		c = rx_buffer_storage_[tail-SERIAL2_RX_BUFFER_SIZE];
	}
	rx_buffer_tail = tail;
    12fc:	b2d9      	uxtb	r1, r3
    12fe:	7029      	strb	r1, [r5, #0]
	if (rts_pin) {
    1300:	4912      	ldr	r1, [pc, #72]	; (134c <serial2_getchar+0x74>)
		c = rx_buffer_storage_[tail-SERIAL2_RX_BUFFER_SIZE];
    1302:	b2c0      	uxtb	r0, r0
	if (rts_pin) {
    1304:	6809      	ldr	r1, [r1, #0]
    1306:	2900      	cmp	r1, #0
    1308:	d009      	beq.n	131e <serial2_getchar+0x46>
		int avail;
		if (head >= tail) avail = head - tail;
    130a:	429c      	cmp	r4, r3
    130c:	d310      	bcc.n	1330 <serial2_getchar+0x58>
    130e:	1ae3      	subs	r3, r4, r3
		else avail = rx_buffer_total_size_ + head - tail;
		if (avail <= rts_low_watermark_) rts_assert();
    1310:	4a0f      	ldr	r2, [pc, #60]	; (1350 <serial2_getchar+0x78>)
    1312:	6812      	ldr	r2, [r2, #0]
    1314:	4293      	cmp	r3, r2
    1316:	d802      	bhi.n	131e <serial2_getchar+0x46>
    1318:	4b0e      	ldr	r3, [pc, #56]	; (1354 <serial2_getchar+0x7c>)
    131a:	781b      	ldrb	r3, [r3, #0]
    131c:	720b      	strb	r3, [r1, #8]
	}
	return c;
}
    131e:	bd30      	pop	{r4, r5, pc}
	if (++tail >= rx_buffer_total_size_) tail = 0;
    1320:	2300      	movs	r3, #0
    1322:	e7e9      	b.n	12f8 <serial2_getchar+0x20>
		c = rx_buffer_storage_[tail-SERIAL2_RX_BUFFER_SIZE];
    1324:	480c      	ldr	r0, [pc, #48]	; (1358 <serial2_getchar+0x80>)
    1326:	393f      	subs	r1, #63	; 0x3f
    1328:	6800      	ldr	r0, [r0, #0]
    132a:	1841      	adds	r1, r0, r1
    132c:	7808      	ldrb	r0, [r1, #0]
    132e:	e7e5      	b.n	12fc <serial2_getchar+0x24>
		else avail = rx_buffer_total_size_ + head - tail;
    1330:	1912      	adds	r2, r2, r4
    1332:	1ad3      	subs	r3, r2, r3
    1334:	e7ec      	b.n	1310 <serial2_getchar+0x38>
	if (head == tail) return -1;
    1336:	2001      	movs	r0, #1
    1338:	4240      	negs	r0, r0
    133a:	e7f0      	b.n	131e <serial2_getchar+0x46>
    133c:	200001b8 	.word	0x200001b8
    1340:	200001c0 	.word	0x200001c0
    1344:	1ffffdac 	.word	0x1ffffdac
    1348:	20000178 	.word	0x20000178
    134c:	20000174 	.word	0x20000174
    1350:	1ffffda8 	.word	0x1ffffda8
    1354:	20000172 	.word	0x20000172
    1358:	200001bc 	.word	0x200001bc

0000135c <serial2_peek>:

int serial2_peek(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    135c:	4b0e      	ldr	r3, [pc, #56]	; (1398 <serial2_peek+0x3c>)
    135e:	7819      	ldrb	r1, [r3, #0]
	tail = rx_buffer_tail;
    1360:	4b0e      	ldr	r3, [pc, #56]	; (139c <serial2_peek+0x40>)
    1362:	781a      	ldrb	r2, [r3, #0]
    1364:	b2d3      	uxtb	r3, r2
	if (head == tail) return -1;
    1366:	4291      	cmp	r1, r2
    1368:	d012      	beq.n	1390 <serial2_peek+0x34>
	if (++tail >= rx_buffer_total_size_) tail = 0;
    136a:	490d      	ldr	r1, [pc, #52]	; (13a0 <serial2_peek+0x44>)
    136c:	1c5a      	adds	r2, r3, #1
    136e:	6809      	ldr	r1, [r1, #0]
    1370:	4291      	cmp	r1, r2
    1372:	d905      	bls.n	1380 <serial2_peek+0x24>
	if (tail < SERIAL2_RX_BUFFER_SIZE) {
    1374:	2a3f      	cmp	r2, #63	; 0x3f
    1376:	d805      	bhi.n	1384 <serial2_peek+0x28>
		return rx_buffer[tail];
    1378:	4b0a      	ldr	r3, [pc, #40]	; (13a4 <serial2_peek+0x48>)
    137a:	5c98      	ldrb	r0, [r3, r2]
	}
	return rx_buffer_storage_[tail-SERIAL2_RX_BUFFER_SIZE];
    137c:	b2c0      	uxtb	r0, r0
}
    137e:	4770      	bx	lr
	if (++tail >= rx_buffer_total_size_) tail = 0;
    1380:	2200      	movs	r2, #0
    1382:	e7f9      	b.n	1378 <serial2_peek+0x1c>
	return rx_buffer_storage_[tail-SERIAL2_RX_BUFFER_SIZE];
    1384:	4a08      	ldr	r2, [pc, #32]	; (13a8 <serial2_peek+0x4c>)
    1386:	3b3f      	subs	r3, #63	; 0x3f
    1388:	6812      	ldr	r2, [r2, #0]
    138a:	18d3      	adds	r3, r2, r3
    138c:	7818      	ldrb	r0, [r3, #0]
    138e:	e7f5      	b.n	137c <serial2_peek+0x20>
	if (head == tail) return -1;
    1390:	2001      	movs	r0, #1
    1392:	4240      	negs	r0, r0
    1394:	e7f3      	b.n	137e <serial2_peek+0x22>
    1396:	46c0      	nop			; (mov r8, r8)
    1398:	200001b8 	.word	0x200001b8
    139c:	200001c0 	.word	0x200001c0
    13a0:	1ffffdac 	.word	0x1ffffdac
    13a4:	20000178 	.word	0x20000178
    13a8:	200001bc 	.word	0x200001bc

000013ac <serial2_clear>:
	if (!(SIM_SCGC4 & SIM_SCGC4_UART1)) return;
	UART1_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
	UART1_CFIFO = UART_CFIFO_RXFLUSH;
	UART1_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
    13ac:	4b06      	ldr	r3, [pc, #24]	; (13c8 <serial2_clear+0x1c>)
    13ae:	4a07      	ldr	r2, [pc, #28]	; (13cc <serial2_clear+0x20>)
    13b0:	781b      	ldrb	r3, [r3, #0]
    13b2:	b2db      	uxtb	r3, r3
    13b4:	7013      	strb	r3, [r2, #0]
	if (rts_pin) rts_assert();
    13b6:	4b06      	ldr	r3, [pc, #24]	; (13d0 <serial2_clear+0x24>)
    13b8:	681b      	ldr	r3, [r3, #0]
    13ba:	2b00      	cmp	r3, #0
    13bc:	d002      	beq.n	13c4 <serial2_clear+0x18>
    13be:	4a05      	ldr	r2, [pc, #20]	; (13d4 <serial2_clear+0x28>)
    13c0:	7812      	ldrb	r2, [r2, #0]
    13c2:	721a      	strb	r2, [r3, #8]
}
    13c4:	4770      	bx	lr
    13c6:	46c0      	nop			; (mov r8, r8)
    13c8:	200001c0 	.word	0x200001c0
    13cc:	200001b8 	.word	0x200001b8
    13d0:	20000174 	.word	0x20000174
    13d4:	20000172 	.word	0x20000172

000013d8 <uart1_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart1_status_isr(void)
{
    13d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
		} while (UART1_TCFIFO < 8);
		tx_buffer_tail = tail;
		if (UART1_S1 & UART_S1_TDRE) UART1_C2 = C2_TX_COMPLETING;
	}
#else
	if (UART1_S1 & UART_S1_RDRF) {
    13da:	4a35      	ldr	r2, [pc, #212]	; (14b0 <uart1_status_isr+0xd8>)
    13dc:	7913      	ldrb	r3, [r2, #4]
    13de:	069b      	lsls	r3, r3, #26
    13e0:	d513      	bpl.n	140a <uart1_status_isr+0x32>
		if (use9Bits && (UART1_C3 & 0x80)) {
			n = UART1_D | 0x100;
		} else {
			n = UART1_D;
		}
		head = rx_buffer_head + 1;
    13e2:	4d34      	ldr	r5, [pc, #208]	; (14b4 <uart1_status_isr+0xdc>)
		if (head >= rx_buffer_total_size_) head = 0;
    13e4:	4834      	ldr	r0, [pc, #208]	; (14b8 <uart1_status_isr+0xe0>)
			n = UART1_D;
    13e6:	79d1      	ldrb	r1, [r2, #7]
		head = rx_buffer_head + 1;
    13e8:	782b      	ldrb	r3, [r5, #0]
		if (head >= rx_buffer_total_size_) head = 0;
    13ea:	6800      	ldr	r0, [r0, #0]
		head = rx_buffer_head + 1;
    13ec:	3301      	adds	r3, #1
		if (head >= rx_buffer_total_size_) head = 0;
    13ee:	4283      	cmp	r3, r0
    13f0:	4180      	sbcs	r0, r0
    13f2:	4003      	ands	r3, r0
		if (head != rx_buffer_tail) {
    13f4:	4831      	ldr	r0, [pc, #196]	; (14bc <uart1_status_isr+0xe4>)
			n = UART1_D;
    13f6:	b2c9      	uxtb	r1, r1
		if (head != rx_buffer_tail) {
    13f8:	7800      	ldrb	r0, [r0, #0]
    13fa:	4298      	cmp	r0, r3
    13fc:	d005      	beq.n	140a <uart1_status_isr+0x32>
			if (head < SERIAL2_RX_BUFFER_SIZE) {
    13fe:	2b3f      	cmp	r3, #63	; 0x3f
    1400:	d838      	bhi.n	1474 <uart1_status_isr+0x9c>
				rx_buffer[head] = n;
    1402:	482f      	ldr	r0, [pc, #188]	; (14c0 <uart1_status_isr+0xe8>)
    1404:	54c1      	strb	r1, [r0, r3]
			} else {
				rx_buffer_storage_[head-SERIAL2_RX_BUFFER_SIZE] = n;
			}

			rx_buffer_head = head;
    1406:	b2db      	uxtb	r3, r3
    1408:	702b      	strb	r3, [r5, #0]
		}
	}
	c = UART1_C2;
    140a:	78d3      	ldrb	r3, [r2, #3]
    140c:	b2dc      	uxtb	r4, r3
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    140e:	b25b      	sxtb	r3, r3
    1410:	2b00      	cmp	r3, #0
    1412:	da0c      	bge.n	142e <uart1_status_isr+0x56>
    1414:	7913      	ldrb	r3, [r2, #4]
    1416:	b25b      	sxtb	r3, r3
    1418:	2b00      	cmp	r3, #0
    141a:	da08      	bge.n	142e <uart1_status_isr+0x56>
		head = tx_buffer_head;
    141c:	4b29      	ldr	r3, [pc, #164]	; (14c4 <uart1_status_isr+0xec>)
		tail = tx_buffer_tail;
    141e:	482a      	ldr	r0, [pc, #168]	; (14c8 <uart1_status_isr+0xf0>)
		head = tx_buffer_head;
    1420:	781d      	ldrb	r5, [r3, #0]
		tail = tx_buffer_tail;
    1422:	7801      	ldrb	r1, [r0, #0]
    1424:	b2cb      	uxtb	r3, r1
		if (head == tail) {
    1426:	428d      	cmp	r5, r1
    1428:	d12b      	bne.n	1482 <uart1_status_isr+0xaa>
			UART1_C2 = C2_TX_COMPLETING;
    142a:	236c      	movs	r3, #108	; 0x6c
    142c:	70d3      	strb	r3, [r2, #3]
			UART1_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
    142e:	2340      	movs	r3, #64	; 0x40
    1430:	421c      	tst	r4, r3
    1432:	d01e      	beq.n	1472 <uart1_status_isr+0x9a>
    1434:	7911      	ldrb	r1, [r2, #4]
    1436:	4219      	tst	r1, r3
    1438:	d01b      	beq.n	1472 <uart1_status_isr+0x9a>
		transmitting = 0;
    143a:	2100      	movs	r1, #0
    143c:	4b23      	ldr	r3, [pc, #140]	; (14cc <uart1_status_isr+0xf4>)
    143e:	7019      	strb	r1, [r3, #0]
		if (transmit_pin) transmit_deassert();
    1440:	4b23      	ldr	r3, [pc, #140]	; (14d0 <uart1_status_isr+0xf8>)
    1442:	681b      	ldr	r3, [r3, #0]
    1444:	428b      	cmp	r3, r1
    1446:	d002      	beq.n	144e <uart1_status_isr+0x76>
    1448:	4922      	ldr	r1, [pc, #136]	; (14d4 <uart1_status_isr+0xfc>)
    144a:	7809      	ldrb	r1, [r1, #0]
    144c:	7219      	strb	r1, [r3, #8]
		#if defined(KINETISL)
		if (half_duplex_mode) {
    144e:	4b22      	ldr	r3, [pc, #136]	; (14d8 <uart1_status_isr+0x100>)
    1450:	781b      	ldrb	r3, [r3, #0]
    1452:	2b00      	cmp	r3, #0
    1454:	d00b      	beq.n	146e <uart1_status_isr+0x96>
			__disable_irq();
    1456:	b672      	cpsid	i
			volatile uint32_t reg = UART1_C3;
			reg &= ~UART_C3_TXDIR;
    1458:	2120      	movs	r1, #32
			volatile uint32_t reg = UART1_C3;
    145a:	7993      	ldrb	r3, [r2, #6]
    145c:	b2db      	uxtb	r3, r3
    145e:	9301      	str	r3, [sp, #4]
			reg &= ~UART_C3_TXDIR;
    1460:	9b01      	ldr	r3, [sp, #4]
    1462:	438b      	bics	r3, r1
    1464:	9301      	str	r3, [sp, #4]
			UART1_C3 = reg;
    1466:	9b01      	ldr	r3, [sp, #4]
    1468:	b2db      	uxtb	r3, r3
    146a:	7193      	strb	r3, [r2, #6]
			__enable_irq();
    146c:	b662      	cpsie	i
		}
		#endif		
		UART1_C2 = C2_TX_INACTIVE;
    146e:	232c      	movs	r3, #44	; 0x2c
    1470:	70d3      	strb	r3, [r2, #3]
	}
}
    1472:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
				rx_buffer_storage_[head-SERIAL2_RX_BUFFER_SIZE] = n;
    1474:	001c      	movs	r4, r3
    1476:	4819      	ldr	r0, [pc, #100]	; (14dc <uart1_status_isr+0x104>)
    1478:	3c40      	subs	r4, #64	; 0x40
    147a:	6800      	ldr	r0, [r0, #0]
    147c:	1900      	adds	r0, r0, r4
    147e:	7001      	strb	r1, [r0, #0]
    1480:	e7c1      	b.n	1406 <uart1_status_isr+0x2e>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    1482:	4d17      	ldr	r5, [pc, #92]	; (14e0 <uart1_status_isr+0x108>)
    1484:	1c59      	adds	r1, r3, #1
    1486:	682d      	ldr	r5, [r5, #0]
    1488:	428d      	cmp	r5, r1
    148a:	d909      	bls.n	14a0 <uart1_status_isr+0xc8>
			if (tail < SERIAL2_TX_BUFFER_SIZE) {
    148c:	2927      	cmp	r1, #39	; 0x27
    148e:	d809      	bhi.n	14a4 <uart1_status_isr+0xcc>
				n = tx_buffer[tail];
    1490:	4b14      	ldr	r3, [pc, #80]	; (14e4 <uart1_status_isr+0x10c>)
    1492:	5c5b      	ldrb	r3, [r3, r1]
				n = tx_buffer_storage_[tail-SERIAL2_TX_BUFFER_SIZE];
    1494:	b2db      	uxtb	r3, r3
			UART1_D = n;
    1496:	b2db      	uxtb	r3, r3
			tx_buffer_tail = tail;
    1498:	b2c9      	uxtb	r1, r1
			UART1_D = n;
    149a:	71d3      	strb	r3, [r2, #7]
			tx_buffer_tail = tail;
    149c:	7001      	strb	r1, [r0, #0]
    149e:	e7c6      	b.n	142e <uart1_status_isr+0x56>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    14a0:	2100      	movs	r1, #0
    14a2:	e7f5      	b.n	1490 <uart1_status_isr+0xb8>
				n = tx_buffer_storage_[tail-SERIAL2_TX_BUFFER_SIZE];
    14a4:	4d10      	ldr	r5, [pc, #64]	; (14e8 <uart1_status_isr+0x110>)
    14a6:	3b27      	subs	r3, #39	; 0x27
    14a8:	682d      	ldr	r5, [r5, #0]
    14aa:	18eb      	adds	r3, r5, r3
    14ac:	781b      	ldrb	r3, [r3, #0]
    14ae:	e7f1      	b.n	1494 <uart1_status_isr+0xbc>
    14b0:	4006b000 	.word	0x4006b000
    14b4:	200001b8 	.word	0x200001b8
    14b8:	1ffffdac 	.word	0x1ffffdac
    14bc:	200001c0 	.word	0x200001c0
    14c0:	20000178 	.word	0x20000178
    14c4:	200001f1 	.word	0x200001f1
    14c8:	200001f8 	.word	0x200001f8
    14cc:	200001c8 	.word	0x200001c8
    14d0:	200001c4 	.word	0x200001c4
    14d4:	200001c1 	.word	0x200001c1
    14d8:	20000171 	.word	0x20000171
    14dc:	200001bc 	.word	0x200001bc
    14e0:	1ffffdb0 	.word	0x1ffffdb0
    14e4:	200001c9 	.word	0x200001c9
    14e8:	200001f4 	.word	0x200001f4

000014ec <serial2_add_memory_for_read>:

void serial2_add_memory_for_read(void *buffer, size_t length)
{
	rx_buffer_storage_ = (BUFTYPE*)buffer;
    14ec:	4b06      	ldr	r3, [pc, #24]	; (1508 <serial2_add_memory_for_read+0x1c>)
    14ee:	6018      	str	r0, [r3, #0]
	if (buffer) {
		rx_buffer_total_size_ = SERIAL2_RX_BUFFER_SIZE + length;
	} else {
		rx_buffer_total_size_ = SERIAL2_RX_BUFFER_SIZE;
    14f0:	2340      	movs	r3, #64	; 0x40
	if (buffer) {
    14f2:	2800      	cmp	r0, #0
    14f4:	d001      	beq.n	14fa <serial2_add_memory_for_read+0xe>
		rx_buffer_total_size_ = SERIAL2_RX_BUFFER_SIZE + length;
    14f6:	000b      	movs	r3, r1
    14f8:	3340      	adds	r3, #64	; 0x40
    14fa:	4a04      	ldr	r2, [pc, #16]	; (150c <serial2_add_memory_for_read+0x20>)
	} 

	rts_low_watermark_ = RTS_LOW_WATERMARK + length;
    14fc:	311a      	adds	r1, #26
    14fe:	6013      	str	r3, [r2, #0]
    1500:	4b03      	ldr	r3, [pc, #12]	; (1510 <serial2_add_memory_for_read+0x24>)
    1502:	6019      	str	r1, [r3, #0]
	rts_high_watermark_ = RTS_HIGH_WATERMARK + length;
}
    1504:	4770      	bx	lr
    1506:	46c0      	nop			; (mov r8, r8)
    1508:	200001bc 	.word	0x200001bc
    150c:	1ffffdac 	.word	0x1ffffdac
    1510:	1ffffda8 	.word	0x1ffffda8

00001514 <serial2_add_memory_for_write>:

void serial2_add_memory_for_write(void *buffer, size_t length)
{
	tx_buffer_storage_ = (BUFTYPE*)buffer;
    1514:	4b04      	ldr	r3, [pc, #16]	; (1528 <serial2_add_memory_for_write+0x14>)
    1516:	6018      	str	r0, [r3, #0]
	if (buffer) {
		tx_buffer_total_size_ = SERIAL2_TX_BUFFER_SIZE + length;
	} else {
		tx_buffer_total_size_ = SERIAL2_TX_BUFFER_SIZE;
    1518:	2328      	movs	r3, #40	; 0x28
	if (buffer) {
    151a:	2800      	cmp	r0, #0
    151c:	d001      	beq.n	1522 <serial2_add_memory_for_write+0xe>
		tx_buffer_total_size_ = SERIAL2_TX_BUFFER_SIZE + length;
    151e:	000b      	movs	r3, r1
    1520:	3328      	adds	r3, #40	; 0x28
    1522:	4a02      	ldr	r2, [pc, #8]	; (152c <serial2_add_memory_for_write+0x18>)
	} 
}
    1524:	6013      	str	r3, [r2, #0]
    1526:	4770      	bx	lr
    1528:	200001f4 	.word	0x200001f4
    152c:	1ffffdb0 	.word	0x1ffffdb0

00001530 <uart2_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart2_status_isr(void)
{
    1530:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART2_S1 & UART_S1_RDRF) {
    1532:	4a40      	ldr	r2, [pc, #256]	; (1634 <uart2_status_isr+0x104>)
    1534:	7913      	ldrb	r3, [r2, #4]
    1536:	069b      	lsls	r3, r3, #26
    1538:	d524      	bpl.n	1584 <uart2_status_isr+0x54>
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    153a:	4e3f      	ldr	r6, [pc, #252]	; (1638 <uart2_status_isr+0x108>)
		if (head >= rx_buffer_total_size_) head = 0;
    153c:	493f      	ldr	r1, [pc, #252]	; (163c <uart2_status_isr+0x10c>)
			n = UART2_D;
    153e:	79d0      	ldrb	r0, [r2, #7]
		head = rx_buffer_head + 1;
    1540:	7833      	ldrb	r3, [r6, #0]
		if (head >= rx_buffer_total_size_) head = 0;
    1542:	6809      	ldr	r1, [r1, #0]
		head = rx_buffer_head + 1;
    1544:	3301      	adds	r3, #1
		if (head >= rx_buffer_total_size_) head = 0;
    1546:	428b      	cmp	r3, r1
    1548:	41a4      	sbcs	r4, r4
    154a:	4023      	ands	r3, r4
		if (head != rx_buffer_tail) {
    154c:	4c3c      	ldr	r4, [pc, #240]	; (1640 <uart2_status_isr+0x110>)
			n = UART2_D;
    154e:	b2c0      	uxtb	r0, r0
		if (head != rx_buffer_tail) {
    1550:	7824      	ldrb	r4, [r4, #0]
    1552:	429c      	cmp	r4, r3
    1554:	d005      	beq.n	1562 <uart2_status_isr+0x32>
			if (head < SERIAL3_RX_BUFFER_SIZE) {
    1556:	2b3f      	cmp	r3, #63	; 0x3f
    1558:	d84a      	bhi.n	15f0 <uart2_status_isr+0xc0>
				rx_buffer[head] = n;
    155a:	4c3a      	ldr	r4, [pc, #232]	; (1644 <uart2_status_isr+0x114>)
    155c:	54e0      	strb	r0, [r4, r3]
			} else {
				rx_buffer_storage_[head-SERIAL3_RX_BUFFER_SIZE] = n;
			}

			rx_buffer_head = head;
    155e:	b2d8      	uxtb	r0, r3
    1560:	7030      	strb	r0, [r6, #0]
		}
		if (rts_pin) {
    1562:	4839      	ldr	r0, [pc, #228]	; (1648 <uart2_status_isr+0x118>)
    1564:	6800      	ldr	r0, [r0, #0]
    1566:	2800      	cmp	r0, #0
    1568:	d00c      	beq.n	1584 <uart2_status_isr+0x54>
			int avail;
			tail = tx_buffer_tail;
    156a:	4c38      	ldr	r4, [pc, #224]	; (164c <uart2_status_isr+0x11c>)
    156c:	7825      	ldrb	r5, [r4, #0]
    156e:	b2ec      	uxtb	r4, r5
			if (head >= tail) avail = head - tail;
    1570:	42ab      	cmp	r3, r5
    1572:	d344      	bcc.n	15fe <uart2_status_isr+0xce>
    1574:	1b1b      	subs	r3, r3, r4
			else avail = rx_buffer_total_size_ + head - tail;
			if (avail >= rts_high_watermark_) rts_deassert();
    1576:	4936      	ldr	r1, [pc, #216]	; (1650 <uart2_status_isr+0x120>)
    1578:	6809      	ldr	r1, [r1, #0]
    157a:	428b      	cmp	r3, r1
    157c:	d302      	bcc.n	1584 <uart2_status_isr+0x54>
    157e:	4b35      	ldr	r3, [pc, #212]	; (1654 <uart2_status_isr+0x124>)
    1580:	781b      	ldrb	r3, [r3, #0]
    1582:	7103      	strb	r3, [r0, #4]
		}
	}
	c = UART2_C2;
    1584:	78d3      	ldrb	r3, [r2, #3]
    1586:	b2dc      	uxtb	r4, r3
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    1588:	b25b      	sxtb	r3, r3
    158a:	2b00      	cmp	r3, #0
    158c:	da0c      	bge.n	15a8 <uart2_status_isr+0x78>
    158e:	7913      	ldrb	r3, [r2, #4]
    1590:	b25b      	sxtb	r3, r3
    1592:	2b00      	cmp	r3, #0
    1594:	da08      	bge.n	15a8 <uart2_status_isr+0x78>
		head = tx_buffer_head;
    1596:	4b30      	ldr	r3, [pc, #192]	; (1658 <uart2_status_isr+0x128>)
		tail = tx_buffer_tail;
    1598:	482c      	ldr	r0, [pc, #176]	; (164c <uart2_status_isr+0x11c>)
		head = tx_buffer_head;
    159a:	781d      	ldrb	r5, [r3, #0]
		tail = tx_buffer_tail;
    159c:	7801      	ldrb	r1, [r0, #0]
    159e:	b2cb      	uxtb	r3, r1
		if (head == tail) {
    15a0:	428d      	cmp	r5, r1
    15a2:	d12f      	bne.n	1604 <uart2_status_isr+0xd4>
			UART2_C2 = C2_TX_COMPLETING;
    15a4:	236c      	movs	r3, #108	; 0x6c
    15a6:	70d3      	strb	r3, [r2, #3]
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
    15a8:	2340      	movs	r3, #64	; 0x40
    15aa:	421c      	tst	r4, r3
    15ac:	d01f      	beq.n	15ee <uart2_status_isr+0xbe>
    15ae:	7911      	ldrb	r1, [r2, #4]
    15b0:	4219      	tst	r1, r3
    15b2:	d01c      	beq.n	15ee <uart2_status_isr+0xbe>
		transmitting = 0;
    15b4:	2100      	movs	r1, #0
    15b6:	4b29      	ldr	r3, [pc, #164]	; (165c <uart2_status_isr+0x12c>)
    15b8:	7019      	strb	r1, [r3, #0]
		if (transmit_pin) transmit_deassert();
    15ba:	4b29      	ldr	r3, [pc, #164]	; (1660 <uart2_status_isr+0x130>)
    15bc:	681b      	ldr	r3, [r3, #0]
    15be:	428b      	cmp	r3, r1
    15c0:	d003      	beq.n	15ca <uart2_status_isr+0x9a>
    15c2:	4928      	ldr	r1, [pc, #160]	; (1664 <uart2_status_isr+0x134>)
    15c4:	7809      	ldrb	r1, [r1, #0]
    15c6:	7219      	strb	r1, [r3, #8]
		#if defined(KINETISL)
		if (transmit_pin) transmit_deassert();
    15c8:	7219      	strb	r1, [r3, #8]
		if (half_duplex_mode) {
    15ca:	4b27      	ldr	r3, [pc, #156]	; (1668 <uart2_status_isr+0x138>)
    15cc:	781b      	ldrb	r3, [r3, #0]
    15ce:	2b00      	cmp	r3, #0
    15d0:	d00b      	beq.n	15ea <uart2_status_isr+0xba>
			__disable_irq();
    15d2:	b672      	cpsid	i
			volatile uint32_t reg = UART2_C3;
			reg &= ~UART_C3_TXDIR;
    15d4:	2120      	movs	r1, #32
			volatile uint32_t reg = UART2_C3;
    15d6:	7993      	ldrb	r3, [r2, #6]
    15d8:	b2db      	uxtb	r3, r3
    15da:	9301      	str	r3, [sp, #4]
			reg &= ~UART_C3_TXDIR;
    15dc:	9b01      	ldr	r3, [sp, #4]
    15de:	438b      	bics	r3, r1
    15e0:	9301      	str	r3, [sp, #4]
			UART2_C3 = reg;
    15e2:	9b01      	ldr	r3, [sp, #4]
    15e4:	b2db      	uxtb	r3, r3
    15e6:	7193      	strb	r3, [r2, #6]
			__enable_irq();
    15e8:	b662      	cpsie	i
		}
		#endif
		UART2_C2 = C2_TX_INACTIVE;
    15ea:	232c      	movs	r3, #44	; 0x2c
    15ec:	70d3      	strb	r3, [r2, #3]
	}
}
    15ee:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
				rx_buffer_storage_[head-SERIAL3_RX_BUFFER_SIZE] = n;
    15f0:	001d      	movs	r5, r3
    15f2:	4c1e      	ldr	r4, [pc, #120]	; (166c <uart2_status_isr+0x13c>)
    15f4:	3d40      	subs	r5, #64	; 0x40
    15f6:	6824      	ldr	r4, [r4, #0]
    15f8:	1964      	adds	r4, r4, r5
    15fa:	7020      	strb	r0, [r4, #0]
    15fc:	e7af      	b.n	155e <uart2_status_isr+0x2e>
			else avail = rx_buffer_total_size_ + head - tail;
    15fe:	1b09      	subs	r1, r1, r4
    1600:	18cb      	adds	r3, r1, r3
    1602:	e7b8      	b.n	1576 <uart2_status_isr+0x46>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    1604:	4d1a      	ldr	r5, [pc, #104]	; (1670 <uart2_status_isr+0x140>)
    1606:	1c59      	adds	r1, r3, #1
    1608:	682d      	ldr	r5, [r5, #0]
    160a:	428d      	cmp	r5, r1
    160c:	d909      	bls.n	1622 <uart2_status_isr+0xf2>
			if (tail < SERIAL3_TX_BUFFER_SIZE) {
    160e:	2927      	cmp	r1, #39	; 0x27
    1610:	d809      	bhi.n	1626 <uart2_status_isr+0xf6>
				n = tx_buffer[tail];
    1612:	4b18      	ldr	r3, [pc, #96]	; (1674 <uart2_status_isr+0x144>)
    1614:	5c5b      	ldrb	r3, [r3, r1]
				n = tx_buffer_storage_[tail-SERIAL3_TX_BUFFER_SIZE];
    1616:	b2db      	uxtb	r3, r3
			UART2_D = n;
    1618:	b2db      	uxtb	r3, r3
			tx_buffer_tail = tail;
    161a:	b2c9      	uxtb	r1, r1
			UART2_D = n;
    161c:	71d3      	strb	r3, [r2, #7]
			tx_buffer_tail = tail;
    161e:	7001      	strb	r1, [r0, #0]
    1620:	e7c2      	b.n	15a8 <uart2_status_isr+0x78>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    1622:	2100      	movs	r1, #0
    1624:	e7f5      	b.n	1612 <uart2_status_isr+0xe2>
				n = tx_buffer_storage_[tail-SERIAL3_TX_BUFFER_SIZE];
    1626:	4d14      	ldr	r5, [pc, #80]	; (1678 <uart2_status_isr+0x148>)
    1628:	3b27      	subs	r3, #39	; 0x27
    162a:	682d      	ldr	r5, [r5, #0]
    162c:	18eb      	adds	r3, r5, r3
    162e:	781b      	ldrb	r3, [r3, #0]
    1630:	e7f1      	b.n	1616 <uart2_status_isr+0xe6>
    1632:	46c0      	nop			; (mov r8, r8)
    1634:	4006c000 	.word	0x4006c000
    1638:	20000240 	.word	0x20000240
    163c:	1ffffdb8 	.word	0x1ffffdb8
    1640:	20000248 	.word	0x20000248
    1644:	20000200 	.word	0x20000200
    1648:	200001fc 	.word	0x200001fc
    164c:	20000280 	.word	0x20000280
    1650:	1ffffdb4 	.word	0x1ffffdb4
    1654:	200001fa 	.word	0x200001fa
    1658:	20000279 	.word	0x20000279
    165c:	20000250 	.word	0x20000250
    1660:	2000024c 	.word	0x2000024c
    1664:	20000249 	.word	0x20000249
    1668:	200001f9 	.word	0x200001f9
    166c:	20000244 	.word	0x20000244
    1670:	1ffffdbc 	.word	0x1ffffdbc
    1674:	20000251 	.word	0x20000251
    1678:	2000027c 	.word	0x2000027c

0000167c <serialEvent2()>:

#include <Arduino.h>
#include "HardwareSerial.h"
void serialEvent2() __attribute__((weak));
void serialEvent2() {}		// No use calling this so disable if called...
    167c:	4770      	bx	lr
    167e:	Address 0x0000167e is out of bounds.


00001680 <endpoint0_transmit>:
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1680:	2302      	movs	r3, #2
{
    1682:	b5f0      	push	{r4, r5, r6, r7, lr}
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1684:	4c0a      	ldr	r4, [pc, #40]	; (16b0 <endpoint0_transmit+0x30>)
    1686:	4e0b      	ldr	r6, [pc, #44]	; (16b4 <endpoint0_transmit+0x34>)
    1688:	7825      	ldrb	r5, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    168a:	27c8      	movs	r7, #200	; 0xc8
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    168c:	432b      	orrs	r3, r5
    168e:	00db      	lsls	r3, r3, #3
    1690:	18f2      	adds	r2, r6, r3
    1692:	6050      	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1694:	4808      	ldr	r0, [pc, #32]	; (16b8 <endpoint0_transmit+0x38>)
    1696:	7802      	ldrb	r2, [r0, #0]
    1698:	2a00      	cmp	r2, #0
    169a:	d100      	bne.n	169e <endpoint0_transmit+0x1e>
    169c:	3f40      	subs	r7, #64	; 0x40
    169e:	0409      	lsls	r1, r1, #16
    16a0:	4339      	orrs	r1, r7
    16a2:	50f1      	str	r1, [r6, r3]
	ep0_tx_data_toggle ^= 1;
    16a4:	2301      	movs	r3, #1
    16a6:	405a      	eors	r2, r3
	ep0_tx_bdt_bank ^= 1;
    16a8:	406b      	eors	r3, r5
	ep0_tx_data_toggle ^= 1;
    16aa:	7002      	strb	r2, [r0, #0]
	ep0_tx_bdt_bank ^= 1;
    16ac:	7023      	strb	r3, [r4, #0]
}
    16ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    16b0:	20000304 	.word	0x20000304
    16b4:	1ffff800 	.word	0x1ffff800
    16b8:	20000305 	.word	0x20000305

000016bc <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    16bc:	1e43      	subs	r3, r0, #1
{
    16be:	b510      	push	{r4, lr}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    16c0:	2000      	movs	r0, #0
    16c2:	2b03      	cmp	r3, #3
    16c4:	d80e      	bhi.n	16e4 <usb_rx+0x28>
	__disable_irq();
    16c6:	b672      	cpsid	i
	ret = rx_first[endpoint];
    16c8:	4a07      	ldr	r2, [pc, #28]	; (16e8 <usb_rx+0x2c>)
    16ca:	0099      	lsls	r1, r3, #2
    16cc:	5888      	ldr	r0, [r1, r2]
	if (ret) {
    16ce:	2800      	cmp	r0, #0
    16d0:	d007      	beq.n	16e2 <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    16d2:	6844      	ldr	r4, [r0, #4]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    16d4:	005b      	lsls	r3, r3, #1
		rx_first[endpoint] = ret->next;
    16d6:	508c      	str	r4, [r1, r2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    16d8:	4a04      	ldr	r2, [pc, #16]	; (16ec <usb_rx+0x30>)
    16da:	8804      	ldrh	r4, [r0, #0]
    16dc:	5a99      	ldrh	r1, [r3, r2]
    16de:	1b09      	subs	r1, r1, r4
    16e0:	5299      	strh	r1, [r3, r2]
	}
	__enable_irq();
    16e2:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    16e4:	bd10      	pop	{r4, pc}
    16e6:	46c0      	nop			; (mov r8, r8)
    16e8:	20000314 	.word	0x20000314
    16ec:	20000362 	.word	0x20000362

000016f0 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    16f0:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    16f2:	2000      	movs	r0, #0
    16f4:	2b03      	cmp	r3, #3
    16f6:	d806      	bhi.n	1706 <usb_tx_packet_count+0x16>
	__disable_irq();
    16f8:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    16fa:	4a05      	ldr	r2, [pc, #20]	; (1710 <usb_tx_packet_count+0x20>)
    16fc:	009b      	lsls	r3, r3, #2
    16fe:	589b      	ldr	r3, [r3, r2]
    1700:	2b00      	cmp	r3, #0
    1702:	d101      	bne.n	1708 <usb_tx_packet_count+0x18>
	__enable_irq();
    1704:	b662      	cpsie	i
	return count;
}
    1706:	4770      	bx	lr
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    1708:	685b      	ldr	r3, [r3, #4]
    170a:	3001      	adds	r0, #1
    170c:	e7f8      	b.n	1700 <usb_tx_packet_count+0x10>
    170e:	46c0      	nop			; (mov r8, r8)
    1710:	2000033c 	.word	0x2000033c

00001714 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    1714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    1716:	b672      	cpsid	i
    1718:	2204      	movs	r2, #4
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    171a:	2508      	movs	r5, #8
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    171c:	2601      	movs	r6, #1
    171e:	4c15      	ldr	r4, [pc, #84]	; (1774 <usb_rx_memory+0x60>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    1720:	4b15      	ldr	r3, [pc, #84]	; (1778 <usb_rx_memory+0x64>)
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    1722:	7821      	ldrb	r1, [r4, #0]
    1724:	4229      	tst	r1, r5
    1726:	d019      	beq.n	175c <usb_rx_memory+0x48>
			if (table[index(i, RX, EVEN)].desc == 0) {
    1728:	00d1      	lsls	r1, r2, #3
    172a:	58cf      	ldr	r7, [r1, r3]
    172c:	2f00      	cmp	r7, #0
    172e:	d10a      	bne.n	1746 <usb_rx_memory+0x32>
				table[index(i, RX, EVEN)].addr = packet->buf;
    1730:	185a      	adds	r2, r3, r1
    1732:	3008      	adds	r0, #8
    1734:	6050      	str	r0, [r2, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    1736:	4a11      	ldr	r2, [pc, #68]	; (177c <usb_rx_memory+0x68>)
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    1738:	505a      	str	r2, [r3, r1]
				usb_rx_memory_needed--;
    173a:	4a11      	ldr	r2, [pc, #68]	; (1780 <usb_rx_memory+0x6c>)
    173c:	7813      	ldrb	r3, [r2, #0]
    173e:	3b01      	subs	r3, #1
    1740:	7013      	strb	r3, [r2, #0]
				__enable_irq();
    1742:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    1744:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (table[index(i, RX, ODD)].desc == 0) {
    1746:	0031      	movs	r1, r6
    1748:	4311      	orrs	r1, r2
    174a:	00c9      	lsls	r1, r1, #3
    174c:	58cf      	ldr	r7, [r1, r3]
    174e:	2f00      	cmp	r7, #0
    1750:	d104      	bne.n	175c <usb_rx_memory+0x48>
				table[index(i, RX, ODD)].addr = packet->buf;
    1752:	185a      	adds	r2, r3, r1
    1754:	3008      	adds	r0, #8
    1756:	6050      	str	r0, [r2, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    1758:	4a0a      	ldr	r2, [pc, #40]	; (1784 <usb_rx_memory+0x70>)
    175a:	e7ed      	b.n	1738 <usb_rx_memory+0x24>
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    175c:	3204      	adds	r2, #4
    175e:	3401      	adds	r4, #1
    1760:	2a14      	cmp	r2, #20
    1762:	d1de      	bne.n	1722 <usb_rx_memory+0xe>
	__enable_irq();
    1764:	b662      	cpsie	i
	usb_rx_memory_needed = 0;
    1766:	2200      	movs	r2, #0
    1768:	4b05      	ldr	r3, [pc, #20]	; (1780 <usb_rx_memory+0x6c>)
    176a:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
    176c:	f000 fbf4 	bl	1f58 <usb_free>
	return;
    1770:	e7e8      	b.n	1744 <usb_rx_memory+0x30>
    1772:	46c0      	nop			; (mov r8, r8)
    1774:	00002b14 	.word	0x00002b14
    1778:	1ffff800 	.word	0x1ffff800
    177c:	00400088 	.word	0x00400088
    1780:	2000036a 	.word	0x2000036a
    1784:	004000c8 	.word	0x004000c8

00001788 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    1788:	1e42      	subs	r2, r0, #1
{
    178a:	b510      	push	{r4, lr}
	if (endpoint >= NUM_ENDPOINTS) return;
    178c:	2a03      	cmp	r2, #3
    178e:	d82b      	bhi.n	17e8 <usb_tx+0x60>
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    1790:	2302      	movs	r3, #2
    1792:	0080      	lsls	r0, r0, #2
    1794:	4303      	orrs	r3, r0
    1796:	4817      	ldr	r0, [pc, #92]	; (17f4 <usb_tx+0x6c>)
    1798:	00db      	lsls	r3, r3, #3
    179a:	181b      	adds	r3, r3, r0
	__disable_irq();
    179c:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    179e:	4c16      	ldr	r4, [pc, #88]	; (17f8 <usb_tx+0x70>)
    17a0:	5ca0      	ldrb	r0, [r4, r2]
    17a2:	2803      	cmp	r0, #3
    17a4:	d817      	bhi.n	17d6 <usb_tx+0x4e>
    17a6:	f000 fea3 	bl	24f0 <__gnu_thumb1_case_uqi>
    17aa:	1023      	.short	0x1023
    17ac:	1302      	.short	0x1302
    17ae:	2005      	movs	r0, #5
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    17b0:	54a0      	strb	r0, [r4, r2]
	b->addr = packet->buf;
    17b2:	000a      	movs	r2, r1
    17b4:	3208      	adds	r2, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    17b6:	20c8      	movs	r0, #200	; 0xc8
	b->addr = packet->buf;
    17b8:	605a      	str	r2, [r3, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    17ba:	071a      	lsls	r2, r3, #28
    17bc:	d400      	bmi.n	17c0 <usb_tx+0x38>
    17be:	3840      	subs	r0, #64	; 0x40
    17c0:	880a      	ldrh	r2, [r1, #0]
    17c2:	0412      	lsls	r2, r2, #16
    17c4:	4302      	orrs	r2, r0
    17c6:	601a      	str	r2, [r3, #0]
    17c8:	e00d      	b.n	17e6 <usb_tx+0x5e>
		next = TX_STATE_EVEN_FREE;
    17ca:	2002      	movs	r0, #2
		b++;
    17cc:	3308      	adds	r3, #8
		break;
    17ce:	e7ef      	b.n	17b0 <usb_tx+0x28>
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    17d0:	2004      	movs	r0, #4
		b++;
    17d2:	3308      	adds	r3, #8
		break;
    17d4:	e7ec      	b.n	17b0 <usb_tx+0x28>
		if (tx_first[endpoint] == NULL) {
    17d6:	4809      	ldr	r0, [pc, #36]	; (17fc <usb_tx+0x74>)
    17d8:	0092      	lsls	r2, r2, #2
    17da:	5814      	ldr	r4, [r2, r0]
    17dc:	4b08      	ldr	r3, [pc, #32]	; (1800 <usb_tx+0x78>)
    17de:	2c00      	cmp	r4, #0
    17e0:	d103      	bne.n	17ea <usb_tx+0x62>
			tx_first[endpoint] = packet;
    17e2:	5011      	str	r1, [r2, r0]
		tx_last[endpoint] = packet;
    17e4:	5099      	str	r1, [r3, r2]
	__enable_irq();
    17e6:	b662      	cpsie	i
}
    17e8:	bd10      	pop	{r4, pc}
			tx_last[endpoint]->next = packet;
    17ea:	5898      	ldr	r0, [r3, r2]
    17ec:	6041      	str	r1, [r0, #4]
    17ee:	e7f9      	b.n	17e4 <usb_tx+0x5c>
		next = TX_STATE_ODD_FREE;
    17f0:	2003      	movs	r0, #3
    17f2:	e7dd      	b.n	17b0 <usb_tx+0x28>
    17f4:	1ffff800 	.word	0x1ffff800
    17f8:	2000035c 	.word	0x2000035c
    17fc:	2000033c 	.word	0x2000033c
    1800:	2000034c 	.word	0x2000034c

00001804 <usb_isr>:
}



void usb_isr(void)
{
    1804:	b5f0      	push	{r4, r5, r6, r7, lr}
    1806:	b085      	sub	sp, #20
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    1808:	2204      	movs	r2, #4
	status = USB0_ISTAT;
    180a:	4bc3      	ldr	r3, [pc, #780]	; (1b18 <usb_isr+0x314>)
    180c:	781b      	ldrb	r3, [r3, #0]
    180e:	b2dc      	uxtb	r4, r3
	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    1810:	4213      	tst	r3, r2
    1812:	d01d      	beq.n	1850 <usb_isr+0x4c>
		if (usb_configuration) {
    1814:	4bc1      	ldr	r3, [pc, #772]	; (1b1c <usb_isr+0x318>)
    1816:	781b      	ldrb	r3, [r3, #0]
    1818:	2b00      	cmp	r3, #0
    181a:	d016      	beq.n	184a <usb_isr+0x46>
			t = usb_reboot_timer;
    181c:	4ac0      	ldr	r2, [pc, #768]	; (1b20 <usb_isr+0x31c>)
    181e:	7811      	ldrb	r1, [r2, #0]
    1820:	b2cb      	uxtb	r3, r1
			if (t) {
    1822:	2900      	cmp	r1, #0
    1824:	d005      	beq.n	1832 <usb_isr+0x2e>
				usb_reboot_timer = --t;
    1826:	3b01      	subs	r3, #1
    1828:	b2db      	uxtb	r3, r3
    182a:	7013      	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    182c:	2b00      	cmp	r3, #0
    182e:	d100      	bne.n	1832 <usb_isr+0x2e>
	__asm__ volatile("bkpt");
    1830:	be00      	bkpt	0x0000
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    1832:	4abc      	ldr	r2, [pc, #752]	; (1b24 <usb_isr+0x320>)
    1834:	7811      	ldrb	r1, [r2, #0]
    1836:	b2cb      	uxtb	r3, r1
			if (t) {
    1838:	2900      	cmp	r1, #0
    183a:	d006      	beq.n	184a <usb_isr+0x46>
				usb_cdc_transmit_flush_timer = --t;
    183c:	3b01      	subs	r3, #1
    183e:	b2db      	uxtb	r3, r3
    1840:	7013      	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    1842:	2b00      	cmp	r3, #0
    1844:	d101      	bne.n	184a <usb_isr+0x46>
    1846:	f000 fced 	bl	2224 <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    184a:	2204      	movs	r2, #4
    184c:	4bb2      	ldr	r3, [pc, #712]	; (1b18 <usb_isr+0x314>)
    184e:	701a      	strb	r2, [r3, #0]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    1850:	2208      	movs	r2, #8
    1852:	2308      	movs	r3, #8
    1854:	4022      	ands	r2, r4
    1856:	421c      	tst	r4, r3
    1858:	d100      	bne.n	185c <usb_isr+0x58>
    185a:	e26c      	b.n	1d36 <usb_isr+0x532>
		uint8_t endpoint;
		stat = USB0_STAT;
    185c:	4bb2      	ldr	r3, [pc, #712]	; (1b28 <usb_isr+0x324>)
    185e:	4cb3      	ldr	r4, [pc, #716]	; (1b2c <usb_isr+0x328>)
    1860:	781e      	ldrb	r6, [r3, #0]
    1862:	b2f3      	uxtb	r3, r6
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
    1864:	0935      	lsrs	r5, r6, #4
		if (endpoint == 0) {
    1866:	08b6      	lsrs	r6, r6, #2
	b = stat2bufferdescriptor(stat);
    1868:	00f6      	lsls	r6, r6, #3
		if (endpoint == 0) {
    186a:	2d00      	cmp	r5, #0
    186c:	d000      	beq.n	1870 <usb_isr+0x6c>
    186e:	e1f8      	b.n	1c62 <usb_isr+0x45e>
	b = stat2bufferdescriptor(stat);
    1870:	19a6      	adds	r6, r4, r6
	pid = BDT_PID(b->desc);
    1872:	6833      	ldr	r3, [r6, #0]
	buf = b->addr;
    1874:	6871      	ldr	r1, [r6, #4]
	pid = BDT_PID(b->desc);
    1876:	069b      	lsls	r3, r3, #26
    1878:	0f1b      	lsrs	r3, r3, #28
	switch (pid) {
    187a:	2b09      	cmp	r3, #9
    187c:	d100      	bne.n	1880 <usb_isr+0x7c>
    187e:	e1c6      	b.n	1c0e <usb_isr+0x40a>
    1880:	d80a      	bhi.n	1898 <usb_isr+0x94>
    1882:	3b01      	subs	r3, #1
    1884:	2b01      	cmp	r3, #1
    1886:	d800      	bhi.n	188a <usb_isr+0x86>
    1888:	e1a6      	b.n	1bd8 <usb_isr+0x3d4>
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    188a:	2201      	movs	r2, #1
    188c:	4ba8      	ldr	r3, [pc, #672]	; (1b30 <usb_isr+0x32c>)
    188e:	701a      	strb	r2, [r3, #0]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    1890:	2208      	movs	r2, #8
    1892:	4ba1      	ldr	r3, [pc, #644]	; (1b18 <usb_isr+0x314>)
    1894:	701a      	strb	r2, [r3, #0]
		goto restart;
    1896:	e7b7      	b.n	1808 <usb_isr+0x4>
	switch (pid) {
    1898:	2b0d      	cmp	r3, #13
    189a:	d1f6      	bne.n	188a <usb_isr+0x86>
		setup.word1 = *(uint32_t *)(buf);
    189c:	680a      	ldr	r2, [r1, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    189e:	6848      	ldr	r0, [r1, #4]
		setup.word1 = *(uint32_t *)(buf);
    18a0:	4ba4      	ldr	r3, [pc, #656]	; (1b34 <usb_isr+0x330>)
		ep0_tx_data_toggle = 1;
    18a2:	49a5      	ldr	r1, [pc, #660]	; (1b38 <usb_isr+0x334>)
		setup.word1 = *(uint32_t *)(buf);
    18a4:	601a      	str	r2, [r3, #0]
    18a6:	9301      	str	r3, [sp, #4]
		setup.word2 = *(uint32_t *)(buf + 4);
    18a8:	6058      	str	r0, [r3, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    18aa:	4ba4      	ldr	r3, [pc, #656]	; (1b3c <usb_isr+0x338>)
    18ac:	6033      	str	r3, [r6, #0]
		ep0_tx_ptr = NULL;
    18ae:	4ba4      	ldr	r3, [pc, #656]	; (1b40 <usb_isr+0x33c>)
	switch (setup.wRequestAndType) {
    18b0:	4ea4      	ldr	r6, [pc, #656]	; (1b44 <usb_isr+0x340>)
		ep0_tx_ptr = NULL;
    18b2:	601d      	str	r5, [r3, #0]
		ep0_tx_data_toggle = 1;
    18b4:	2301      	movs	r3, #1
    18b6:	700b      	strb	r3, [r1, #0]
    18b8:	b291      	uxth	r1, r2
		table[index(0, TX, EVEN)].desc = 0;
    18ba:	6125      	str	r5, [r4, #16]
		table[index(0, TX, ODD)].desc = 0;
    18bc:	61a5      	str	r5, [r4, #24]
	switch (setup.wRequestAndType) {
    18be:	42b1      	cmp	r1, r6
    18c0:	d847      	bhi.n	1952 <usb_isr+0x14e>
    18c2:	23d0      	movs	r3, #208	; 0xd0
    18c4:	00db      	lsls	r3, r3, #3
    18c6:	4299      	cmp	r1, r3
    18c8:	d300      	bcc.n	18cc <usb_isr+0xc8>
    18ca:	e163      	b.n	1b94 <usb_isr+0x390>
    18cc:	2381      	movs	r3, #129	; 0x81
    18ce:	005b      	lsls	r3, r3, #1
    18d0:	4299      	cmp	r1, r3
    18d2:	d100      	bne.n	18d6 <usb_isr+0xd2>
    18d4:	e0fe      	b.n	1ad4 <usb_isr+0x2d0>
    18d6:	d80c      	bhi.n	18f2 <usb_isr+0xee>
    18d8:	2980      	cmp	r1, #128	; 0x80
    18da:	d100      	bne.n	18de <usb_isr+0xda>
    18dc:	e0dd      	b.n	1a9a <usb_isr+0x296>
    18de:	2982      	cmp	r1, #130	; 0x82
    18e0:	d100      	bne.n	18e4 <usb_isr+0xe0>
    18e2:	e0e0      	b.n	1aa6 <usb_isr+0x2a2>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    18e4:	220f      	movs	r2, #15
    18e6:	4b98      	ldr	r3, [pc, #608]	; (1b48 <usb_isr+0x344>)
    18e8:	701a      	strb	r2, [r3, #0]
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    18ea:	2201      	movs	r2, #1
    18ec:	4b90      	ldr	r3, [pc, #576]	; (1b30 <usb_isr+0x32c>)
			USB0_ADDR = setup.wValue;
    18ee:	701a      	strb	r2, [r3, #0]
    18f0:	e7cb      	b.n	188a <usb_isr+0x86>
	switch (setup.wRequestAndType) {
    18f2:	4b96      	ldr	r3, [pc, #600]	; (1b4c <usb_isr+0x348>)
    18f4:	4299      	cmp	r1, r3
    18f6:	d100      	bne.n	18fa <usb_isr+0xf6>
    18f8:	e0fc      	b.n	1af4 <usb_isr+0x2f0>
    18fa:	22a0      	movs	r2, #160	; 0xa0
    18fc:	00d2      	lsls	r2, r2, #3
    18fe:	2300      	movs	r3, #0
    1900:	001c      	movs	r4, r3
    1902:	4291      	cmp	r1, r2
    1904:	d1ee      	bne.n	18e4 <usb_isr+0xe0>
	if (datalen > setup.wLength) datalen = setup.wLength;
    1906:	9a01      	ldr	r2, [sp, #4]
    1908:	88d5      	ldrh	r5, [r2, #6]
    190a:	429d      	cmp	r5, r3
    190c:	d900      	bls.n	1910 <usb_isr+0x10c>
    190e:	001d      	movs	r5, r3
	if (size > EP0_SIZE) size = EP0_SIZE;
    1910:	002f      	movs	r7, r5
    1912:	2d40      	cmp	r5, #64	; 0x40
    1914:	d900      	bls.n	1918 <usb_isr+0x114>
    1916:	2740      	movs	r7, #64	; 0x40
	endpoint0_transmit(data, size);
    1918:	0039      	movs	r1, r7
    191a:	0020      	movs	r0, r4
    191c:	f7ff feb0 	bl	1680 <endpoint0_transmit>
	datalen -= size;
    1920:	1bee      	subs	r6, r5, r7
	if (datalen == 0 && size < EP0_SIZE) return;
    1922:	42bd      	cmp	r5, r7
    1924:	d101      	bne.n	192a <usb_isr+0x126>
    1926:	2d3f      	cmp	r5, #63	; 0x3f
    1928:	d9df      	bls.n	18ea <usb_isr+0xe6>
    192a:	0035      	movs	r5, r6
	data += size;
    192c:	19e4      	adds	r4, r4, r7
	if (size > EP0_SIZE) size = EP0_SIZE;
    192e:	2e40      	cmp	r6, #64	; 0x40
    1930:	d900      	bls.n	1934 <usb_isr+0x130>
    1932:	2540      	movs	r5, #64	; 0x40
	endpoint0_transmit(data, size);
    1934:	0020      	movs	r0, r4
    1936:	0029      	movs	r1, r5
    1938:	f7ff fea2 	bl	1680 <endpoint0_transmit>
	data += size;
    193c:	1964      	adds	r4, r4, r5
	datalen -= size;
    193e:	1b72      	subs	r2, r6, r5
	if (datalen == 0 && size < EP0_SIZE) return;
    1940:	42ae      	cmp	r6, r5
    1942:	d101      	bne.n	1948 <usb_isr+0x144>
    1944:	2e3f      	cmp	r6, #63	; 0x3f
    1946:	d9d0      	bls.n	18ea <usb_isr+0xe6>
	ep0_tx_ptr = data;
    1948:	4b7d      	ldr	r3, [pc, #500]	; (1b40 <usb_isr+0x33c>)
    194a:	601c      	str	r4, [r3, #0]
	ep0_tx_len = datalen;
    194c:	4b80      	ldr	r3, [pc, #512]	; (1b50 <usb_isr+0x34c>)
    194e:	801a      	strh	r2, [r3, #0]
    1950:	e7cb      	b.n	18ea <usb_isr+0xe6>
	switch (setup.wRequestAndType) {
    1952:	4e80      	ldr	r6, [pc, #512]	; (1b54 <usb_isr+0x350>)
    1954:	42b1      	cmp	r1, r6
    1956:	d0c8      	beq.n	18ea <usb_isr+0xe6>
    1958:	d83b      	bhi.n	19d2 <usb_isr+0x1ce>
    195a:	2088      	movs	r0, #136	; 0x88
    195c:	0100      	lsls	r0, r0, #4
    195e:	4281      	cmp	r1, r0
    1960:	d100      	bne.n	1964 <usb_isr+0x160>
    1962:	e095      	b.n	1a90 <usb_isr+0x28c>
    1964:	2390      	movs	r3, #144	; 0x90
    1966:	011b      	lsls	r3, r3, #4
    1968:	4299      	cmp	r1, r3
    196a:	d1bb      	bne.n	18e4 <usb_isr+0xe0>
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    196c:	2504      	movs	r5, #4
			if (table[i].desc & BDT_OWN) {
    196e:	2680      	movs	r6, #128	; 0x80
		usb_configuration = setup.wValue;
    1970:	4b6a      	ldr	r3, [pc, #424]	; (1b1c <usb_isr+0x318>)
    1972:	0c12      	lsrs	r2, r2, #16
    1974:	b2d2      	uxtb	r2, r2
    1976:	701a      	strb	r2, [r3, #0]
			if (table[i].desc & BDT_OWN) {
    1978:	00eb      	lsls	r3, r5, #3
    197a:	58e2      	ldr	r2, [r4, r3]
    197c:	4232      	tst	r2, r6
    197e:	d004      	beq.n	198a <usb_isr+0x186>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    1980:	18e3      	adds	r3, r4, r3
    1982:	6858      	ldr	r0, [r3, #4]
    1984:	3808      	subs	r0, #8
    1986:	f000 fae7 	bl	1f58 <usb_free>
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    198a:	3501      	adds	r5, #1
    198c:	2d14      	cmp	r5, #20
    198e:	d1f3      	bne.n	1978 <usb_isr+0x174>
		for (i=0; i < NUM_ENDPOINTS; i++) {
    1990:	2700      	movs	r7, #0
    1992:	4b71      	ldr	r3, [pc, #452]	; (1b58 <usb_isr+0x354>)
    1994:	4e71      	ldr	r6, [pc, #452]	; (1b5c <usb_isr+0x358>)
    1996:	4d72      	ldr	r5, [pc, #456]	; (1b60 <usb_isr+0x35c>)
    1998:	9300      	str	r3, [sp, #0]
			p = rx_first[i];
    199a:	6830      	ldr	r0, [r6, #0]
			while (p) {
    199c:	2800      	cmp	r0, #0
    199e:	d11e      	bne.n	19de <usb_isr+0x1da>
			rx_first[i] = NULL;
    19a0:	00bb      	lsls	r3, r7, #2
    19a2:	9303      	str	r3, [sp, #12]
			rx_last[i] = NULL;
    19a4:	4b6f      	ldr	r3, [pc, #444]	; (1b64 <usb_isr+0x360>)
    19a6:	00ba      	lsls	r2, r7, #2
			rx_first[i] = NULL;
    19a8:	6030      	str	r0, [r6, #0]
			rx_last[i] = NULL;
    19aa:	50d0      	str	r0, [r2, r3]
			p = tx_first[i];
    19ac:	6828      	ldr	r0, [r5, #0]
			while (p) {
    19ae:	2800      	cmp	r0, #0
    19b0:	d11b      	bne.n	19ea <usb_isr+0x1e6>
			tx_last[i] = NULL;
    19b2:	4b6d      	ldr	r3, [pc, #436]	; (1b68 <usb_isr+0x364>)
    19b4:	9a03      	ldr	r2, [sp, #12]
			tx_first[i] = NULL;
    19b6:	6028      	str	r0, [r5, #0]
			tx_last[i] = NULL;
    19b8:	50d0      	str	r0, [r2, r3]
			usb_rx_byte_count_data[i] = 0;
    19ba:	4b6c      	ldr	r3, [pc, #432]	; (1b6c <usb_isr+0x368>)
    19bc:	007a      	lsls	r2, r7, #1
    19be:	52d0      	strh	r0, [r2, r3]
			switch (tx_state[i]) {
    19c0:	9b00      	ldr	r3, [sp, #0]
    19c2:	7818      	ldrb	r0, [r3, #0]
    19c4:	3802      	subs	r0, #2
    19c6:	2803      	cmp	r0, #3
    19c8:	d818      	bhi.n	19fc <usb_isr+0x1f8>
    19ca:	f000 fd91 	bl	24f0 <__gnu_thumb1_case_uqi>
    19ce:	5114      	.short	0x5114
    19d0:	5114      	.short	0x5114
	switch (setup.wRequestAndType) {
    19d2:	4b67      	ldr	r3, [pc, #412]	; (1b70 <usb_isr+0x36c>)
    19d4:	4299      	cmp	r1, r3
    19d6:	d100      	bne.n	19da <usb_isr+0x1d6>
    19d8:	e0f2      	b.n	1bc0 <usb_isr+0x3bc>
    19da:	4a66      	ldr	r2, [pc, #408]	; (1b74 <usb_isr+0x370>)
    19dc:	e78f      	b.n	18fe <usb_isr+0xfa>
				n = p->next;
    19de:	6843      	ldr	r3, [r0, #4]
    19e0:	9302      	str	r3, [sp, #8]
				usb_free(p);
    19e2:	f000 fab9 	bl	1f58 <usb_free>
				p = n;
    19e6:	9802      	ldr	r0, [sp, #8]
    19e8:	e7d8      	b.n	199c <usb_isr+0x198>
				n = p->next;
    19ea:	6843      	ldr	r3, [r0, #4]
    19ec:	9302      	str	r3, [sp, #8]
				usb_free(p);
    19ee:	f000 fab3 	bl	1f58 <usb_free>
				p = n;
    19f2:	9802      	ldr	r0, [sp, #8]
    19f4:	e7db      	b.n	19ae <usb_isr+0x1aa>
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    19f6:	2300      	movs	r3, #0
    19f8:	9a00      	ldr	r2, [sp, #0]
    19fa:	7013      	strb	r3, [r2, #0]
		for (i=0; i < NUM_ENDPOINTS; i++) {
    19fc:	9b00      	ldr	r3, [sp, #0]
    19fe:	3701      	adds	r7, #1
    1a00:	3301      	adds	r3, #1
    1a02:	3604      	adds	r6, #4
    1a04:	9300      	str	r3, [sp, #0]
    1a06:	3504      	adds	r5, #4
    1a08:	2f04      	cmp	r7, #4
    1a0a:	d1c6      	bne.n	199a <usb_isr+0x196>
		usb_rx_memory_needed = 0;
    1a0c:	2200      	movs	r2, #0
    1a0e:	4b5a      	ldr	r3, [pc, #360]	; (1b78 <usb_isr+0x374>)
    1a10:	4f5a      	ldr	r7, [pc, #360]	; (1b7c <usb_isr+0x378>)
		reg = &USB0_ENDPT1;
    1a12:	4d5b      	ldr	r5, [pc, #364]	; (1b80 <usb_isr+0x37c>)
		usb_rx_memory_needed = 0;
    1a14:	701a      	strb	r2, [r3, #0]
			epconf = *cfg++;
    1a16:	783b      	ldrb	r3, [r7, #0]
			*reg = epconf;
    1a18:	4a5a      	ldr	r2, [pc, #360]	; (1b84 <usb_isr+0x380>)
    1a1a:	702b      	strb	r3, [r5, #0]
			reg += 4;
    1a1c:	3504      	adds	r5, #4
			if (epconf & USB_ENDPT_EPRXEN) {
    1a1e:	18ae      	adds	r6, r5, r2
    1a20:	2208      	movs	r2, #8
    1a22:	4213      	tst	r3, r2
    1a24:	d015      	beq.n	1a52 <usb_isr+0x24e>
				p = usb_malloc();
    1a26:	f000 fa77 	bl	1f18 <usb_malloc>
				if (p) {
    1a2a:	00f3      	lsls	r3, r6, #3
    1a2c:	2800      	cmp	r0, #0
    1a2e:	d023      	beq.n	1a78 <usb_isr+0x274>
					table[index(i, RX, EVEN)].addr = p->buf;
    1a30:	18e2      	adds	r2, r4, r3
    1a32:	3008      	adds	r0, #8
    1a34:	6050      	str	r0, [r2, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    1a36:	4a54      	ldr	r2, [pc, #336]	; (1b88 <usb_isr+0x384>)
    1a38:	50e2      	str	r2, [r4, r3]
				p = usb_malloc();
    1a3a:	f000 fa6d 	bl	1f18 <usb_malloc>
					table[index(i, RX, ODD)].addr = p->buf;
    1a3e:	2301      	movs	r3, #1
    1a40:	4333      	orrs	r3, r6
    1a42:	00db      	lsls	r3, r3, #3
				if (p) {
    1a44:	2800      	cmp	r0, #0
    1a46:	d01d      	beq.n	1a84 <usb_isr+0x280>
					table[index(i, RX, ODD)].addr = p->buf;
    1a48:	18e2      	adds	r2, r4, r3
    1a4a:	3008      	adds	r0, #8
    1a4c:	6050      	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    1a4e:	4a3b      	ldr	r2, [pc, #236]	; (1b3c <usb_isr+0x338>)
    1a50:	50e2      	str	r2, [r4, r3]
			table[index(i, TX, EVEN)].desc = 0;
    1a52:	2302      	movs	r3, #2
    1a54:	2200      	movs	r2, #0
    1a56:	4333      	orrs	r3, r6
    1a58:	00db      	lsls	r3, r3, #3
    1a5a:	50e2      	str	r2, [r4, r3]
			table[index(i, TX, ODD)].desc = 0;
    1a5c:	2303      	movs	r3, #3
    1a5e:	4333      	orrs	r3, r6
    1a60:	00db      	lsls	r3, r3, #3
    1a62:	50e2      	str	r2, [r4, r3]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    1a64:	4b49      	ldr	r3, [pc, #292]	; (1b8c <usb_isr+0x388>)
    1a66:	3701      	adds	r7, #1
    1a68:	429d      	cmp	r5, r3
    1a6a:	d1d4      	bne.n	1a16 <usb_isr+0x212>
	uint32_t datalen = 0;
    1a6c:	2300      	movs	r3, #0
    1a6e:	e050      	b.n	1b12 <usb_isr+0x30e>
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1a70:	2201      	movs	r2, #1
    1a72:	9b00      	ldr	r3, [sp, #0]
    1a74:	701a      	strb	r2, [r3, #0]
				break;
    1a76:	e7c1      	b.n	19fc <usb_isr+0x1f8>
					usb_rx_memory_needed++;
    1a78:	4a3f      	ldr	r2, [pc, #252]	; (1b78 <usb_isr+0x374>)
					table[index(i, RX, EVEN)].desc = 0;
    1a7a:	50e0      	str	r0, [r4, r3]
					usb_rx_memory_needed++;
    1a7c:	7813      	ldrb	r3, [r2, #0]
    1a7e:	3301      	adds	r3, #1
    1a80:	7013      	strb	r3, [r2, #0]
    1a82:	e7da      	b.n	1a3a <usb_isr+0x236>
					usb_rx_memory_needed++;
    1a84:	4a3c      	ldr	r2, [pc, #240]	; (1b78 <usb_isr+0x374>)
					table[index(i, RX, ODD)].desc = 0;
    1a86:	50e0      	str	r0, [r4, r3]
					usb_rx_memory_needed++;
    1a88:	7813      	ldrb	r3, [r2, #0]
    1a8a:	3301      	adds	r3, #1
    1a8c:	7013      	strb	r3, [r2, #0]
    1a8e:	e7e0      	b.n	1a52 <usb_isr+0x24e>
		reply_buffer[0] = usb_configuration;
    1a90:	4a22      	ldr	r2, [pc, #136]	; (1b1c <usb_isr+0x318>)
    1a92:	4c3f      	ldr	r4, [pc, #252]	; (1b90 <usb_isr+0x38c>)
    1a94:	7812      	ldrb	r2, [r2, #0]
    1a96:	7022      	strb	r2, [r4, #0]
		break;
    1a98:	e735      	b.n	1906 <usb_isr+0x102>
		reply_buffer[0] = 0;
    1a9a:	2300      	movs	r3, #0
    1a9c:	4c3c      	ldr	r4, [pc, #240]	; (1b90 <usb_isr+0x38c>)
    1a9e:	7023      	strb	r3, [r4, #0]
		reply_buffer[1] = 0;
    1aa0:	7063      	strb	r3, [r4, #1]
		datalen = 2;
    1aa2:	3302      	adds	r3, #2
		break;
    1aa4:	e72f      	b.n	1906 <usb_isr+0x102>
		i = setup.wIndex & 0x7F;
    1aa6:	237f      	movs	r3, #127	; 0x7f
    1aa8:	4003      	ands	r3, r0
		if (i > NUM_ENDPOINTS) {
    1aaa:	2b04      	cmp	r3, #4
    1aac:	d900      	bls.n	1ab0 <usb_isr+0x2ac>
    1aae:	e719      	b.n	18e4 <usb_isr+0xe0>
		reply_buffer[0] = 0;
    1ab0:	2100      	movs	r1, #0
    1ab2:	4a37      	ldr	r2, [pc, #220]	; (1b90 <usb_isr+0x38c>)
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    1ab4:	009b      	lsls	r3, r3, #2
		reply_buffer[0] = 0;
    1ab6:	7011      	strb	r1, [r2, #0]
		reply_buffer[1] = 0;
    1ab8:	7051      	strb	r1, [r2, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    1aba:	4923      	ldr	r1, [pc, #140]	; (1b48 <usb_isr+0x344>)
		data = reply_buffer;
    1abc:	0014      	movs	r4, r2
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    1abe:	185b      	adds	r3, r3, r1
    1ac0:	2102      	movs	r1, #2
    1ac2:	7818      	ldrb	r0, [r3, #0]
		datalen = 2;
    1ac4:	000b      	movs	r3, r1
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    1ac6:	4208      	tst	r0, r1
    1ac8:	d100      	bne.n	1acc <usb_isr+0x2c8>
    1aca:	e71c      	b.n	1906 <usb_isr+0x102>
    1acc:	3b01      	subs	r3, #1
    1ace:	7013      	strb	r3, [r2, #0]
		datalen = 2;
    1ad0:	000b      	movs	r3, r1
    1ad2:	e718      	b.n	1906 <usb_isr+0x102>
		i = setup.wIndex & 0x7F;
    1ad4:	237f      	movs	r3, #127	; 0x7f
    1ad6:	4003      	ands	r3, r0
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    1ad8:	2b04      	cmp	r3, #4
    1ada:	d900      	bls.n	1ade <usb_isr+0x2da>
    1adc:	e702      	b.n	18e4 <usb_isr+0xe0>
    1ade:	0c12      	lsrs	r2, r2, #16
    1ae0:	d000      	beq.n	1ae4 <usb_isr+0x2e0>
    1ae2:	e6ff      	b.n	18e4 <usb_isr+0xe0>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    1ae4:	2102      	movs	r1, #2
    1ae6:	4a18      	ldr	r2, [pc, #96]	; (1b48 <usb_isr+0x344>)
    1ae8:	009b      	lsls	r3, r3, #2
    1aea:	189b      	adds	r3, r3, r2
    1aec:	781a      	ldrb	r2, [r3, #0]
    1aee:	438a      	bics	r2, r1
			usb_cdc_line_rtsdtr = setup.wValue;
    1af0:	701a      	strb	r2, [r3, #0]
    1af2:	e7bb      	b.n	1a6c <usb_isr+0x268>
		i = setup.wIndex & 0x7F;
    1af4:	217f      	movs	r1, #127	; 0x7f
    1af6:	4001      	ands	r1, r0
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    1af8:	2904      	cmp	r1, #4
    1afa:	d900      	bls.n	1afe <usb_isr+0x2fa>
    1afc:	e6f2      	b.n	18e4 <usb_isr+0xe0>
    1afe:	0c13      	lsrs	r3, r2, #16
    1b00:	d000      	beq.n	1b04 <usb_isr+0x300>
    1b02:	e6ef      	b.n	18e4 <usb_isr+0xe0>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    1b04:	008a      	lsls	r2, r1, #2
    1b06:	4910      	ldr	r1, [pc, #64]	; (1b48 <usb_isr+0x344>)
    1b08:	1852      	adds	r2, r2, r1
    1b0a:	2102      	movs	r1, #2
    1b0c:	7810      	ldrb	r0, [r2, #0]
    1b0e:	4301      	orrs	r1, r0
    1b10:	7011      	strb	r1, [r2, #0]
	const uint8_t *data = NULL;
    1b12:	001c      	movs	r4, r3
			break;
    1b14:	e6f7      	b.n	1906 <usb_isr+0x102>
    1b16:	46c0      	nop			; (mov r8, r8)
    1b18:	40072080 	.word	0x40072080
    1b1c:	20000360 	.word	0x20000360
    1b20:	20000361 	.word	0x20000361
    1b24:	20000388 	.word	0x20000388
    1b28:	40072090 	.word	0x40072090
    1b2c:	1ffff800 	.word	0x1ffff800
    1b30:	40072094 	.word	0x40072094
    1b34:	20000334 	.word	0x20000334
    1b38:	20000305 	.word	0x20000305
    1b3c:	004000c8 	.word	0x004000c8
    1b40:	20000308 	.word	0x20000308
    1b44:	00000681 	.word	0x00000681
    1b48:	400720c0 	.word	0x400720c0
    1b4c:	00000302 	.word	0x00000302
    1b50:	20000306 	.word	0x20000306
    1b54:	00002021 	.word	0x00002021
    1b58:	2000035c 	.word	0x2000035c
    1b5c:	20000314 	.word	0x20000314
    1b60:	2000033c 	.word	0x2000033c
    1b64:	20000324 	.word	0x20000324
    1b68:	2000034c 	.word	0x2000034c
    1b6c:	20000362 	.word	0x20000362
    1b70:	00002221 	.word	0x00002221
    1b74:	00002321 	.word	0x00002321
    1b78:	2000036a 	.word	0x2000036a
    1b7c:	00002b14 	.word	0x00002b14
    1b80:	400720c4 	.word	0x400720c4
    1b84:	bff8df3c 	.word	0xbff8df3c
    1b88:	00400088 	.word	0x00400088
    1b8c:	400720d4 	.word	0x400720d4
    1b90:	2000030c 	.word	0x2000030c
	switch (setup.wRequestAndType) {
    1b94:	4b86      	ldr	r3, [pc, #536]	; (1db0 <usb_isr+0x5ac>)
    1b96:	0c12      	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    1b98:	b280      	uxth	r0, r0
			if (list->addr == NULL) break;
    1b9a:	685c      	ldr	r4, [r3, #4]
    1b9c:	2c00      	cmp	r4, #0
    1b9e:	d100      	bne.n	1ba2 <usb_isr+0x39e>
    1ba0:	e6a0      	b.n	18e4 <usb_isr+0xe0>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    1ba2:	8819      	ldrh	r1, [r3, #0]
    1ba4:	4291      	cmp	r1, r2
    1ba6:	d109      	bne.n	1bbc <usb_isr+0x3b8>
    1ba8:	885d      	ldrh	r5, [r3, #2]
    1baa:	4285      	cmp	r5, r0
    1bac:	d106      	bne.n	1bbc <usb_isr+0x3b8>
				if ((setup.wValue >> 8) == 3) {
    1bae:	0a09      	lsrs	r1, r1, #8
    1bb0:	2903      	cmp	r1, #3
    1bb2:	d101      	bne.n	1bb8 <usb_isr+0x3b4>
					datalen = *(list->addr);
    1bb4:	7823      	ldrb	r3, [r4, #0]
    1bb6:	e6a6      	b.n	1906 <usb_isr+0x102>
					datalen = list->length;
    1bb8:	891b      	ldrh	r3, [r3, #8]
    1bba:	e6a4      	b.n	1906 <usb_isr+0x102>
		for (list = usb_descriptor_list; 1; list++) {
    1bbc:	330c      	adds	r3, #12
			if (list->addr == NULL) break;
    1bbe:	e7ec      	b.n	1b9a <usb_isr+0x396>
		switch (setup.wIndex) {
    1bc0:	b280      	uxth	r0, r0
    1bc2:	2800      	cmp	r0, #0
    1bc4:	d000      	beq.n	1bc8 <usb_isr+0x3c4>
    1bc6:	e751      	b.n	1a6c <usb_isr+0x268>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    1bc8:	4b7a      	ldr	r3, [pc, #488]	; (1db4 <usb_isr+0x5b0>)
			usb_cdc_line_rtsdtr = setup.wValue;
    1bca:	0c12      	lsrs	r2, r2, #16
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    1bcc:	6819      	ldr	r1, [r3, #0]
    1bce:	4b7a      	ldr	r3, [pc, #488]	; (1db8 <usb_isr+0x5b4>)
			usb_cdc_line_rtsdtr = setup.wValue;
    1bd0:	b2d2      	uxtb	r2, r2
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    1bd2:	6019      	str	r1, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    1bd4:	4b79      	ldr	r3, [pc, #484]	; (1dbc <usb_isr+0x5b8>)
    1bd6:	e78b      	b.n	1af0 <usb_isr+0x2ec>
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    1bd8:	4b79      	ldr	r3, [pc, #484]	; (1dc0 <usb_isr+0x5bc>)
    1bda:	4a7a      	ldr	r2, [pc, #488]	; (1dc4 <usb_isr+0x5c0>)
    1bdc:	8818      	ldrh	r0, [r3, #0]
    1bde:	4290      	cmp	r0, r2
    1be0:	d112      	bne.n	1c08 <usb_isr+0x404>
			switch (setup.wIndex) {
    1be2:	889b      	ldrh	r3, [r3, #4]
    1be4:	2b00      	cmp	r3, #0
    1be6:	d10b      	bne.n	1c00 <usb_isr+0x3fc>
					*dst++ = *buf++;
    1be8:	4a77      	ldr	r2, [pc, #476]	; (1dc8 <usb_isr+0x5c4>)
    1bea:	5cc8      	ldrb	r0, [r1, r3]
    1bec:	54d0      	strb	r0, [r2, r3]
				for (i=0; i<7; i++) {
    1bee:	3301      	adds	r3, #1
    1bf0:	2b07      	cmp	r3, #7
    1bf2:	d1fa      	bne.n	1bea <usb_isr+0x3e6>
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    1bf4:	6813      	ldr	r3, [r2, #0]
    1bf6:	2b86      	cmp	r3, #134	; 0x86
    1bf8:	d102      	bne.n	1c00 <usb_isr+0x3fc>
    1bfa:	220f      	movs	r2, #15
    1bfc:	4b73      	ldr	r3, [pc, #460]	; (1dcc <usb_isr+0x5c8>)
    1bfe:	701a      	strb	r2, [r3, #0]
			endpoint0_transmit(NULL, 0);
    1c00:	2100      	movs	r1, #0
    1c02:	0008      	movs	r0, r1
    1c04:	f7ff fd3c 	bl	1680 <endpoint0_transmit>
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    1c08:	4b71      	ldr	r3, [pc, #452]	; (1dd0 <usb_isr+0x5cc>)
    1c0a:	6033      	str	r3, [r6, #0]
		break;
    1c0c:	e63d      	b.n	188a <usb_isr+0x86>
		data = ep0_tx_ptr;
    1c0e:	4f71      	ldr	r7, [pc, #452]	; (1dd4 <usb_isr+0x5d0>)
    1c10:	683c      	ldr	r4, [r7, #0]
		if (data) {
    1c12:	2c00      	cmp	r4, #0
    1c14:	d019      	beq.n	1c4a <usb_isr+0x446>
			size = ep0_tx_len;
    1c16:	4b70      	ldr	r3, [pc, #448]	; (1dd8 <usb_isr+0x5d4>)
    1c18:	881d      	ldrh	r5, [r3, #0]
    1c1a:	9300      	str	r3, [sp, #0]
    1c1c:	002e      	movs	r6, r5
    1c1e:	2d40      	cmp	r5, #64	; 0x40
    1c20:	d900      	bls.n	1c24 <usb_isr+0x420>
    1c22:	2640      	movs	r6, #64	; 0x40
			endpoint0_transmit(data, size);
    1c24:	0020      	movs	r0, r4
    1c26:	0031      	movs	r1, r6
    1c28:	f7ff fd2a 	bl	1680 <endpoint0_transmit>
			data += size;
    1c2c:	19a4      	adds	r4, r4, r6
			ep0_tx_len -= size;
    1c2e:	1c2b      	adds	r3, r5, #0
    1c30:	2d40      	cmp	r5, #64	; 0x40
    1c32:	d900      	bls.n	1c36 <usb_isr+0x432>
    1c34:	2340      	movs	r3, #64	; 0x40
    1c36:	9a00      	ldr	r2, [sp, #0]
    1c38:	1aeb      	subs	r3, r5, r3
    1c3a:	b29b      	uxth	r3, r3
    1c3c:	8013      	strh	r3, [r2, #0]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    1c3e:	2b00      	cmp	r3, #0
    1c40:	d102      	bne.n	1c48 <usb_isr+0x444>
    1c42:	2d3f      	cmp	r5, #63	; 0x3f
    1c44:	d800      	bhi.n	1c48 <usb_isr+0x444>
    1c46:	001c      	movs	r4, r3
    1c48:	603c      	str	r4, [r7, #0]
		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    1c4a:	22a0      	movs	r2, #160	; 0xa0
    1c4c:	4b5c      	ldr	r3, [pc, #368]	; (1dc0 <usb_isr+0x5bc>)
    1c4e:	00d2      	lsls	r2, r2, #3
    1c50:	8819      	ldrh	r1, [r3, #0]
    1c52:	4291      	cmp	r1, r2
    1c54:	d000      	beq.n	1c58 <usb_isr+0x454>
    1c56:	e618      	b.n	188a <usb_isr+0x86>
			setup.bRequest = 0;
    1c58:	2200      	movs	r2, #0
    1c5a:	705a      	strb	r2, [r3, #1]
			USB0_ADDR = setup.wValue;
    1c5c:	789a      	ldrb	r2, [r3, #2]
    1c5e:	4b5f      	ldr	r3, [pc, #380]	; (1ddc <usb_isr+0x5d8>)
    1c60:	e645      	b.n	18ee <usb_isr+0xea>
			if (stat & 0x08) { // transmit
    1c62:	2208      	movs	r2, #8
    1c64:	2108      	movs	r1, #8
			bdt_t *b = stat2bufferdescriptor(stat);
    1c66:	19a4      	adds	r4, r4, r6
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    1c68:	6860      	ldr	r0, [r4, #4]
			endpoint--;	// endpoint is index to zero-based arrays
    1c6a:	3d01      	subs	r5, #1
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    1c6c:	3808      	subs	r0, #8
			endpoint--;	// endpoint is index to zero-based arrays
    1c6e:	b2ed      	uxtb	r5, r5
			if (stat & 0x08) { // transmit
    1c70:	401a      	ands	r2, r3
    1c72:	420b      	tst	r3, r1
    1c74:	d035      	beq.n	1ce2 <usb_isr+0x4de>
				usb_free(packet);
    1c76:	f000 f96f 	bl	1f58 <usb_free>
				packet = tx_first[endpoint];
    1c7a:	4959      	ldr	r1, [pc, #356]	; (1de0 <usb_isr+0x5dc>)
    1c7c:	00a8      	lsls	r0, r5, #2
    1c7e:	5842      	ldr	r2, [r0, r1]
				if (packet) {
    1c80:	4b58      	ldr	r3, [pc, #352]	; (1de4 <usb_isr+0x5e0>)
    1c82:	2a00      	cmp	r2, #0
    1c84:	d01c      	beq.n	1cc0 <usb_isr+0x4bc>
					tx_first[endpoint] = packet->next;
    1c86:	6856      	ldr	r6, [r2, #4]
    1c88:	5046      	str	r6, [r0, r1]
					b->addr = packet->buf;
    1c8a:	0011      	movs	r1, r2
					switch (tx_state[endpoint]) {
    1c8c:	5d58      	ldrb	r0, [r3, r5]
					b->addr = packet->buf;
    1c8e:	3108      	adds	r1, #8
    1c90:	6061      	str	r1, [r4, #4]
					switch (tx_state[endpoint]) {
    1c92:	2803      	cmp	r0, #3
    1c94:	d805      	bhi.n	1ca2 <usb_isr+0x49e>
    1c96:	f000 fc2b 	bl	24f0 <__gnu_thumb1_case_uqi>
    1c9a:	0d02      	.short	0x0d02
    1c9c:	110f      	.short	0x110f
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    1c9e:	2103      	movs	r1, #3
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    1ca0:	5559      	strb	r1, [r3, r5]
					b->desc = BDT_DESC(packet->len,
    1ca2:	21c8      	movs	r1, #200	; 0xc8
    1ca4:	0723      	lsls	r3, r4, #28
    1ca6:	d400      	bmi.n	1caa <usb_isr+0x4a6>
    1ca8:	3940      	subs	r1, #64	; 0x40
    1caa:	8813      	ldrh	r3, [r2, #0]
    1cac:	041b      	lsls	r3, r3, #16
    1cae:	430b      	orrs	r3, r1
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    1cb0:	6023      	str	r3, [r4, #0]
    1cb2:	e5ed      	b.n	1890 <usb_isr+0x8c>
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    1cb4:	2102      	movs	r1, #2
    1cb6:	e7f3      	b.n	1ca0 <usb_isr+0x49c>
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    1cb8:	2105      	movs	r1, #5
    1cba:	e7f1      	b.n	1ca0 <usb_isr+0x49c>
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    1cbc:	2104      	movs	r1, #4
    1cbe:	e7ef      	b.n	1ca0 <usb_isr+0x49c>
					switch (tx_state[endpoint]) {
    1cc0:	5d59      	ldrb	r1, [r3, r5]
    1cc2:	2902      	cmp	r1, #2
    1cc4:	d00b      	beq.n	1cde <usb_isr+0x4da>
    1cc6:	d800      	bhi.n	1cca <usb_isr+0x4c6>
    1cc8:	e5e2      	b.n	1890 <usb_isr+0x8c>
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1cca:	2201      	movs	r2, #1
					switch (tx_state[endpoint]) {
    1ccc:	2903      	cmp	r1, #3
    1cce:	d006      	beq.n	1cde <usb_isr+0x4da>
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    1cd0:	2208      	movs	r2, #8
    1cd2:	4014      	ands	r4, r2
    1cd4:	1e62      	subs	r2, r4, #1
    1cd6:	4194      	sbcs	r4, r2
    1cd8:	3402      	adds	r4, #2
    1cda:	555c      	strb	r4, [r3, r5]
						break;
    1cdc:	e5d8      	b.n	1890 <usb_isr+0x8c>
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1cde:	555a      	strb	r2, [r3, r5]
						break;
    1ce0:	e5d6      	b.n	1890 <usb_isr+0x8c>
				packet->len = b->desc >> 16;
    1ce2:	6823      	ldr	r3, [r4, #0]
    1ce4:	0c19      	lsrs	r1, r3, #16
    1ce6:	1e0b      	subs	r3, r1, #0
    1ce8:	8001      	strh	r1, [r0, #0]
				if (packet->len > 0) {
    1cea:	d014      	beq.n	1d16 <usb_isr+0x512>
					if (rx_first[endpoint] == NULL) {
    1cec:	4e3e      	ldr	r6, [pc, #248]	; (1de8 <usb_isr+0x5e4>)
					packet->index = 0;
    1cee:	8042      	strh	r2, [r0, #2]
					packet->next = NULL;
    1cf0:	6042      	str	r2, [r0, #4]
					if (rx_first[endpoint] == NULL) {
    1cf2:	00aa      	lsls	r2, r5, #2
    1cf4:	5997      	ldr	r7, [r2, r6]
    1cf6:	493d      	ldr	r1, [pc, #244]	; (1dec <usb_isr+0x5e8>)
    1cf8:	2f00      	cmp	r7, #0
    1cfa:	d113      	bne.n	1d24 <usb_isr+0x520>
						rx_first[endpoint] = packet;
    1cfc:	5190      	str	r0, [r2, r6]
					rx_last[endpoint] = packet;
    1cfe:	5088      	str	r0, [r1, r2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    1d00:	4a3b      	ldr	r2, [pc, #236]	; (1df0 <usb_isr+0x5ec>)
    1d02:	006d      	lsls	r5, r5, #1
    1d04:	5aa9      	ldrh	r1, [r5, r2]
    1d06:	185b      	adds	r3, r3, r1
    1d08:	52ab      	strh	r3, [r5, r2]
					packet = usb_malloc();
    1d0a:	f000 f905 	bl	1f18 <usb_malloc>
					if (packet) {
    1d0e:	2800      	cmp	r0, #0
    1d10:	d00b      	beq.n	1d2a <usb_isr+0x526>
						b->addr = packet->buf;
    1d12:	3008      	adds	r0, #8
    1d14:	6060      	str	r0, [r4, #4]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    1d16:	2240      	movs	r2, #64	; 0x40
    1d18:	0723      	lsls	r3, r4, #28
    1d1a:	17db      	asrs	r3, r3, #31
    1d1c:	4013      	ands	r3, r2
    1d1e:	4a35      	ldr	r2, [pc, #212]	; (1df4 <usb_isr+0x5f0>)
    1d20:	189b      	adds	r3, r3, r2
    1d22:	e7c5      	b.n	1cb0 <usb_isr+0x4ac>
						rx_last[endpoint]->next = packet;
    1d24:	588e      	ldr	r6, [r1, r2]
    1d26:	6070      	str	r0, [r6, #4]
    1d28:	e7e9      	b.n	1cfe <usb_isr+0x4fa>
						usb_rx_memory_needed++;
    1d2a:	4a33      	ldr	r2, [pc, #204]	; (1df8 <usb_isr+0x5f4>)
						b->desc = 0;
    1d2c:	6020      	str	r0, [r4, #0]
						usb_rx_memory_needed++;
    1d2e:	7813      	ldrb	r3, [r2, #0]
    1d30:	3301      	adds	r3, #1
    1d32:	7013      	strb	r3, [r2, #0]
    1d34:	e5ac      	b.n	1890 <usb_isr+0x8c>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    1d36:	2001      	movs	r0, #1
    1d38:	4204      	tst	r4, r0
    1d3a:	d020      	beq.n	1d7e <usb_isr+0x57a>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    1d3c:	2302      	movs	r3, #2
    1d3e:	492f      	ldr	r1, [pc, #188]	; (1dfc <usb_isr+0x5f8>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    1d40:	4c2c      	ldr	r4, [pc, #176]	; (1df4 <usb_isr+0x5f0>)
		USB0_CTL = USB_CTL_ODDRST;
    1d42:	700b      	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    1d44:	4b2e      	ldr	r3, [pc, #184]	; (1e00 <usb_isr+0x5fc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    1d46:	4d2f      	ldr	r5, [pc, #188]	; (1e04 <usb_isr+0x600>)
		ep0_tx_bdt_bank = 0;
    1d48:	701a      	strb	r2, [r3, #0]
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    1d4a:	4b2f      	ldr	r3, [pc, #188]	; (1e08 <usb_isr+0x604>)
    1d4c:	601c      	str	r4, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    1d4e:	605d      	str	r5, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    1d50:	609c      	str	r4, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    1d52:	4c2e      	ldr	r4, [pc, #184]	; (1e0c <usb_isr+0x608>)
    1d54:	60dc      	str	r4, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1d56:	240d      	movs	r4, #13
		table[index(0, TX, EVEN)].desc = 0;
    1d58:	611a      	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    1d5a:	619a      	str	r2, [r3, #24]
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1d5c:	4b2c      	ldr	r3, [pc, #176]	; (1e10 <usb_isr+0x60c>)
    1d5e:	701c      	strb	r4, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    1d60:	23ff      	movs	r3, #255	; 0xff
    1d62:	4c2c      	ldr	r4, [pc, #176]	; (1e14 <usb_isr+0x610>)
    1d64:	7023      	strb	r3, [r4, #0]
		USB0_ISTAT = 0xFF;
    1d66:	4c2c      	ldr	r4, [pc, #176]	; (1e18 <usb_isr+0x614>)
    1d68:	7023      	strb	r3, [r4, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    1d6a:	4c1c      	ldr	r4, [pc, #112]	; (1ddc <usb_isr+0x5d8>)
    1d6c:	7022      	strb	r2, [r4, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    1d6e:	4a2b      	ldr	r2, [pc, #172]	; (1e1c <usb_isr+0x618>)
    1d70:	7013      	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    1d72:	229f      	movs	r2, #159	; 0x9f
    1d74:	4b2a      	ldr	r3, [pc, #168]	; (1e20 <usb_isr+0x61c>)
    1d76:	701a      	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    1d78:	7008      	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    1d7a:	b005      	add	sp, #20
    1d7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    1d7e:	b263      	sxtb	r3, r4
    1d80:	2b00      	cmp	r3, #0
    1d82:	da05      	bge.n	1d90 <usb_isr+0x58c>
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1d84:	220d      	movs	r2, #13
    1d86:	4b22      	ldr	r3, [pc, #136]	; (1e10 <usb_isr+0x60c>)
    1d88:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    1d8a:	2380      	movs	r3, #128	; 0x80
    1d8c:	4a22      	ldr	r2, [pc, #136]	; (1e18 <usb_isr+0x614>)
    1d8e:	7013      	strb	r3, [r2, #0]
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    1d90:	2202      	movs	r2, #2
    1d92:	4214      	tst	r4, r2
    1d94:	d005      	beq.n	1da2 <usb_isr+0x59e>
		uint8_t err = USB0_ERRSTAT;
    1d96:	491f      	ldr	r1, [pc, #124]	; (1e14 <usb_isr+0x610>)
    1d98:	780b      	ldrb	r3, [r1, #0]
    1d9a:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    1d9c:	700b      	strb	r3, [r1, #0]
		USB0_ISTAT = USB_ISTAT_ERROR;
    1d9e:	4b1e      	ldr	r3, [pc, #120]	; (1e18 <usb_isr+0x614>)
    1da0:	701a      	strb	r2, [r3, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    1da2:	2310      	movs	r3, #16
    1da4:	421c      	tst	r4, r3
    1da6:	d0e8      	beq.n	1d7a <usb_isr+0x576>
		USB0_ISTAT = USB_ISTAT_SLEEP;
    1da8:	4a1b      	ldr	r2, [pc, #108]	; (1e18 <usb_isr+0x614>)
    1daa:	7013      	strb	r3, [r2, #0]
    1dac:	e7e5      	b.n	1d7a <usb_isr+0x576>
    1dae:	46c0      	nop			; (mov r8, r8)
    1db0:	00002ac0 	.word	0x00002ac0
    1db4:	200000d4 	.word	0x200000d4
    1db8:	20000384 	.word	0x20000384
    1dbc:	20000380 	.word	0x20000380
    1dc0:	20000334 	.word	0x20000334
    1dc4:	00002021 	.word	0x00002021
    1dc8:	20000378 	.word	0x20000378
    1dcc:	20000361 	.word	0x20000361
    1dd0:	004000c8 	.word	0x004000c8
    1dd4:	20000308 	.word	0x20000308
    1dd8:	20000306 	.word	0x20000306
    1ddc:	40072098 	.word	0x40072098
    1de0:	2000033c 	.word	0x2000033c
    1de4:	2000035c 	.word	0x2000035c
    1de8:	20000314 	.word	0x20000314
    1dec:	20000324 	.word	0x20000324
    1df0:	20000362 	.word	0x20000362
    1df4:	00400088 	.word	0x00400088
    1df8:	2000036a 	.word	0x2000036a
    1dfc:	40072094 	.word	0x40072094
    1e00:	20000304 	.word	0x20000304
    1e04:	20000284 	.word	0x20000284
    1e08:	1ffff800 	.word	0x1ffff800
    1e0c:	200002c4 	.word	0x200002c4
    1e10:	400720c0 	.word	0x400720c0
    1e14:	40072088 	.word	0x40072088
    1e18:	40072080 	.word	0x40072080
    1e1c:	4007208c 	.word	0x4007208c
    1e20:	40072084 	.word	0x40072084

00001e24 <usb_init>:



void usb_init(void)
{
    1e24:	b510      	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    1e26:	f000 fb29 	bl	247c <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    1e2a:	2200      	movs	r2, #0
		table[i].desc = 0;
    1e2c:	0010      	movs	r0, r2
    1e2e:	4b1a      	ldr	r3, [pc, #104]	; (1e98 <usb_init+0x74>)
    1e30:	00d1      	lsls	r1, r2, #3
    1e32:	50c8      	str	r0, [r1, r3]
	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    1e34:	3201      	adds	r2, #1
		table[i].addr = 0;
    1e36:	1859      	adds	r1, r3, r1
    1e38:	6048      	str	r0, [r1, #4]
	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    1e3a:	2a14      	cmp	r2, #20
    1e3c:	d1f8      	bne.n	1e30 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    1e3e:	2280      	movs	r2, #128	; 0x80
    1e40:	4916      	ldr	r1, [pc, #88]	; (1e9c <usb_init+0x78>)
    1e42:	02d2      	lsls	r2, r2, #11
    1e44:	680c      	ldr	r4, [r1, #0]
    1e46:	4322      	orrs	r2, r4
    1e48:	600a      	str	r2, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    1e4a:	4915      	ldr	r1, [pc, #84]	; (1ea0 <usb_init+0x7c>)
    1e4c:	0a1a      	lsrs	r2, r3, #8
    1e4e:	b2d2      	uxtb	r2, r2
    1e50:	700a      	strb	r2, [r1, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    1e52:	4914      	ldr	r1, [pc, #80]	; (1ea4 <usb_init+0x80>)
    1e54:	0c1a      	lsrs	r2, r3, #16
    1e56:	b2d2      	uxtb	r2, r2
    1e58:	700a      	strb	r2, [r1, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    1e5a:	4a13      	ldr	r2, [pc, #76]	; (1ea8 <usb_init+0x84>)
    1e5c:	0e1b      	lsrs	r3, r3, #24
    1e5e:	7013      	strb	r3, [r2, #0]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    1e60:	23ff      	movs	r3, #255	; 0xff
    1e62:	4a12      	ldr	r2, [pc, #72]	; (1eac <usb_init+0x88>)
	USB0_OTGISTAT = 0xFF;

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    1e64:	4912      	ldr	r1, [pc, #72]	; (1eb0 <usb_init+0x8c>)
	USB0_ISTAT = 0xFF;
    1e66:	7013      	strb	r3, [r2, #0]
	USB0_ERRSTAT = 0xFF;
    1e68:	4a12      	ldr	r2, [pc, #72]	; (1eb4 <usb_init+0x90>)
    1e6a:	7013      	strb	r3, [r2, #0]
	USB0_OTGISTAT = 0xFF;
    1e6c:	4a12      	ldr	r2, [pc, #72]	; (1eb8 <usb_init+0x94>)
    1e6e:	7013      	strb	r3, [r2, #0]
	USB0_CTL = USB_CTL_USBENSOFEN;
    1e70:	2201      	movs	r2, #1
    1e72:	700a      	strb	r2, [r1, #0]
	USB0_USBCTRL = 0;
    1e74:	4911      	ldr	r1, [pc, #68]	; (1ebc <usb_init+0x98>)
    1e76:	7008      	strb	r0, [r1, #0]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    1e78:	4911      	ldr	r1, [pc, #68]	; (1ec0 <usb_init+0x9c>)
    1e7a:	700a      	strb	r2, [r1, #0]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    1e7c:	4911      	ldr	r1, [pc, #68]	; (1ec4 <usb_init+0xa0>)
    1e7e:	680a      	ldr	r2, [r1, #0]
    1e80:	439a      	bics	r2, r3
    1e82:	3b8f      	subs	r3, #143	; 0x8f
    1e84:	4313      	orrs	r3, r2
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    1e86:	2280      	movs	r2, #128	; 0x80
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    1e88:	600b      	str	r3, [r1, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    1e8a:	4b0f      	ldr	r3, [pc, #60]	; (1ec8 <usb_init+0xa4>)
    1e8c:	0452      	lsls	r2, r2, #17
    1e8e:	601a      	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    1e90:	2210      	movs	r2, #16
    1e92:	4b0e      	ldr	r3, [pc, #56]	; (1ecc <usb_init+0xa8>)
    1e94:	701a      	strb	r2, [r3, #0]
}
    1e96:	bd10      	pop	{r4, pc}
    1e98:	1ffff800 	.word	0x1ffff800
    1e9c:	40048034 	.word	0x40048034
    1ea0:	4007209c 	.word	0x4007209c
    1ea4:	400720b0 	.word	0x400720b0
    1ea8:	400720b4 	.word	0x400720b4
    1eac:	40072080 	.word	0x40072080
    1eb0:	40072094 	.word	0x40072094
    1eb4:	40072088 	.word	0x40072088
    1eb8:	40072010 	.word	0x40072010
    1ebc:	40072100 	.word	0x40072100
    1ec0:	40072084 	.word	0x40072084
    1ec4:	e000e418 	.word	0xe000e418
    1ec8:	e000e100 	.word	0xe000e100
    1ecc:	40072108 	.word	0x40072108

00001ed0 <usb_serial_class::clear()>:
        virtual void clear(void) { usb_serial_flush_input(); }
    1ed0:	b510      	push	{r4, lr}
    1ed2:	f000 f8c5 	bl	2060 <usb_serial_flush_input>
    1ed6:	bd10      	pop	{r4, pc}

00001ed8 <usb_serial_class::peek()>:
        virtual int peek() { return usb_serial_peekchar(); }
    1ed8:	b510      	push	{r4, lr}
    1eda:	f000 f88d 	bl	1ff8 <usb_serial_peekchar>
    1ede:	bd10      	pop	{r4, pc}

00001ee0 <usb_serial_class::read()>:
        virtual int read() { return usb_serial_getchar(); }
    1ee0:	b510      	push	{r4, lr}
    1ee2:	f000 f861 	bl	1fa8 <usb_serial_getchar>
    1ee6:	bd10      	pop	{r4, pc}

00001ee8 <usb_serial_class::available()>:
        virtual int available() { return usb_serial_available(); }
    1ee8:	b510      	push	{r4, lr}
    1eea:	f000 f8a3 	bl	2034 <usb_serial_available>
    1eee:	bd10      	pop	{r4, pc}

00001ef0 <usb_serial_class::flush()>:
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    1ef0:	b510      	push	{r4, lr}
    1ef2:	f000 f969 	bl	21c8 <usb_serial_flush_output>
    1ef6:	bd10      	pop	{r4, pc}

00001ef8 <usb_serial_class::availableForWrite()>:
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    1ef8:	b510      	push	{r4, lr}
    1efa:	f000 f93f 	bl	217c <usb_serial_write_buffer_free>
    1efe:	bd10      	pop	{r4, pc}

00001f00 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1f00:	b510      	push	{r4, lr}
    1f02:	0008      	movs	r0, r1
    1f04:	0011      	movs	r1, r2
    1f06:	f000 f8c5 	bl	2094 <usb_serial_write>
    1f0a:	bd10      	pop	{r4, pc}

00001f0c <usb_serial_class::write(unsigned char)>:
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    1f0c:	b510      	push	{r4, lr}
    1f0e:	0008      	movs	r0, r1
    1f10:	f000 f92a 	bl	2168 <usb_serial_putchar>
    1f14:	bd10      	pop	{r4, pc}
    1f16:	Address 0x00001f16 is out of bounds.


00001f18 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    1f18:	b570      	push	{r4, r5, r6, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    1f1a:	b672      	cpsid	i
	avail = usb_buffer_available;
    1f1c:	4d0c      	ldr	r5, [pc, #48]	; (1f50 <usb_malloc+0x38>)
    1f1e:	682c      	ldr	r4, [r5, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    1f20:	0020      	movs	r0, r4
    1f22:	f000 fb7b 	bl	261c <__clzsi2>
    1f26:	0003      	movs	r3, r0
	if (n >= NUM_USB_BUFFERS) {
    1f28:	280b      	cmp	r0, #11
    1f2a:	dd02      	ble.n	1f32 <usb_malloc+0x1a>
		__enable_irq();
    1f2c:	b662      	cpsie	i
		return NULL;
    1f2e:	2000      	movs	r0, #0
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
}
    1f30:	bd70      	pop	{r4, r5, r6, pc}
	usb_buffer_available = avail & ~(0x80000000 >> n);
    1f32:	2280      	movs	r2, #128	; 0x80
    1f34:	0612      	lsls	r2, r2, #24
    1f36:	40c2      	lsrs	r2, r0
    1f38:	4394      	bics	r4, r2
    1f3a:	602c      	str	r4, [r5, #0]
	__enable_irq();
    1f3c:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    1f3e:	2048      	movs	r0, #72	; 0x48
    1f40:	4358      	muls	r0, r3
    1f42:	4b04      	ldr	r3, [pc, #16]	; (1f54 <usb_malloc+0x3c>)
    1f44:	18c0      	adds	r0, r0, r3
	*(uint32_t *)p = 0;
    1f46:	2300      	movs	r3, #0
    1f48:	6003      	str	r3, [r0, #0]
	*(uint32_t *)(p + 4) = 0;
    1f4a:	6043      	str	r3, [r0, #4]
	return (usb_packet_t *)p;
    1f4c:	e7f0      	b.n	1f30 <usb_malloc+0x18>
    1f4e:	46c0      	nop			; (mov r8, r8)
    1f50:	1ffffdd4 	.word	0x1ffffdd4
    1f54:	1ffff9c0 	.word	0x1ffff9c0

00001f58 <usb_free>:
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
	if (n >= NUM_USB_BUFFERS) return;
    1f58:	22d8      	movs	r2, #216	; 0xd8
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    1f5a:	4b0f      	ldr	r3, [pc, #60]	; (1f98 <usb_free+0x40>)
{
    1f5c:	b510      	push	{r4, lr}
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    1f5e:	1ac3      	subs	r3, r0, r3
	if (n >= NUM_USB_BUFFERS) return;
    1f60:	0092      	lsls	r2, r2, #2
    1f62:	4293      	cmp	r3, r2
    1f64:	d209      	bcs.n	1f7a <usb_free+0x22>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    1f66:	4a0d      	ldr	r2, [pc, #52]	; (1f9c <usb_free+0x44>)
    1f68:	7812      	ldrb	r2, [r2, #0]
    1f6a:	2a00      	cmp	r2, #0
    1f6c:	d006      	beq.n	1f7c <usb_free+0x24>
    1f6e:	4a0c      	ldr	r2, [pc, #48]	; (1fa0 <usb_free+0x48>)
    1f70:	7812      	ldrb	r2, [r2, #0]
    1f72:	2a00      	cmp	r2, #0
    1f74:	d002      	beq.n	1f7c <usb_free+0x24>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    1f76:	f7ff fbcd 	bl	1714 <usb_rx_memory>
	__enable_irq();

	//serial_print("free:");
	//serial_phex32((int)p);
	//serial_print("\n");
}
    1f7a:	bd10      	pop	{r4, pc}
	__disable_irq();
    1f7c:	b672      	cpsid	i
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    1f7e:	2148      	movs	r1, #72	; 0x48
    1f80:	0018      	movs	r0, r3
    1f82:	f000 fabf 	bl	2504 <__udivsi3>
	mask = (0x80000000 >> n);
    1f86:	2380      	movs	r3, #128	; 0x80
    1f88:	061b      	lsls	r3, r3, #24
    1f8a:	40c3      	lsrs	r3, r0
	usb_buffer_available |= mask;
    1f8c:	4c05      	ldr	r4, [pc, #20]	; (1fa4 <usb_free+0x4c>)
    1f8e:	6822      	ldr	r2, [r4, #0]
    1f90:	4313      	orrs	r3, r2
    1f92:	6023      	str	r3, [r4, #0]
	__enable_irq();
    1f94:	b662      	cpsie	i
    1f96:	e7f0      	b.n	1f7a <usb_free+0x22>
    1f98:	1ffff9c0 	.word	0x1ffff9c0
    1f9c:	2000036a 	.word	0x2000036a
    1fa0:	20000360 	.word	0x20000360
    1fa4:	1ffffdd4 	.word	0x1ffffdd4

00001fa8 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    1fa8:	b570      	push	{r4, r5, r6, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    1faa:	4c11      	ldr	r4, [pc, #68]	; (1ff0 <usb_serial_getchar+0x48>)
    1fac:	6823      	ldr	r3, [r4, #0]
    1fae:	2b00      	cmp	r3, #0
    1fb0:	d00c      	beq.n	1fcc <usb_serial_getchar+0x24>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    1fb2:	6820      	ldr	r0, [r4, #0]
    1fb4:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    1fb6:	18c2      	adds	r2, r0, r3
    1fb8:	7a15      	ldrb	r5, [r2, #8]
	if (i >= rx_packet->len) {
    1fba:	8802      	ldrh	r2, [r0, #0]
	c = rx_packet->buf[i++];
    1fbc:	3301      	adds	r3, #1
	if (i >= rx_packet->len) {
    1fbe:	429a      	cmp	r2, r3
    1fc0:	d813      	bhi.n	1fea <usb_serial_getchar+0x42>
		usb_free(rx_packet);
    1fc2:	f7ff ffc9 	bl	1f58 <usb_free>
		rx_packet = NULL;
    1fc6:	2300      	movs	r3, #0
    1fc8:	6023      	str	r3, [r4, #0]
    1fca:	e005      	b.n	1fd8 <usb_serial_getchar+0x30>
		if (!usb_configuration) return -1;
    1fcc:	4b09      	ldr	r3, [pc, #36]	; (1ff4 <usb_serial_getchar+0x4c>)
    1fce:	781b      	ldrb	r3, [r3, #0]
    1fd0:	2b00      	cmp	r3, #0
    1fd2:	d103      	bne.n	1fdc <usb_serial_getchar+0x34>
    1fd4:	2501      	movs	r5, #1
    1fd6:	426d      	negs	r5, r5
	} else {
		rx_packet->index = i;
	}
	return c;
}
    1fd8:	0028      	movs	r0, r5
    1fda:	bd70      	pop	{r4, r5, r6, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    1fdc:	2003      	movs	r0, #3
    1fde:	f7ff fb6d 	bl	16bc <usb_rx>
    1fe2:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    1fe4:	2800      	cmp	r0, #0
    1fe6:	d1e4      	bne.n	1fb2 <usb_serial_getchar+0xa>
    1fe8:	e7f4      	b.n	1fd4 <usb_serial_getchar+0x2c>
		rx_packet->index = i;
    1fea:	8043      	strh	r3, [r0, #2]
    1fec:	e7f4      	b.n	1fd8 <usb_serial_getchar+0x30>
    1fee:	46c0      	nop			; (mov r8, r8)
    1ff0:	2000036c 	.word	0x2000036c
    1ff4:	20000360 	.word	0x20000360

00001ff8 <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    1ff8:	b510      	push	{r4, lr}
	if (!rx_packet) {
    1ffa:	4c0c      	ldr	r4, [pc, #48]	; (202c <usb_serial_peekchar+0x34>)
    1ffc:	6823      	ldr	r3, [r4, #0]
    1ffe:	2b00      	cmp	r3, #0
    2000:	d005      	beq.n	200e <usb_serial_peekchar+0x16>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    2002:	6823      	ldr	r3, [r4, #0]
    2004:	2b00      	cmp	r3, #0
    2006:	d10d      	bne.n	2024 <usb_serial_peekchar+0x2c>
		if (!usb_configuration) return -1;
    2008:	2001      	movs	r0, #1
    200a:	4240      	negs	r0, r0
	return rx_packet->buf[rx_packet->index];
}
    200c:	bd10      	pop	{r4, pc}
		if (!usb_configuration) return -1;
    200e:	4b08      	ldr	r3, [pc, #32]	; (2030 <usb_serial_peekchar+0x38>)
    2010:	781b      	ldrb	r3, [r3, #0]
    2012:	2b00      	cmp	r3, #0
    2014:	d0f8      	beq.n	2008 <usb_serial_peekchar+0x10>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    2016:	2003      	movs	r0, #3
    2018:	f7ff fb50 	bl	16bc <usb_rx>
    201c:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    201e:	2800      	cmp	r0, #0
    2020:	d1ef      	bne.n	2002 <usb_serial_peekchar+0xa>
    2022:	e7f1      	b.n	2008 <usb_serial_peekchar+0x10>
	return rx_packet->buf[rx_packet->index];
    2024:	885a      	ldrh	r2, [r3, #2]
    2026:	189b      	adds	r3, r3, r2
    2028:	7a18      	ldrb	r0, [r3, #8]
    202a:	e7ef      	b.n	200c <usb_serial_peekchar+0x14>
    202c:	2000036c 	.word	0x2000036c
    2030:	20000360 	.word	0x20000360

00002034 <usb_serial_available>:

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
    2034:	b510      	push	{r4, lr}
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    2036:	4b08      	ldr	r3, [pc, #32]	; (2058 <usb_serial_available+0x24>)
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    2038:	889c      	ldrh	r4, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    203a:	4b08      	ldr	r3, [pc, #32]	; (205c <usb_serial_available+0x28>)
    203c:	681a      	ldr	r2, [r3, #0]
    203e:	2a00      	cmp	r2, #0
    2040:	d003      	beq.n	204a <usb_serial_available+0x16>
    2042:	8813      	ldrh	r3, [r2, #0]
    2044:	8852      	ldrh	r2, [r2, #2]
    2046:	1a9b      	subs	r3, r3, r2
    2048:	18e4      	adds	r4, r4, r3
	if (count == 0) yield();
    204a:	2c00      	cmp	r4, #0
    204c:	d101      	bne.n	2052 <usb_serial_available+0x1e>
    204e:	f000 f93d 	bl	22cc <yield>
	return count;
}
    2052:	0020      	movs	r0, r4
    2054:	bd10      	pop	{r4, pc}
    2056:	46c0      	nop			; (mov r8, r8)
    2058:	20000362 	.word	0x20000362
    205c:	2000036c 	.word	0x2000036c

00002060 <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    2060:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    2062:	4b0a      	ldr	r3, [pc, #40]	; (208c <usb_serial_flush_input+0x2c>)
    2064:	781b      	ldrb	r3, [r3, #0]
    2066:	2b00      	cmp	r3, #0
    2068:	d00f      	beq.n	208a <usb_serial_flush_input+0x2a>
	if (rx_packet) {
    206a:	4c09      	ldr	r4, [pc, #36]	; (2090 <usb_serial_flush_input+0x30>)
    206c:	6820      	ldr	r0, [r4, #0]
    206e:	2800      	cmp	r0, #0
    2070:	d003      	beq.n	207a <usb_serial_flush_input+0x1a>
		usb_free(rx_packet);
    2072:	f7ff ff71 	bl	1f58 <usb_free>
		rx_packet = NULL;
    2076:	2300      	movs	r3, #0
    2078:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    207a:	2003      	movs	r0, #3
    207c:	f7ff fb1e 	bl	16bc <usb_rx>
		if (!rx) break;
    2080:	2800      	cmp	r0, #0
    2082:	d002      	beq.n	208a <usb_serial_flush_input+0x2a>
		usb_free(rx);
    2084:	f7ff ff68 	bl	1f58 <usb_free>
		rx = usb_rx(CDC_RX_ENDPOINT);
    2088:	e7f7      	b.n	207a <usb_serial_flush_input+0x1a>
	}
}
    208a:	bd10      	pop	{r4, pc}
    208c:	20000360 	.word	0x20000360
    2090:	2000036c 	.word	0x2000036c

00002094 <usb_serial_write>:
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    2094:	2301      	movs	r3, #1
{
    2096:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	while (size > 0) {
    2098:	000c      	movs	r4, r1
	tx_noautoflush = 1;
    209a:	4d2d      	ldr	r5, [pc, #180]	; (2150 <usb_serial_write+0xbc>)
{
    209c:	9000      	str	r0, [sp, #0]
    209e:	9101      	str	r1, [sp, #4]
	tx_noautoflush = 1;
    20a0:	702b      	strb	r3, [r5, #0]
	while (size > 0) {
    20a2:	2c00      	cmp	r4, #0
    20a4:	d102      	bne.n	20ac <usb_serial_write+0x18>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    20a6:	9801      	ldr	r0, [sp, #4]
	tx_noautoflush = 0;
    20a8:	702c      	strb	r4, [r5, #0]
	return ret;
    20aa:	e00c      	b.n	20c6 <usb_serial_write+0x32>
		if (!tx_packet) {
    20ac:	4e29      	ldr	r6, [pc, #164]	; (2154 <usb_serial_write+0xc0>)
    20ae:	6833      	ldr	r3, [r6, #0]
    20b0:	2b00      	cmp	r3, #0
    20b2:	d123      	bne.n	20fc <usb_serial_write+0x68>
    20b4:	4f28      	ldr	r7, [pc, #160]	; (2158 <usb_serial_write+0xc4>)
				if (!usb_configuration) {
    20b6:	4b29      	ldr	r3, [pc, #164]	; (215c <usb_serial_write+0xc8>)
    20b8:	781b      	ldrb	r3, [r3, #0]
    20ba:	b2da      	uxtb	r2, r3
    20bc:	2b00      	cmp	r3, #0
    20be:	d103      	bne.n	20c8 <usb_serial_write+0x34>
					tx_noautoflush = 0;
    20c0:	702a      	strb	r2, [r5, #0]
					return -1;
    20c2:	2001      	movs	r0, #1
    20c4:	4240      	negs	r0, r0
}
    20c6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    20c8:	2004      	movs	r0, #4
    20ca:	f7ff fb11 	bl	16f0 <usb_tx_packet_count>
    20ce:	2807      	cmp	r0, #7
    20d0:	d807      	bhi.n	20e2 <usb_serial_write+0x4e>
					tx_noautoflush = 1;
    20d2:	2301      	movs	r3, #1
    20d4:	702b      	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    20d6:	f7ff ff1f 	bl	1f18 <usb_malloc>
    20da:	6030      	str	r0, [r6, #0]
					if (tx_packet) break;
    20dc:	2800      	cmp	r0, #0
    20de:	d10d      	bne.n	20fc <usb_serial_write+0x68>
					tx_noautoflush = 0;
    20e0:	7028      	strb	r0, [r5, #0]
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    20e2:	3f01      	subs	r7, #1
    20e4:	4b1e      	ldr	r3, [pc, #120]	; (2160 <usb_serial_write+0xcc>)
    20e6:	2f00      	cmp	r7, #0
    20e8:	d002      	beq.n	20f0 <usb_serial_write+0x5c>
    20ea:	781a      	ldrb	r2, [r3, #0]
    20ec:	2a00      	cmp	r2, #0
    20ee:	d002      	beq.n	20f6 <usb_serial_write+0x62>
					transmit_previous_timeout = 1;
    20f0:	2201      	movs	r2, #1
    20f2:	701a      	strb	r2, [r3, #0]
    20f4:	e7e5      	b.n	20c2 <usb_serial_write+0x2e>
				yield();
    20f6:	f000 f8e9 	bl	22cc <yield>
				if (!usb_configuration) {
    20fa:	e7dc      	b.n	20b6 <usb_serial_write+0x22>
		transmit_previous_timeout = 0;
    20fc:	2200      	movs	r2, #0
    20fe:	4b18      	ldr	r3, [pc, #96]	; (2160 <usb_serial_write+0xcc>)
		len = CDC_TX_SIZE - tx_packet->index;
    2100:	6831      	ldr	r1, [r6, #0]
		transmit_previous_timeout = 0;
    2102:	701a      	strb	r2, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    2104:	2340      	movs	r3, #64	; 0x40
    2106:	884a      	ldrh	r2, [r1, #2]
    2108:	1a9b      	subs	r3, r3, r2
    210a:	42a3      	cmp	r3, r4
    210c:	d900      	bls.n	2110 <usb_serial_write+0x7c>
    210e:	0023      	movs	r3, r4
		dest = tx_packet->buf + tx_packet->index;
    2110:	0008      	movs	r0, r1
    2112:	3008      	adds	r0, #8
    2114:	1880      	adds	r0, r0, r2
		tx_packet->index += len;
    2116:	18d2      	adds	r2, r2, r3
    2118:	804a      	strh	r2, [r1, #2]
		while (len-- > 0) *dest++ = *src++;
    211a:	2200      	movs	r2, #0
		size -= len;
    211c:	1ae4      	subs	r4, r4, r3
		while (len-- > 0) *dest++ = *src++;
    211e:	4293      	cmp	r3, r2
    2120:	d110      	bne.n	2144 <usb_serial_write+0xb0>
    2122:	9a00      	ldr	r2, [sp, #0]
    2124:	18d3      	adds	r3, r2, r3
    2126:	9300      	str	r3, [sp, #0]
		if (tx_packet->index >= CDC_TX_SIZE) {
    2128:	884b      	ldrh	r3, [r1, #2]
    212a:	2b3f      	cmp	r3, #63	; 0x3f
    212c:	d906      	bls.n	213c <usb_serial_write+0xa8>
			tx_packet->len = CDC_TX_SIZE;
    212e:	2340      	movs	r3, #64	; 0x40
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    2130:	2004      	movs	r0, #4
			tx_packet->len = CDC_TX_SIZE;
    2132:	800b      	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    2134:	f7ff fb28 	bl	1788 <usb_tx>
			tx_packet = NULL;
    2138:	2300      	movs	r3, #0
    213a:	6033      	str	r3, [r6, #0]
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    213c:	2205      	movs	r2, #5
    213e:	4b09      	ldr	r3, [pc, #36]	; (2164 <usb_serial_write+0xd0>)
    2140:	701a      	strb	r2, [r3, #0]
    2142:	e7ae      	b.n	20a2 <usb_serial_write+0xe>
		while (len-- > 0) *dest++ = *src++;
    2144:	9f00      	ldr	r7, [sp, #0]
    2146:	5cbf      	ldrb	r7, [r7, r2]
    2148:	5487      	strb	r7, [r0, r2]
    214a:	3201      	adds	r2, #1
    214c:	e7e7      	b.n	211e <usb_serial_write+0x8a>
    214e:	46c0      	nop			; (mov r8, r8)
    2150:	20000371 	.word	0x20000371
    2154:	20000374 	.word	0x20000374
    2158:	00007509 	.word	0x00007509
    215c:	20000360 	.word	0x20000360
    2160:	20000370 	.word	0x20000370
    2164:	20000388 	.word	0x20000388

00002168 <usb_serial_putchar>:
{
    2168:	b507      	push	{r0, r1, r2, lr}
    216a:	466b      	mov	r3, sp
    216c:	71d8      	strb	r0, [r3, #7]
    216e:	3307      	adds	r3, #7
	return usb_serial_write(&c, 1);
    2170:	2101      	movs	r1, #1
    2172:	0018      	movs	r0, r3
    2174:	f7ff ff8e 	bl	2094 <usb_serial_write>
}
    2178:	bd0e      	pop	{r1, r2, r3, pc}
    217a:	Address 0x0000217a is out of bounds.


0000217c <usb_serial_write_buffer_free>:

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    217c:	2301      	movs	r3, #1
{
    217e:	b570      	push	{r4, r5, r6, lr}
	tx_noautoflush = 1;
    2180:	4c0e      	ldr	r4, [pc, #56]	; (21bc <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    2182:	4d0f      	ldr	r5, [pc, #60]	; (21c0 <usb_serial_write_buffer_free+0x44>)
	tx_noautoflush = 1;
    2184:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    2186:	682b      	ldr	r3, [r5, #0]
    2188:	2b00      	cmp	r3, #0
    218a:	d110      	bne.n	21ae <usb_serial_write_buffer_free+0x32>
		if (!usb_configuration ||
    218c:	4b0d      	ldr	r3, [pc, #52]	; (21c4 <usb_serial_write_buffer_free+0x48>)
    218e:	781b      	ldrb	r3, [r3, #0]
    2190:	2b00      	cmp	r3, #0
    2192:	d102      	bne.n	219a <usb_serial_write_buffer_free+0x1e>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    2194:	2000      	movs	r0, #0
    2196:	7020      	strb	r0, [r4, #0]
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    2198:	bd70      	pop	{r4, r5, r6, pc}
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    219a:	2004      	movs	r0, #4
    219c:	f7ff faa8 	bl	16f0 <usb_tx_packet_count>
		if (!usb_configuration ||
    21a0:	2807      	cmp	r0, #7
    21a2:	d8f7      	bhi.n	2194 <usb_serial_write_buffer_free+0x18>
		  (tx_packet = usb_malloc()) == NULL) {
    21a4:	f7ff feb8 	bl	1f18 <usb_malloc>
    21a8:	6028      	str	r0, [r5, #0]
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    21aa:	2800      	cmp	r0, #0
    21ac:	d0f2      	beq.n	2194 <usb_serial_write_buffer_free+0x18>
	len = CDC_TX_SIZE - tx_packet->index;
    21ae:	2040      	movs	r0, #64	; 0x40
    21b0:	682b      	ldr	r3, [r5, #0]
    21b2:	885b      	ldrh	r3, [r3, #2]
    21b4:	1ac0      	subs	r0, r0, r3
	tx_noautoflush = 0;
    21b6:	2300      	movs	r3, #0
    21b8:	7023      	strb	r3, [r4, #0]
	return len;
    21ba:	e7ed      	b.n	2198 <usb_serial_write_buffer_free+0x1c>
    21bc:	20000371 	.word	0x20000371
    21c0:	20000374 	.word	0x20000374
    21c4:	20000360 	.word	0x20000360

000021c8 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    21c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    21ca:	4b12      	ldr	r3, [pc, #72]	; (2214 <usb_serial_flush_output+0x4c>)
    21cc:	781b      	ldrb	r3, [r3, #0]
    21ce:	2b00      	cmp	r3, #0
    21d0:	d014      	beq.n	21fc <usb_serial_flush_output+0x34>
	tx_noautoflush = 1;
    21d2:	2601      	movs	r6, #1
	if (tx_packet) {
    21d4:	4f10      	ldr	r7, [pc, #64]	; (2218 <usb_serial_flush_output+0x50>)
	tx_noautoflush = 1;
    21d6:	4b11      	ldr	r3, [pc, #68]	; (221c <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    21d8:	683c      	ldr	r4, [r7, #0]
    21da:	4d11      	ldr	r5, [pc, #68]	; (2220 <usb_serial_flush_output+0x58>)
	tx_noautoflush = 1;
    21dc:	9301      	str	r3, [sp, #4]
    21de:	701e      	strb	r6, [r3, #0]
	if (tx_packet) {
    21e0:	2c00      	cmp	r4, #0
    21e2:	d00c      	beq.n	21fe <usb_serial_flush_output+0x36>
		usb_cdc_transmit_flush_timer = 0;
    21e4:	2600      	movs	r6, #0
    21e6:	702e      	strb	r6, [r5, #0]
		tx_packet->len = tx_packet->index;
    21e8:	8863      	ldrh	r3, [r4, #2]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    21ea:	0021      	movs	r1, r4
    21ec:	2004      	movs	r0, #4
		tx_packet->len = tx_packet->index;
    21ee:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    21f0:	f7ff faca 	bl	1788 <usb_tx>
		tx_packet = NULL;
    21f4:	603e      	str	r6, [r7, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    21f6:	2300      	movs	r3, #0
    21f8:	9a01      	ldr	r2, [sp, #4]
    21fa:	7013      	strb	r3, [r2, #0]
}
    21fc:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		usb_packet_t *tx = usb_malloc();
    21fe:	f7ff fe8b 	bl	1f18 <usb_malloc>
    2202:	1e01      	subs	r1, r0, #0
		if (tx) {
    2204:	d004      	beq.n	2210 <usb_serial_flush_output+0x48>
			usb_tx(CDC_TX_ENDPOINT, tx);
    2206:	2004      	movs	r0, #4
			usb_cdc_transmit_flush_timer = 0;
    2208:	702c      	strb	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    220a:	f7ff fabd 	bl	1788 <usb_tx>
    220e:	e7f2      	b.n	21f6 <usb_serial_flush_output+0x2e>
			usb_cdc_transmit_flush_timer = 1;
    2210:	702e      	strb	r6, [r5, #0]
    2212:	e7f0      	b.n	21f6 <usb_serial_flush_output+0x2e>
    2214:	20000360 	.word	0x20000360
    2218:	20000374 	.word	0x20000374
    221c:	20000371 	.word	0x20000371
    2220:	20000388 	.word	0x20000388

00002224 <usb_serial_flush_callback>:

void usb_serial_flush_callback(void)
{
    2224:	b570      	push	{r4, r5, r6, lr}
	if (tx_noautoflush) return;
    2226:	4b0e      	ldr	r3, [pc, #56]	; (2260 <usb_serial_flush_callback+0x3c>)
    2228:	781b      	ldrb	r3, [r3, #0]
    222a:	b2dd      	uxtb	r5, r3
    222c:	2b00      	cmp	r3, #0
    222e:	d109      	bne.n	2244 <usb_serial_flush_callback+0x20>
	if (tx_packet) {
    2230:	4c0c      	ldr	r4, [pc, #48]	; (2264 <usb_serial_flush_callback+0x40>)
    2232:	6821      	ldr	r1, [r4, #0]
    2234:	2900      	cmp	r1, #0
    2236:	d006      	beq.n	2246 <usb_serial_flush_callback+0x22>
		tx_packet->len = tx_packet->index;
    2238:	884b      	ldrh	r3, [r1, #2]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    223a:	2004      	movs	r0, #4
		tx_packet->len = tx_packet->index;
    223c:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    223e:	f7ff faa3 	bl	1788 <usb_tx>
		tx_packet = NULL;
    2242:	6025      	str	r5, [r4, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    2244:	bd70      	pop	{r4, r5, r6, pc}
		usb_packet_t *tx = usb_malloc();
    2246:	f7ff fe67 	bl	1f18 <usb_malloc>
    224a:	1e01      	subs	r1, r0, #0
		if (tx) {
    224c:	d003      	beq.n	2256 <usb_serial_flush_callback+0x32>
			usb_tx(CDC_TX_ENDPOINT, tx);
    224e:	2004      	movs	r0, #4
    2250:	f7ff fa9a 	bl	1788 <usb_tx>
    2254:	e7f6      	b.n	2244 <usb_serial_flush_callback+0x20>
			usb_cdc_transmit_flush_timer = 1;
    2256:	2201      	movs	r2, #1
    2258:	4b03      	ldr	r3, [pc, #12]	; (2268 <usb_serial_flush_callback+0x44>)
    225a:	701a      	strb	r2, [r3, #0]
    225c:	e7f2      	b.n	2244 <usb_serial_flush_callback+0x20>
    225e:	46c0      	nop			; (mov r8, r8)
    2260:	20000371 	.word	0x20000371
    2264:	20000374 	.word	0x20000374
    2268:	20000388 	.word	0x20000388

0000226c <EventResponder::runFromYield()>:
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    226c:	4914      	ldr	r1, [pc, #80]	; (22c0 <EventResponder::runFromYield()+0x54>)
	static void runFromYield() {
    226e:	b570      	push	{r4, r5, r6, lr}
		if (!firstYield) return;  
    2270:	680b      	ldr	r3, [r1, #0]
    2272:	2b00      	cmp	r3, #0
    2274:	d00c      	beq.n	2290 <EventResponder::runFromYield()+0x24>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    2276:	f3ef 8305 	mrs	r3, IPSR
		if (ipsr != 0) return;
    227a:	2b00      	cmp	r3, #0
    227c:	d108      	bne.n	2290 <EventResponder::runFromYield()+0x24>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    227e:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    2282:	b672      	cpsid	i
		EventResponder *first = firstYield;
    2284:	6808      	ldr	r0, [r1, #0]
		if (first == nullptr) {
    2286:	2800      	cmp	r0, #0
    2288:	d103      	bne.n	2292 <EventResponder::runFromYield()+0x26>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    228a:	2a00      	cmp	r2, #0
    228c:	d100      	bne.n	2290 <EventResponder::runFromYield()+0x24>
    228e:	b662      	cpsie	i
	}
    2290:	bd70      	pop	{r4, r5, r6, pc}
		if (runningFromYield) {
    2292:	4c0c      	ldr	r4, [pc, #48]	; (22c4 <EventResponder::runFromYield()+0x58>)
    2294:	7825      	ldrb	r5, [r4, #0]
    2296:	2d00      	cmp	r5, #0
    2298:	d1f7      	bne.n	228a <EventResponder::runFromYield()+0x1e>
		runningFromYield = true;
    229a:	2301      	movs	r3, #1
    229c:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
    229e:	6943      	ldr	r3, [r0, #20]
    22a0:	600b      	str	r3, [r1, #0]
		if (firstYield) {
    22a2:	2b00      	cmp	r3, #0
    22a4:	d009      	beq.n	22ba <EventResponder::runFromYield()+0x4e>
			firstYield->_prev = nullptr;
    22a6:	619d      	str	r5, [r3, #24]
		if (doit) __enable_irq();
    22a8:	2a00      	cmp	r2, #0
    22aa:	d100      	bne.n	22ae <EventResponder::runFromYield()+0x42>
    22ac:	b662      	cpsie	i
		first->_triggered = false;
    22ae:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    22b0:	6883      	ldr	r3, [r0, #8]
		first->_triggered = false;
    22b2:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    22b4:	4798      	blx	r3
		runningFromYield = false;
    22b6:	7025      	strb	r5, [r4, #0]
    22b8:	e7ea      	b.n	2290 <EventResponder::runFromYield()+0x24>
			lastYield = nullptr;
    22ba:	4903      	ldr	r1, [pc, #12]	; (22c8 <EventResponder::runFromYield()+0x5c>)
    22bc:	600b      	str	r3, [r1, #0]
    22be:	e7f3      	b.n	22a8 <EventResponder::runFromYield()+0x3c>
    22c0:	2000038c 	.word	0x2000038c
    22c4:	20000398 	.word	0x20000398
    22c8:	2000039c 	.word	0x2000039c

000022cc <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    22cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    22ce:	4d1b      	ldr	r5, [pc, #108]	; (233c <yield+0x70>)
    22d0:	782a      	ldrb	r2, [r5, #0]
    22d2:	2a00      	cmp	r2, #0
    22d4:	d01f      	beq.n	2316 <yield+0x4a>
	if (running) return; // TODO: does this need to be atomic?
    22d6:	4e1a      	ldr	r6, [pc, #104]	; (2340 <yield+0x74>)
    22d8:	7834      	ldrb	r4, [r6, #0]
    22da:	2c00      	cmp	r4, #0
    22dc:	d11b      	bne.n	2316 <yield+0x4a>
	running = 1;
    22de:	2301      	movs	r3, #1
    22e0:	7033      	strb	r3, [r6, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    22e2:	421a      	tst	r2, r3
    22e4:	d00d      	beq.n	2302 <yield+0x36>
        virtual int available() { return usb_serial_available(); }
    22e6:	f7ff fea5 	bl	2034 <usb_serial_available>
		if (Serial.available()) serialEvent();
    22ea:	2800      	cmp	r0, #0
    22ec:	d001      	beq.n	22f2 <yield+0x26>
    22ee:	f000 f8c3 	bl	2478 <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    22f2:	4a14      	ldr	r2, [pc, #80]	; (2344 <yield+0x78>)
    22f4:	782b      	ldrb	r3, [r5, #0]
    22f6:	7812      	ldrb	r2, [r2, #0]
    22f8:	2a00      	cmp	r2, #0
    22fa:	d002      	beq.n	2302 <yield+0x36>
    22fc:	2201      	movs	r2, #1
    22fe:	4393      	bics	r3, r2
    2300:	702b      	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    2302:	782b      	ldrb	r3, [r5, #0]
    2304:	079b      	lsls	r3, r3, #30
    2306:	d414      	bmi.n	2332 <yield+0x66>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    2308:	2300      	movs	r3, #0
    230a:	7033      	strb	r3, [r6, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    230c:	782b      	ldrb	r3, [r5, #0]
    230e:	075b      	lsls	r3, r3, #29
    2310:	d501      	bpl.n	2316 <yield+0x4a>
    2312:	f7ff ffab 	bl	226c <EventResponder::runFromYield()>
	
};
    2316:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			s_serials_with_serial_events[i]->doYieldCode();
    2318:	4b0b      	ldr	r3, [pc, #44]	; (2348 <yield+0x7c>)
    231a:	00a2      	lsls	r2, r4, #2
    231c:	58d7      	ldr	r7, [r2, r3]
		if (available()) (*_serialEvent)();
    231e:	683b      	ldr	r3, [r7, #0]
    2320:	0038      	movs	r0, r7
    2322:	691b      	ldr	r3, [r3, #16]
    2324:	4798      	blx	r3
    2326:	2800      	cmp	r0, #0
    2328:	d001      	beq.n	232e <yield+0x62>
    232a:	693b      	ldr	r3, [r7, #16]
    232c:	4798      	blx	r3
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    232e:	3401      	adds	r4, #1
    2330:	b2e4      	uxtb	r4, r4
    2332:	4b06      	ldr	r3, [pc, #24]	; (234c <yield+0x80>)
    2334:	781b      	ldrb	r3, [r3, #0]
    2336:	42a3      	cmp	r3, r4
    2338:	d8ee      	bhi.n	2318 <yield+0x4c>
    233a:	e7e5      	b.n	2308 <yield+0x3c>
    233c:	1ffffdd8 	.word	0x1ffffdd8
    2340:	20000389 	.word	0x20000389
    2344:	00002abc 	.word	0x00002abc
    2348:	200003a0 	.word	0x200003a0
    234c:	200003ac 	.word	0x200003ac

00002350 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    2350:	b510      	push	{r4, lr}
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2352:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    2356:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2358:	4b0b      	ldr	r3, [pc, #44]	; (2388 <EventResponder::runFromInterrupt()+0x38>)
    235a:	6818      	ldr	r0, [r3, #0]
		if (first) {
    235c:	2800      	cmp	r0, #0
    235e:	d00f      	beq.n	2380 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
    2360:	6942      	ldr	r2, [r0, #20]
    2362:	601a      	str	r2, [r3, #0]
			if (firstInterrupt) {
    2364:	2300      	movs	r3, #0
    2366:	429a      	cmp	r2, r3
    2368:	d007      	beq.n	237a <EventResponder::runFromInterrupt()+0x2a>
				firstInterrupt->_prev = nullptr;
    236a:	6193      	str	r3, [r2, #24]
		if (doit) __enable_irq();
    236c:	2900      	cmp	r1, #0
    236e:	d100      	bne.n	2372 <EventResponder::runFromInterrupt()+0x22>
    2370:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    2372:	7743      	strb	r3, [r0, #29]
			(*(first->_function))(*first);
    2374:	6883      	ldr	r3, [r0, #8]
    2376:	4798      	blx	r3
		} else {
			enableInterrupts(irq);
			break;
		}
	}
    2378:	e7eb      	b.n	2352 <EventResponder::runFromInterrupt()+0x2>
				lastInterrupt = nullptr;
    237a:	4a04      	ldr	r2, [pc, #16]	; (238c <EventResponder::runFromInterrupt()+0x3c>)
    237c:	6013      	str	r3, [r2, #0]
    237e:	e7f5      	b.n	236c <EventResponder::runFromInterrupt()+0x1c>
    2380:	2900      	cmp	r1, #0
    2382:	d100      	bne.n	2386 <EventResponder::runFromInterrupt()+0x36>
    2384:	b662      	cpsie	i
}
    2386:	bd10      	pop	{r4, pc}
    2388:	20000394 	.word	0x20000394
    238c:	20000390 	.word	0x20000390

00002390 <pendablesrvreq_isr>:
{
    2390:	b510      	push	{r4, lr}
	EventResponder::runFromInterrupt();
    2392:	f7ff ffdd 	bl	2350 <EventResponder::runFromInterrupt()>
}
    2396:	bd10      	pop	{r4, pc}

00002398 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    2398:	4a02      	ldr	r2, [pc, #8]	; (23a4 <systick_isr+0xc>)
    239a:	6813      	ldr	r3, [r2, #0]
    239c:	3301      	adds	r3, #1
    239e:	6013      	str	r3, [r2, #0]
}
    23a0:	4770      	bx	lr
    23a2:	46c0      	nop			; (mov r8, r8)
    23a4:	200000d4 	.word	0x200000d4

000023a8 <HardwareSerial::addToSerialEventsList()>:
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    23a8:	490c      	ldr	r1, [pc, #48]	; (23dc <HardwareSerial::addToSerialEventsList()+0x34>)
void HardwareSerial::addToSerialEventsList() {
    23aa:	b570      	push	{r4, r5, r6, lr}
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    23ac:	2200      	movs	r2, #0
    23ae:	000d      	movs	r5, r1
    23b0:	4c0b      	ldr	r4, [pc, #44]	; (23e0 <HardwareSerial::addToSerialEventsList()+0x38>)
    23b2:	7823      	ldrb	r3, [r4, #0]
    23b4:	4293      	cmp	r3, r2
    23b6:	d109      	bne.n	23cc <HardwareSerial::addToSerialEventsList()+0x24>
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
	}

	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    23b8:	1c5a      	adds	r2, r3, #1
    23ba:	009b      	lsls	r3, r3, #2
    23bc:	50e8      	str	r0, [r5, r3]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    23be:	2302      	movs	r3, #2
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    23c0:	7022      	strb	r2, [r4, #0]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    23c2:	4a08      	ldr	r2, [pc, #32]	; (23e4 <HardwareSerial::addToSerialEventsList()+0x3c>)
    23c4:	7811      	ldrb	r1, [r2, #0]
    23c6:	430b      	orrs	r3, r1
    23c8:	7013      	strb	r3, [r2, #0]
}
    23ca:	bd70      	pop	{r4, r5, r6, pc}
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
    23cc:	3104      	adds	r1, #4
    23ce:	1f0e      	subs	r6, r1, #4
    23d0:	6836      	ldr	r6, [r6, #0]
    23d2:	4286      	cmp	r6, r0
    23d4:	d0f9      	beq.n	23ca <HardwareSerial::addToSerialEventsList()+0x22>
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    23d6:	3201      	adds	r2, #1
    23d8:	b2d2      	uxtb	r2, r2
    23da:	e7eb      	b.n	23b4 <HardwareSerial::addToSerialEventsList()+0xc>
    23dc:	200003a0 	.word	0x200003a0
    23e0:	200003ac 	.word	0x200003ac
    23e4:	1ffffdd8 	.word	0x1ffffdd8

000023e8 <analog_init>:
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    23e8:	4b1b      	ldr	r3, [pc, #108]	; (2458 <analog_init+0x70>)
    23ea:	4a1c      	ldr	r2, [pc, #112]	; (245c <analog_init+0x74>)
    23ec:	7819      	ldrb	r1, [r3, #0]
    23ee:	4b1c      	ldr	r3, [pc, #112]	; (2460 <analog_init+0x78>)
    23f0:	2908      	cmp	r1, #8
    23f2:	d115      	bne.n	2420 <analog_init+0x38>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    23f4:	2100      	movs	r1, #0
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    23f6:	6011      	str	r1, [r2, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    23f8:	2213      	movs	r2, #19
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    23fa:	601a      	str	r2, [r3, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MKL26Z64__)
	if (analog_reference_internal) {
    23fc:	4b19      	ldr	r3, [pc, #100]	; (2464 <analog_init+0x7c>)
    23fe:	781a      	ldrb	r2, [r3, #0]
    2400:	4b19      	ldr	r3, [pc, #100]	; (2468 <analog_init+0x80>)
    2402:	2a00      	cmp	r2, #0
    2404:	d018      	beq.n	2438 <analog_init+0x50>
		ADC0_SC2 = ADC_SC2_REFSEL(0); // external AREF
    2406:	2200      	movs	r2, #0
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
    2408:	601a      	str	r2, [r3, #0]
	}
	#endif

	num = analog_num_average;
    240a:	4b18      	ldr	r3, [pc, #96]	; (246c <analog_init+0x84>)
    240c:	781a      	ldrb	r2, [r3, #0]
	if (num <= 1) {
    240e:	4b18      	ldr	r3, [pc, #96]	; (2470 <analog_init+0x88>)
    2410:	2a01      	cmp	r2, #1
    2412:	d813      	bhi.n	243c <analog_init+0x54>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    2414:	2280      	movs	r2, #128	; 0x80
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    2416:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
		#endif
	}
	calibrating = 1;
    2418:	2201      	movs	r2, #1
    241a:	4b16      	ldr	r3, [pc, #88]	; (2474 <analog_init+0x8c>)
    241c:	701a      	strb	r2, [r3, #0]
}
    241e:	4770      	bx	lr
	} else if (analog_config_bits == 10) {
    2420:	290a      	cmp	r1, #10
    2422:	d101      	bne.n	2428 <analog_init+0x40>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    2424:	312e      	adds	r1, #46	; 0x2e
    2426:	e7e6      	b.n	23f6 <analog_init+0xe>
	} else if (analog_config_bits == 12) {
    2428:	290c      	cmp	r1, #12
    242a:	d103      	bne.n	2434 <analog_init+0x4c>
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    242c:	3128      	adds	r1, #40	; 0x28
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    242e:	6011      	str	r1, [r2, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    2430:	2212      	movs	r2, #18
    2432:	e7e2      	b.n	23fa <analog_init+0x12>
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    2434:	213c      	movs	r1, #60	; 0x3c
    2436:	e7fa      	b.n	242e <analog_init+0x46>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
    2438:	2201      	movs	r2, #1
    243a:	e7e5      	b.n	2408 <analog_init+0x20>
	} else if (num <= 4) {
    243c:	2a04      	cmp	r2, #4
    243e:	d801      	bhi.n	2444 <analog_init+0x5c>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    2440:	2284      	movs	r2, #132	; 0x84
    2442:	e7e8      	b.n	2416 <analog_init+0x2e>
	} else if (num <= 8) {
    2444:	2a08      	cmp	r2, #8
    2446:	d801      	bhi.n	244c <analog_init+0x64>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    2448:	2285      	movs	r2, #133	; 0x85
    244a:	e7e4      	b.n	2416 <analog_init+0x2e>
	} else if (num <= 16) {
    244c:	2a10      	cmp	r2, #16
    244e:	d801      	bhi.n	2454 <analog_init+0x6c>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    2450:	2286      	movs	r2, #134	; 0x86
    2452:	e7e0      	b.n	2416 <analog_init+0x2e>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    2454:	2287      	movs	r2, #135	; 0x87
    2456:	e7de      	b.n	2416 <analog_init+0x2e>
    2458:	1ffffdd9 	.word	0x1ffffdd9
    245c:	4003b008 	.word	0x4003b008
    2460:	4003b00c 	.word	0x4003b00c
    2464:	200003ad 	.word	0x200003ad
    2468:	4003b020 	.word	0x4003b020
    246c:	1ffffdda 	.word	0x1ffffdda
    2470:	4003b024 	.word	0x4003b024
    2474:	200003ae 	.word	0x200003ae

00002478 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
}
    2478:	4770      	bx	lr
    247a:	Address 0x0000247a is out of bounds.


0000247c <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    247c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    247e:	b672      	cpsid	i
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    2480:	2370      	movs	r3, #112	; 0x70
	FTFL_FCCOB0 = 0x41;
    2482:	2141      	movs	r1, #65	; 0x41
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    2484:	4a14      	ldr	r2, [pc, #80]	; (24d8 <usb_init_serialnumber+0x5c>)
    2486:	7013      	strb	r3, [r2, #0]
	FTFL_FCCOB0 = 0x41;
    2488:	4b14      	ldr	r3, [pc, #80]	; (24dc <usb_init_serialnumber+0x60>)
    248a:	7019      	strb	r1, [r3, #0]
	FTFL_FCCOB1 = 15;
    248c:	4b14      	ldr	r3, [pc, #80]	; (24e0 <usb_init_serialnumber+0x64>)
    248e:	3932      	subs	r1, #50	; 0x32
    2490:	7019      	strb	r1, [r3, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    2492:	2380      	movs	r3, #128	; 0x80
    2494:	7013      	strb	r3, [r2, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    2496:	7813      	ldrb	r3, [r2, #0]
    2498:	b25b      	sxtb	r3, r3
    249a:	2b00      	cmp	r3, #0
    249c:	dafb      	bge.n	2496 <usb_init_serialnumber+0x1a>
	num = *(uint32_t *)&FTFL_FCCOB7;
    249e:	4b11      	ldr	r3, [pc, #68]	; (24e4 <usb_init_serialnumber+0x68>)
    24a0:	6818      	ldr	r0, [r3, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    24a2:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    24a4:	4b10      	ldr	r3, [pc, #64]	; (24e8 <usb_init_serialnumber+0x6c>)
    24a6:	4298      	cmp	r0, r3
    24a8:	d801      	bhi.n	24ae <usb_init_serialnumber+0x32>
    24aa:	230a      	movs	r3, #10
    24ac:	4358      	muls	r0, r3
	ultoa(num, buf, 10);
    24ae:	ac01      	add	r4, sp, #4
    24b0:	220a      	movs	r2, #10
    24b2:	0021      	movs	r1, r4
    24b4:	f7fe fada 	bl	a6c <ultoa>
	for (i=0; i<10; i++) {
    24b8:	2200      	movs	r2, #0
    24ba:	490c      	ldr	r1, [pc, #48]	; (24ec <usb_init_serialnumber+0x70>)
		char c = buf[i];
    24bc:	5ca0      	ldrb	r0, [r4, r2]
		if (!c) break;
    24be:	0013      	movs	r3, r2
	for (i=0; i<10; i++) {
    24c0:	3201      	adds	r2, #1
		if (!c) break;
    24c2:	2800      	cmp	r0, #0
    24c4:	d004      	beq.n	24d0 <usb_init_serialnumber+0x54>
		usb_string_serial_number_default.wString[i] = c;
    24c6:	0053      	lsls	r3, r2, #1
    24c8:	52c8      	strh	r0, [r1, r3]
	for (i=0; i<10; i++) {
    24ca:	2a0a      	cmp	r2, #10
    24cc:	d1f6      	bne.n	24bc <usb_init_serialnumber+0x40>
    24ce:	0013      	movs	r3, r2
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    24d0:	3301      	adds	r3, #1
    24d2:	005b      	lsls	r3, r3, #1
    24d4:	700b      	strb	r3, [r1, #0]
}
    24d6:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
    24d8:	40020000 	.word	0x40020000
    24dc:	40020007 	.word	0x40020007
    24e0:	40020006 	.word	0x40020006
    24e4:	40020008 	.word	0x40020008
    24e8:	0098967f 	.word	0x0098967f
    24ec:	1ffffe62 	.word	0x1ffffe62

000024f0 <__gnu_thumb1_case_uqi>:
    24f0:	b402      	push	{r1}
    24f2:	4671      	mov	r1, lr
    24f4:	0849      	lsrs	r1, r1, #1
    24f6:	0049      	lsls	r1, r1, #1
    24f8:	5c09      	ldrb	r1, [r1, r0]
    24fa:	0049      	lsls	r1, r1, #1
    24fc:	448e      	add	lr, r1
    24fe:	bc02      	pop	{r1}
    2500:	4770      	bx	lr
    2502:	46c0      	nop			; (mov r8, r8)

00002504 <__udivsi3>:
    2504:	2200      	movs	r2, #0
    2506:	0843      	lsrs	r3, r0, #1
    2508:	428b      	cmp	r3, r1
    250a:	d374      	bcc.n	25f6 <__udivsi3+0xf2>
    250c:	0903      	lsrs	r3, r0, #4
    250e:	428b      	cmp	r3, r1
    2510:	d35f      	bcc.n	25d2 <__udivsi3+0xce>
    2512:	0a03      	lsrs	r3, r0, #8
    2514:	428b      	cmp	r3, r1
    2516:	d344      	bcc.n	25a2 <__udivsi3+0x9e>
    2518:	0b03      	lsrs	r3, r0, #12
    251a:	428b      	cmp	r3, r1
    251c:	d328      	bcc.n	2570 <__udivsi3+0x6c>
    251e:	0c03      	lsrs	r3, r0, #16
    2520:	428b      	cmp	r3, r1
    2522:	d30d      	bcc.n	2540 <__udivsi3+0x3c>
    2524:	22ff      	movs	r2, #255	; 0xff
    2526:	0209      	lsls	r1, r1, #8
    2528:	ba12      	rev	r2, r2
    252a:	0c03      	lsrs	r3, r0, #16
    252c:	428b      	cmp	r3, r1
    252e:	d302      	bcc.n	2536 <__udivsi3+0x32>
    2530:	1212      	asrs	r2, r2, #8
    2532:	0209      	lsls	r1, r1, #8
    2534:	d065      	beq.n	2602 <__udivsi3+0xfe>
    2536:	0b03      	lsrs	r3, r0, #12
    2538:	428b      	cmp	r3, r1
    253a:	d319      	bcc.n	2570 <__udivsi3+0x6c>
    253c:	e000      	b.n	2540 <__udivsi3+0x3c>
    253e:	0a09      	lsrs	r1, r1, #8
    2540:	0bc3      	lsrs	r3, r0, #15
    2542:	428b      	cmp	r3, r1
    2544:	d301      	bcc.n	254a <__udivsi3+0x46>
    2546:	03cb      	lsls	r3, r1, #15
    2548:	1ac0      	subs	r0, r0, r3
    254a:	4152      	adcs	r2, r2
    254c:	0b83      	lsrs	r3, r0, #14
    254e:	428b      	cmp	r3, r1
    2550:	d301      	bcc.n	2556 <__udivsi3+0x52>
    2552:	038b      	lsls	r3, r1, #14
    2554:	1ac0      	subs	r0, r0, r3
    2556:	4152      	adcs	r2, r2
    2558:	0b43      	lsrs	r3, r0, #13
    255a:	428b      	cmp	r3, r1
    255c:	d301      	bcc.n	2562 <__udivsi3+0x5e>
    255e:	034b      	lsls	r3, r1, #13
    2560:	1ac0      	subs	r0, r0, r3
    2562:	4152      	adcs	r2, r2
    2564:	0b03      	lsrs	r3, r0, #12
    2566:	428b      	cmp	r3, r1
    2568:	d301      	bcc.n	256e <__udivsi3+0x6a>
    256a:	030b      	lsls	r3, r1, #12
    256c:	1ac0      	subs	r0, r0, r3
    256e:	4152      	adcs	r2, r2
    2570:	0ac3      	lsrs	r3, r0, #11
    2572:	428b      	cmp	r3, r1
    2574:	d301      	bcc.n	257a <__udivsi3+0x76>
    2576:	02cb      	lsls	r3, r1, #11
    2578:	1ac0      	subs	r0, r0, r3
    257a:	4152      	adcs	r2, r2
    257c:	0a83      	lsrs	r3, r0, #10
    257e:	428b      	cmp	r3, r1
    2580:	d301      	bcc.n	2586 <__udivsi3+0x82>
    2582:	028b      	lsls	r3, r1, #10
    2584:	1ac0      	subs	r0, r0, r3
    2586:	4152      	adcs	r2, r2
    2588:	0a43      	lsrs	r3, r0, #9
    258a:	428b      	cmp	r3, r1
    258c:	d301      	bcc.n	2592 <__udivsi3+0x8e>
    258e:	024b      	lsls	r3, r1, #9
    2590:	1ac0      	subs	r0, r0, r3
    2592:	4152      	adcs	r2, r2
    2594:	0a03      	lsrs	r3, r0, #8
    2596:	428b      	cmp	r3, r1
    2598:	d301      	bcc.n	259e <__udivsi3+0x9a>
    259a:	020b      	lsls	r3, r1, #8
    259c:	1ac0      	subs	r0, r0, r3
    259e:	4152      	adcs	r2, r2
    25a0:	d2cd      	bcs.n	253e <__udivsi3+0x3a>
    25a2:	09c3      	lsrs	r3, r0, #7
    25a4:	428b      	cmp	r3, r1
    25a6:	d301      	bcc.n	25ac <__udivsi3+0xa8>
    25a8:	01cb      	lsls	r3, r1, #7
    25aa:	1ac0      	subs	r0, r0, r3
    25ac:	4152      	adcs	r2, r2
    25ae:	0983      	lsrs	r3, r0, #6
    25b0:	428b      	cmp	r3, r1
    25b2:	d301      	bcc.n	25b8 <__udivsi3+0xb4>
    25b4:	018b      	lsls	r3, r1, #6
    25b6:	1ac0      	subs	r0, r0, r3
    25b8:	4152      	adcs	r2, r2
    25ba:	0943      	lsrs	r3, r0, #5
    25bc:	428b      	cmp	r3, r1
    25be:	d301      	bcc.n	25c4 <__udivsi3+0xc0>
    25c0:	014b      	lsls	r3, r1, #5
    25c2:	1ac0      	subs	r0, r0, r3
    25c4:	4152      	adcs	r2, r2
    25c6:	0903      	lsrs	r3, r0, #4
    25c8:	428b      	cmp	r3, r1
    25ca:	d301      	bcc.n	25d0 <__udivsi3+0xcc>
    25cc:	010b      	lsls	r3, r1, #4
    25ce:	1ac0      	subs	r0, r0, r3
    25d0:	4152      	adcs	r2, r2
    25d2:	08c3      	lsrs	r3, r0, #3
    25d4:	428b      	cmp	r3, r1
    25d6:	d301      	bcc.n	25dc <__udivsi3+0xd8>
    25d8:	00cb      	lsls	r3, r1, #3
    25da:	1ac0      	subs	r0, r0, r3
    25dc:	4152      	adcs	r2, r2
    25de:	0883      	lsrs	r3, r0, #2
    25e0:	428b      	cmp	r3, r1
    25e2:	d301      	bcc.n	25e8 <__udivsi3+0xe4>
    25e4:	008b      	lsls	r3, r1, #2
    25e6:	1ac0      	subs	r0, r0, r3
    25e8:	4152      	adcs	r2, r2
    25ea:	0843      	lsrs	r3, r0, #1
    25ec:	428b      	cmp	r3, r1
    25ee:	d301      	bcc.n	25f4 <__udivsi3+0xf0>
    25f0:	004b      	lsls	r3, r1, #1
    25f2:	1ac0      	subs	r0, r0, r3
    25f4:	4152      	adcs	r2, r2
    25f6:	1a41      	subs	r1, r0, r1
    25f8:	d200      	bcs.n	25fc <__udivsi3+0xf8>
    25fa:	4601      	mov	r1, r0
    25fc:	4152      	adcs	r2, r2
    25fe:	4610      	mov	r0, r2
    2600:	4770      	bx	lr
    2602:	e7ff      	b.n	2604 <__udivsi3+0x100>
    2604:	b501      	push	{r0, lr}
    2606:	2000      	movs	r0, #0
    2608:	f000 f806 	bl	2618 <__aeabi_idiv0>
    260c:	bd02      	pop	{r1, pc}
    260e:	46c0      	nop			; (mov r8, r8)

00002610 <__aeabi_uidivmod>:
    2610:	2900      	cmp	r1, #0
    2612:	d0f7      	beq.n	2604 <__udivsi3+0x100>
    2614:	e776      	b.n	2504 <__udivsi3>
    2616:	4770      	bx	lr

00002618 <__aeabi_idiv0>:
    2618:	4770      	bx	lr
    261a:	46c0      	nop			; (mov r8, r8)

0000261c <__clzsi2>:
    261c:	211c      	movs	r1, #28
    261e:	2301      	movs	r3, #1
    2620:	041b      	lsls	r3, r3, #16
    2622:	4298      	cmp	r0, r3
    2624:	d301      	bcc.n	262a <__clzsi2+0xe>
    2626:	0c00      	lsrs	r0, r0, #16
    2628:	3910      	subs	r1, #16
    262a:	0a1b      	lsrs	r3, r3, #8
    262c:	4298      	cmp	r0, r3
    262e:	d301      	bcc.n	2634 <__clzsi2+0x18>
    2630:	0a00      	lsrs	r0, r0, #8
    2632:	3908      	subs	r1, #8
    2634:	091b      	lsrs	r3, r3, #4
    2636:	4298      	cmp	r0, r3
    2638:	d301      	bcc.n	263e <__clzsi2+0x22>
    263a:	0900      	lsrs	r0, r0, #4
    263c:	3904      	subs	r1, #4
    263e:	a202      	add	r2, pc, #8	; (adr r2, 2648 <__clzsi2+0x2c>)
    2640:	5c10      	ldrb	r0, [r2, r0]
    2642:	1840      	adds	r0, r0, r1
    2644:	4770      	bx	lr
    2646:	46c0      	nop			; (mov r8, r8)
    2648:	02020304 	.word	0x02020304
    264c:	01010101 	.word	0x01010101
	...

00002658 <atoi>:
    2658:	b510      	push	{r4, lr}
    265a:	220a      	movs	r2, #10
    265c:	2100      	movs	r1, #0
    265e:	f000 f887 	bl	2770 <strtol>
    2662:	bd10      	pop	{r4, pc}

00002664 <_strtol_l.constprop.0>:
    2664:	b5f0      	push	{r4, r5, r6, r7, lr}
    2666:	b087      	sub	sp, #28
    2668:	001e      	movs	r6, r3
    266a:	9005      	str	r0, [sp, #20]
    266c:	9101      	str	r1, [sp, #4]
    266e:	9202      	str	r2, [sp, #8]
    2670:	2b01      	cmp	r3, #1
    2672:	d048      	beq.n	2706 <_strtol_l.constprop.0+0xa2>
    2674:	000b      	movs	r3, r1
    2676:	2e24      	cmp	r6, #36	; 0x24
    2678:	d845      	bhi.n	2706 <_strtol_l.constprop.0+0xa2>
    267a:	4a3b      	ldr	r2, [pc, #236]	; (2768 <_strtol_l.constprop.0+0x104>)
    267c:	2108      	movs	r1, #8
    267e:	4694      	mov	ip, r2
    2680:	001a      	movs	r2, r3
    2682:	4660      	mov	r0, ip
    2684:	7814      	ldrb	r4, [r2, #0]
    2686:	3301      	adds	r3, #1
    2688:	5d00      	ldrb	r0, [r0, r4]
    268a:	001d      	movs	r5, r3
    268c:	0007      	movs	r7, r0
    268e:	400f      	ands	r7, r1
    2690:	4208      	tst	r0, r1
    2692:	d1f5      	bne.n	2680 <_strtol_l.constprop.0+0x1c>
    2694:	2c2d      	cmp	r4, #45	; 0x2d
    2696:	d13d      	bne.n	2714 <_strtol_l.constprop.0+0xb0>
    2698:	2701      	movs	r7, #1
    269a:	781c      	ldrb	r4, [r3, #0]
    269c:	1c95      	adds	r5, r2, #2
    269e:	2e00      	cmp	r6, #0
    26a0:	d05e      	beq.n	2760 <_strtol_l.constprop.0+0xfc>
    26a2:	2e10      	cmp	r6, #16
    26a4:	d109      	bne.n	26ba <_strtol_l.constprop.0+0x56>
    26a6:	2c30      	cmp	r4, #48	; 0x30
    26a8:	d107      	bne.n	26ba <_strtol_l.constprop.0+0x56>
    26aa:	2220      	movs	r2, #32
    26ac:	782b      	ldrb	r3, [r5, #0]
    26ae:	4393      	bics	r3, r2
    26b0:	2b58      	cmp	r3, #88	; 0x58
    26b2:	d150      	bne.n	2756 <_strtol_l.constprop.0+0xf2>
    26b4:	2610      	movs	r6, #16
    26b6:	786c      	ldrb	r4, [r5, #1]
    26b8:	3502      	adds	r5, #2
    26ba:	4b2c      	ldr	r3, [pc, #176]	; (276c <_strtol_l.constprop.0+0x108>)
    26bc:	0031      	movs	r1, r6
    26be:	18fb      	adds	r3, r7, r3
    26c0:	0018      	movs	r0, r3
    26c2:	9303      	str	r3, [sp, #12]
    26c4:	f7ff ffa4 	bl	2610 <__aeabi_uidivmod>
    26c8:	2200      	movs	r2, #0
    26ca:	9104      	str	r1, [sp, #16]
    26cc:	2101      	movs	r1, #1
    26ce:	4684      	mov	ip, r0
    26d0:	0010      	movs	r0, r2
    26d2:	4249      	negs	r1, r1
    26d4:	0023      	movs	r3, r4
    26d6:	3b30      	subs	r3, #48	; 0x30
    26d8:	2b09      	cmp	r3, #9
    26da:	d903      	bls.n	26e4 <_strtol_l.constprop.0+0x80>
    26dc:	3b11      	subs	r3, #17
    26de:	2b19      	cmp	r3, #25
    26e0:	d81d      	bhi.n	271e <_strtol_l.constprop.0+0xba>
    26e2:	330a      	adds	r3, #10
    26e4:	429e      	cmp	r6, r3
    26e6:	dd1e      	ble.n	2726 <_strtol_l.constprop.0+0xc2>
    26e8:	1c54      	adds	r4, r2, #1
    26ea:	d009      	beq.n	2700 <_strtol_l.constprop.0+0x9c>
    26ec:	000a      	movs	r2, r1
    26ee:	4584      	cmp	ip, r0
    26f0:	d306      	bcc.n	2700 <_strtol_l.constprop.0+0x9c>
    26f2:	d102      	bne.n	26fa <_strtol_l.constprop.0+0x96>
    26f4:	9c04      	ldr	r4, [sp, #16]
    26f6:	429c      	cmp	r4, r3
    26f8:	db02      	blt.n	2700 <_strtol_l.constprop.0+0x9c>
    26fa:	2201      	movs	r2, #1
    26fc:	4370      	muls	r0, r6
    26fe:	1818      	adds	r0, r3, r0
    2700:	782c      	ldrb	r4, [r5, #0]
    2702:	3501      	adds	r5, #1
    2704:	e7e6      	b.n	26d4 <_strtol_l.constprop.0+0x70>
    2706:	f000 f85d 	bl	27c4 <__errno>
    270a:	2316      	movs	r3, #22
    270c:	6003      	str	r3, [r0, #0]
    270e:	2000      	movs	r0, #0
    2710:	b007      	add	sp, #28
    2712:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2714:	2c2b      	cmp	r4, #43	; 0x2b
    2716:	d1c2      	bne.n	269e <_strtol_l.constprop.0+0x3a>
    2718:	781c      	ldrb	r4, [r3, #0]
    271a:	1c95      	adds	r5, r2, #2
    271c:	e7bf      	b.n	269e <_strtol_l.constprop.0+0x3a>
    271e:	0023      	movs	r3, r4
    2720:	3b61      	subs	r3, #97	; 0x61
    2722:	2b19      	cmp	r3, #25
    2724:	d9dd      	bls.n	26e2 <_strtol_l.constprop.0+0x7e>
    2726:	1c53      	adds	r3, r2, #1
    2728:	d109      	bne.n	273e <_strtol_l.constprop.0+0xda>
    272a:	2322      	movs	r3, #34	; 0x22
    272c:	9a05      	ldr	r2, [sp, #20]
    272e:	9803      	ldr	r0, [sp, #12]
    2730:	6013      	str	r3, [r2, #0]
    2732:	9b02      	ldr	r3, [sp, #8]
    2734:	2b00      	cmp	r3, #0
    2736:	d0eb      	beq.n	2710 <_strtol_l.constprop.0+0xac>
    2738:	1e6b      	subs	r3, r5, #1
    273a:	9301      	str	r3, [sp, #4]
    273c:	e007      	b.n	274e <_strtol_l.constprop.0+0xea>
    273e:	2f00      	cmp	r7, #0
    2740:	d000      	beq.n	2744 <_strtol_l.constprop.0+0xe0>
    2742:	4240      	negs	r0, r0
    2744:	9b02      	ldr	r3, [sp, #8]
    2746:	2b00      	cmp	r3, #0
    2748:	d0e2      	beq.n	2710 <_strtol_l.constprop.0+0xac>
    274a:	2a00      	cmp	r2, #0
    274c:	d1f4      	bne.n	2738 <_strtol_l.constprop.0+0xd4>
    274e:	9b02      	ldr	r3, [sp, #8]
    2750:	9a01      	ldr	r2, [sp, #4]
    2752:	601a      	str	r2, [r3, #0]
    2754:	e7dc      	b.n	2710 <_strtol_l.constprop.0+0xac>
    2756:	2430      	movs	r4, #48	; 0x30
    2758:	2e00      	cmp	r6, #0
    275a:	d1ae      	bne.n	26ba <_strtol_l.constprop.0+0x56>
    275c:	3608      	adds	r6, #8
    275e:	e7ac      	b.n	26ba <_strtol_l.constprop.0+0x56>
    2760:	2c30      	cmp	r4, #48	; 0x30
    2762:	d0a2      	beq.n	26aa <_strtol_l.constprop.0+0x46>
    2764:	260a      	movs	r6, #10
    2766:	e7a8      	b.n	26ba <_strtol_l.constprop.0+0x56>
    2768:	00002b19 	.word	0x00002b19
    276c:	7fffffff 	.word	0x7fffffff

00002770 <strtol>:
    2770:	b510      	push	{r4, lr}
    2772:	4c04      	ldr	r4, [pc, #16]	; (2784 <strtol+0x14>)
    2774:	0013      	movs	r3, r2
    2776:	000a      	movs	r2, r1
    2778:	0001      	movs	r1, r0
    277a:	6820      	ldr	r0, [r4, #0]
    277c:	f7ff ff72 	bl	2664 <_strtol_l.constprop.0>
    2780:	bd10      	pop	{r4, pc}
    2782:	46c0      	nop			; (mov r8, r8)
    2784:	1ffffec4 	.word	0x1ffffec4

00002788 <memset>:
    2788:	0003      	movs	r3, r0
    278a:	1882      	adds	r2, r0, r2
    278c:	4293      	cmp	r3, r2
    278e:	d100      	bne.n	2792 <memset+0xa>
    2790:	4770      	bx	lr
    2792:	7019      	strb	r1, [r3, #0]
    2794:	3301      	adds	r3, #1
    2796:	e7f9      	b.n	278c <memset+0x4>

00002798 <strstr>:
    2798:	780a      	ldrb	r2, [r1, #0]
    279a:	b530      	push	{r4, r5, lr}
    279c:	2a00      	cmp	r2, #0
    279e:	d10c      	bne.n	27ba <strstr+0x22>
    27a0:	bd30      	pop	{r4, r5, pc}
    27a2:	429a      	cmp	r2, r3
    27a4:	d108      	bne.n	27b8 <strstr+0x20>
    27a6:	2301      	movs	r3, #1
    27a8:	5ccc      	ldrb	r4, [r1, r3]
    27aa:	2c00      	cmp	r4, #0
    27ac:	d0f8      	beq.n	27a0 <strstr+0x8>
    27ae:	5cc5      	ldrb	r5, [r0, r3]
    27b0:	42a5      	cmp	r5, r4
    27b2:	d101      	bne.n	27b8 <strstr+0x20>
    27b4:	3301      	adds	r3, #1
    27b6:	e7f7      	b.n	27a8 <strstr+0x10>
    27b8:	3001      	adds	r0, #1
    27ba:	7803      	ldrb	r3, [r0, #0]
    27bc:	2b00      	cmp	r3, #0
    27be:	d1f0      	bne.n	27a2 <strstr+0xa>
    27c0:	0018      	movs	r0, r3
    27c2:	e7ed      	b.n	27a0 <strstr+0x8>

000027c4 <__errno>:
    27c4:	4b01      	ldr	r3, [pc, #4]	; (27cc <__errno+0x8>)
    27c6:	6818      	ldr	r0, [r3, #0]
    27c8:	4770      	bx	lr
    27ca:	46c0      	nop			; (mov r8, r8)
    27cc:	1ffffec4 	.word	0x1ffffec4

000027d0 <__libc_init_array>:
    27d0:	b570      	push	{r4, r5, r6, lr}
    27d2:	2600      	movs	r6, #0
    27d4:	4c0c      	ldr	r4, [pc, #48]	; (2808 <__libc_init_array+0x38>)
    27d6:	4d0d      	ldr	r5, [pc, #52]	; (280c <__libc_init_array+0x3c>)
    27d8:	1b64      	subs	r4, r4, r5
    27da:	10a4      	asrs	r4, r4, #2
    27dc:	42a6      	cmp	r6, r4
    27de:	d109      	bne.n	27f4 <__libc_init_array+0x24>
    27e0:	2600      	movs	r6, #0
    27e2:	f000 fa1b 	bl	2c1c <_init>
    27e6:	4c0a      	ldr	r4, [pc, #40]	; (2810 <__libc_init_array+0x40>)
    27e8:	4d0a      	ldr	r5, [pc, #40]	; (2814 <__libc_init_array+0x44>)
    27ea:	1b64      	subs	r4, r4, r5
    27ec:	10a4      	asrs	r4, r4, #2
    27ee:	42a6      	cmp	r6, r4
    27f0:	d105      	bne.n	27fe <__libc_init_array+0x2e>
    27f2:	bd70      	pop	{r4, r5, r6, pc}
    27f4:	00b3      	lsls	r3, r6, #2
    27f6:	58eb      	ldr	r3, [r5, r3]
    27f8:	4798      	blx	r3
    27fa:	3601      	adds	r6, #1
    27fc:	e7ee      	b.n	27dc <__libc_init_array+0xc>
    27fe:	00b3      	lsls	r3, r6, #2
    2800:	58eb      	ldr	r3, [r5, r3]
    2802:	4798      	blx	r3
    2804:	3601      	adds	r6, #1
    2806:	e7f2      	b.n	27ee <__libc_init_array+0x1e>
    2808:	00002c28 	.word	0x00002c28
    280c:	00002c28 	.word	0x00002c28
    2810:	00002c30 	.word	0x00002c30
    2814:	00002c28 	.word	0x00002c28

00002818 <memcpy>:
    2818:	2300      	movs	r3, #0
    281a:	b510      	push	{r4, lr}
    281c:	429a      	cmp	r2, r3
    281e:	d100      	bne.n	2822 <memcpy+0xa>
    2820:	bd10      	pop	{r4, pc}
    2822:	5ccc      	ldrb	r4, [r1, r3]
    2824:	54c4      	strb	r4, [r0, r3]
    2826:	3301      	adds	r3, #1
    2828:	e7f8      	b.n	281c <memcpy+0x4>

0000282a <strlen>:
    282a:	2300      	movs	r3, #0
    282c:	5cc2      	ldrb	r2, [r0, r3]
    282e:	3301      	adds	r3, #1
    2830:	2a00      	cmp	r2, #0
    2832:	d1fb      	bne.n	282c <strlen+0x2>
    2834:	1e58      	subs	r0, r3, #1
    2836:	4770      	bx	lr
    2838:	79616c50 	.word	0x79616c50
    283c:	20676e69 	.word	0x20676e69
    2840:	73726946 	.word	0x73726946
    2844:	69462074 	.word	0x69462074
    2848:	0a00656c 	.word	0x0a00656c
    284c:	79616c50 	.word	0x79616c50
    2850:	20676e69 	.word	0x20676e69
    2854:	63617274 	.word	0x63617274
    2858:	0023206b 	.word	0x0023206b
    285c:	6c696146 	.word	0x6c696146
    2860:	74206465 	.word	0x74206465
    2864:	6c70206f 	.word	0x6c70206f
    2868:	74207961 	.word	0x74207961
    286c:	6b636172 	.word	0x6b636172
    2870:	003f      	.short	0x003f
    2872:	6441      	.short	0x6441
    2874:	75726661 	.word	0x75726661
    2878:	53207469 	.word	0x53207469
    287c:	646e756f 	.word	0x646e756f
    2880:	616f4220 	.word	0x616f4220
    2884:	00216472 	.word	0x00216472
    2888:	20746f4e 	.word	0x20746f4e
    288c:	6e756f66 	.word	0x6e756f66
    2890:	46530064 	.word	0x46530064
    2894:	6f622058 	.word	0x6f622058
    2898:	20647261 	.word	0x20647261
    289c:	6e756f66 	.word	0x6e756f66
    28a0:	0064      	.short	0x0064
    28a2:	2d2d      	.short	0x2d2d
    28a4:	00203e2d 	.word	0x00203e2d
    28a8:	66616441 	.word	0x66616441
    28ac:	74697572 	.word	0x74697572
    28b0:	20584620 	.word	0x20584620
    28b4:	6e756f53 	.word	0x6e756f53
    28b8:	6f422064 	.word	0x6f422064
    28bc:	00647261 	.word	0x00647261
    28c0:	79616c70 	.word	0x79616c70
    28c4:	ffffff00 	.word	0xffffff00

000028c8 <vtable for Adafruit_Soundboard>:
	...
    28d0:	000005d5 0000088d 000005b1 000005b5     ................

000028e0 <vtable for HardwareSerial2>:
	...
    28e8:	000007a9 000007cd 00000885 0000087d     ............}...
    28f8:	00000875 0000086d 00000865 00000771     u...m...e...q...
    2908:	00000845 0000083d 00000833 00000829     E...=...3...)...
    2918:	0000081d 0000080d 000007fd 000007f5     ................
    2928:	000007e9 000007dd 00000741 0000074d     ........A...M...
    2938:	00000759 00000765 000007b5 0000079d     Y...e...........

00002948 <CSWTCH.29>:
    2948:	090a0c08 ffffff0b                       ........

00002950 <digital_pin_to_info_PGM>:
    2950:	f8000042 4004a040 00000001 f8000042     B...@..@....B...
    2960:	4004a044 00000002 f80000c0 4004c000     D..@...........@
    2970:	00000001 f8000000 40049004 00000002     ...........@....
    2980:	f8000000 40049008 00000004 f80000c0     .......@........
    2990:	4004c01c 00000080 f80000c0 4004c010     ...@...........@
    29a0:	00000010 f80000c0 4004c008 00000004     ...........@....
    29b0:	f80000c0 4004c00c 00000008 f8000080     .......@........
    29c0:	4004b00c 00000008 f8000080 4004b010     ...@...........@
    29d0:	00000010 f8000080 4004b018 00000040     ...........@@...
    29e0:	f8000080 4004b01c 00000080 f8000080     .......@........
    29f0:	4004b014 00000020 f80000c0 4004c004     ...@ ..........@
    2a00:	00000002 f8000080 4004b000 00000001     ...........@....
    2a10:	f8000040 4004a000 00000001 f8000040     @......@....@...
    2a20:	4004a004 00000002 f8000040 4004a00c     ...@....@......@
    2a30:	00000008 f8000040 4004a008 00000004     ....@......@....
    2a40:	f80000c0 4004c014 00000020 f80000c0     .......@ .......
    2a50:	4004c018 00000040 f8000080 4004b004     ...@@..........@
    2a60:	00000002 f8000080 4004b008 00000004     ...........@....
    2a70:	f8000102 4004d050 00000010 f8000102     ....P..@........
    2a80:	4004d054 00000020 f8000103 4004d078     T..@ .......x..@
    2a90:	00000040                                @...

00002a94 <vtable for usb_serial_class>:
	...
    2a9c:	00001f0d 00001f01 00001ef9 00001ef1     ................
    2aac:	00001ee9 00001ee1 00001ed9 00001ed1     ................

00002abc <_serialEvent_default>:
    2abc:	ffffff00                                ....

00002ac0 <usb_descriptor_list>:
    2ac0:	00000100 1ffffe1e 00000012 00000200     ................
    2ad0:	1ffffddb 00000043 00000300 1ffffe30     ....C.......0...
    2ae0:	00000000 04090301 1ffffe34 00000000     ........4.......
    2af0:	04090302 1ffffe4c 00000000 04090303     ....L...........
    2b00:	1ffffe62 00000000 00000000 00000000     b...............
    2b10:	00000000                                ....

00002b14 <usb_endpoint_config_table>:
    2b14:	15191500                                ....

00002b18 <_ctype_>:
    2b18:	20202000 20202020 28282020 20282828     .         ((((( 
    2b28:	20202020 20202020 20202020 20202020                     
    2b38:	10108820 10101010 10101010 10101010      ...............
    2b48:	04040410 04040404 10040404 10101010     ................
    2b58:	41411010 41414141 01010101 01010101     ..AAAAAA........
    2b68:	01010101 01010101 01010101 10101010     ................
    2b78:	42421010 42424242 02020202 02020202     ..BBBBBB........
    2b88:	02020202 02020202 02020202 10101010     ................
    2b98:	00000020 00000000 00000000 00000000      ...............
	...
    2c18:	ffffff00                                ....

00002c1c <_init>:
    2c1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2c1e:	46c0      	nop			; (mov r8, r8)
    2c20:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2c22:	bc08      	pop	{r3}
    2c24:	469e      	mov	lr, r3
    2c26:	4770      	bx	lr

00002c28 <__frame_dummy_init_array_entry>:
    2c28:	0439 0000 04dd 0000                         9.......

Disassembly of section .fini:

00002c30 <_fini>:
    2c30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2c32:	46c0      	nop			; (mov r8, r8)
